<?xml version="1.0" encoding="GB2312"?>
<root cmdName="通讯工具命令表">
  <Command cmdname="超级终端模式" cmdType="P" cmd="[P]void main()&#xA;{&#xA;    SetLayoutMode(0);&#xA;    ClearOutputWin();   //清除输出窗口内容&#xA;    ClearCommWin();&#xA;    CloseInputWin();&#xA;    ShowTerminalWin();&#xA;    HideLeftTools();&#xA;    HideRightTools();&#xA;    ClearVclControls();&#xA;    HideVclWin();&#xA;}"/>
  <Command cmdname="编程布局" cmdType="P" cmd="[P]void main()&#xA;{&#xA;    SetLayoutMode(1);&#xA;    CloseOutputWin();&#xA;    HideLeftTools();&#xA;    HideRightTools();&#xA;    HideVclWin();&#xA;}"/>
  <Command cmdname="默认布局" cmdType="P" cmd="[P]void main()&#xA;{&#xA;   //ClearOutput();   //清除输出窗口内容  &#xA;   //ClearCommWin();&#xA;   SetLayoutMode(0);&#xA;   OpenInputWin();&#xA;   HideTerminalWin();&#xA;   ClearVclControls();&#xA;   HideVclWin();&#xA;   HideLeftTools();&#xA;   HideRightTools();&#xA;}"/>
  <Command cmdname="计算器" cmdType="P" cmd="[P]void main()&#xA;{&#xA;    WinExec(&quot;calc.exe&quot;);&#xA;&#xA;}"/>
  <Command cmdname="Windows系统工具" cmdType="S" cmd="[S]new command">
    <Command cmdname="计算器" cmdType="P" cmd="[P]void main()&#xA;{&#xA;    WinExec(&quot;calc.exe&quot;);&#xA;&#xA;}"/>
    <Command cmdname="记事本" cmdType="P" cmd="[P]void main()&#xA;{&#xA;    WinExec(&quot;notepad.exe&quot;);&#xA;}"/>
    <Command cmdname="命令行" cmdType="P" cmd="[P]void main()&#xA;{&#xA;    WinExec(&quot;cmd.exe&quot;);&#xA;}"/>
    <Command cmdname="画图" cmdType="P" cmd="[P]&#xA;void main()&#xA;{&#xA;    WinExec(&quot;mspaint.exe&quot;);&#xA;}"/>
    <Command cmdname="Windows 超级终端:COM]" cmdType="P" cmd="[P]&#xA;void main()&#xA;{&#xA;    WinExec(&quot;C:\\Program Files\\Windows NT\\hypertrm.exe C:\\Documents and Settings\\Administrator\\「开始」菜单\\程序\\附件\\通讯\\超级终端\\com 1&quot;);&#xA;&#xA;}&#xA;"/>
  </Command>
  <Command cmdname="实用工具" cmdType="S" cmd="[S]数据发送区&#xA;">
    <Command cmdname="超级终端" cmdType="P" cmd="[P]void main()&#xA;{&#xA;   ClearOutputWin();   //清除输出窗口内容&#xA;   ClearCommWin();&#xA;   CloseInputWin();&#xA;   ShowTerminalWin();&#xA;   HideLeftTools();&#xA;   HideRightTools();&#xA;   ClearVclControls();&#xA;   HideVclWin();&#xA;}"/>
    <Command cmdname="定时发送" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;int edt1;&#xA;int cbHex;&#xA;int cbx1;&#xA;int tmr1;&#xA;int btn0,btn1,btn2;&#xA;void OnClose(int *sender)&#xA;{&#xA;    HideVclWin();&#xA;    CloseVclWin();&#xA;    ////PrintToCommWin(&quot;over&quot;);&#xA;&#xA;}&#xA;void OnStart(void *sender)&#xA;{&#xA;    char s[200];&#xA;    GetProperty(cbx1,&quot;text&quot;,s,20);&#xA;    int inv=atoi(s);&#xA;    printf(&quot;%d&quot;,inv);&#xA;    SetProperty(tmr1,&quot;interval&quot;,inv);&#xA;    SetProperty(tmr1,&quot;enabled&quot;,1);&#xA;    SetProperty(btn1,&quot;enabled&quot;,0);&#xA;    SetProperty(btn2,&quot;enabled&quot;,1);&#xA;&#xA;    //myForm.btnStart.Enabled=false;&#xA;    //myForm.btnStop.Enabled=true;&#xA;}&#xA;void OnStop()&#xA;{&#xA;    SetProperty(tmr1,&quot;enabled&quot;,0);&#xA;    SetProperty(btn1,&quot;enabled&quot;,1);&#xA;    SetProperty(btn2,&quot;enabled&quot;,0);&#xA;&#xA;}&#xA;void OnTimer()&#xA;{&#xA;    char s[200];&#xA;    int ck;&#xA;    //PrintToCommWin(&quot;abc&quot;);&#xA;    ck=GetProperty(cbHex,&quot;checked&quot;,s,4);&#xA;    //printf(&quot;checked:%s&quot;,s);&#xA;    GetProperty(edt1,&quot;text&quot;,s,200);&#xA;    if(ck==1)&#xA;        SendHexString(s);&#xA;    else&#xA;        SendString(s);&#xA;}&#xA;&#xA;&#xA;void main()&#xA;{&#xA;    ClearOutputWin();   //清除输出窗口内容&#xA;    ClearCommWin();&#xA;    //CloseInputWin();&#xA;    CloseCodeWin();//&#xA;    HideLeftTools();&#xA;    HideRightTools();&#xA;    HideOutputWin();&#xA;    ClearVclControls();&#xA;    int p=GetGuiWin(0);&#xA;&#xA;    btn0=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,     &quot;left&quot;,230,&quot;top&quot;,70,&quot;width&quot;,100,&quot;height&quot;,30,&quot;onclick&quot;,OnClose,NULL);//创建按钮&#xA;    btn1=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;开始发送&quot;, &quot;left&quot;,10,&quot;top&quot;,70,&quot;width&quot;,100,&quot;height&quot;,30,&quot;onclick&quot;,OnStart,NULL);//创建按钮&#xA;    btn2=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;停止发送&quot;, &quot;left&quot;,120,&quot;top&quot;,70,&quot;width&quot;,100,&quot;height&quot;,30,&quot;onclick&quot;,OnStop,NULL);//创建按钮&#xA;    int lbl1=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;发送内容:&quot;,&quot;left&quot;,10,&quot;top&quot;,8,&quot;width&quot;,90,&quot;height&quot;,20,NULL);//创建按钮&#xA;    edt1=CreateComponentEx(p,&quot;edit&quot;,  &quot;text&quot;,   &quot;123456&quot;,   &quot;left&quot;,70,&quot;top&quot;,5,&quot;width&quot;,260,&quot;height&quot;,20,NULL);//创建按钮&#xA;    cbHex=CreateComponentEx(p,&quot;checkbox&quot;,&quot;caption&quot;,&quot;十六进制发送&quot;,&quot;left&quot;,10,&quot;top&quot;,35,&quot;width&quot;,100,&quot;height&quot;,20,NULL);//创建按钮&#xA;    int lbl2=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;发送间隔:&quot;,&quot;left&quot;,145,&quot;top&quot;,37,&quot;width&quot;,70,&quot;height&quot;,20,NULL);//创建按钮&#xA;    cbx1=CreateComponentEx(p,&quot;combobox&quot;,&quot;text&quot;,&quot;200&quot;,&quot;left&quot;,203,&quot;top&quot;,35,&quot;width&quot;,60,&quot;height&quot;,20,NULL);//创建按钮&#xA;    int lbl3=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;毫秒&quot;,&quot;left&quot;,270,&quot;top&quot;,37,&quot;width&quot;,70,&quot;height&quot;,20,NULL);//创建按钮&#xA;    tmr1=CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,500,&quot;enabled&quot;,0,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮&#xA;    //int img=CreateComponentEx(p,&quot;image&quot;,&quot;left&quot;,20,&quot;top&quot;,170,&quot;width&quot;,100,&quot;height&quot;,130,NULL);//创建按钮&#xA;    //int canvas=GetProperty(img,&quot;canvas&quot;,0,0);&#xA;    //LineTo(canvas,100,100);&#xA;    StringsAdd(cbx1,&quot;1&quot;);    &#xA;    StringsAdd(cbx1,&quot;100&quot;);&#xA;    StringsAdd(cbx1,&quot;200&quot;);&#xA;    StringsAdd(cbx1,&quot;500&quot;);&#xA;    StringsAdd(cbx1,&quot;1000&quot;);&#xA;    //ShowVclWin(120);&#xA;    AutoSetVclWinSize();&#xA;&#xA;}&#xA;"/>
    <Command cmdname="数据求和" cmdType="P" cmd="[P]&#xA;void OnGetSelDat();&#xA;void OnGetAllDat();&#xA;void OnSum();&#xA;void OnClose()&#xA;{&#xA;    HideVclWin();&#xA;    // printf(&quot;hided&quot;);&#xA;    CloseVclWin();&#xA;}&#xA;&#xA;int edtSdTxt;&#xA;int edtSumTxt;&#xA;int edtSumTxt1;&#xA;int edtDatLen;&#xA;void main()&#xA;{&#xA;    ClearOutputWin(); //清除输出窗口内容&#xA;    ClearCommWin();&#xA;    CloseCodeWin();&#xA;    HideRightTools();&#xA;    Update();&#xA;    ClearVclControls();&#xA;    int p=GetGuiWin(0);&#xA;    CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;十六进制求和数据:&quot;,&quot;left&quot;,10,&quot;top&quot;,8,&quot;width&quot;,170,&quot;height&quot;,20,0);&#xA;    edtSdTxt=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;12 D4 AA 8E&quot;,&quot;left&quot;,120,&quot;top&quot;,5,&quot;width&quot;,270,&quot;height&quot;,20,0);&#xA;    int button0=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;取发送区反选数据&quot;,&quot;left&quot;,400,&quot;top&quot;,5,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnGetSelDat,0);&#xA;    int button1=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;取发送区所有数据&quot;,&quot;left&quot;,400,&quot;top&quot;,38,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnGetAllDat,0);&#xA;    CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;十进制求和结果:&quot;,&quot;left&quot;,10,&quot;top&quot;,38,&quot;width&quot;,170,&quot;height&quot;,20,0);&#xA;    edtSumTxt=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;&quot;,&quot;left&quot;,120,&quot;top&quot;,35,&quot;width&quot;,70,&quot;height&quot;,20,0);&#xA;    int lblDatLen=CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;数据长度:&quot;,&quot;left&quot;,10,&quot;top&quot;,60,&quot;width&quot;,170,&quot;height&quot;,20,0);&#xA;    edtDatLen=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;&quot;,&quot;left&quot;,120,&quot;top&quot;,60,&quot;width&quot;,70,&quot;height&quot;,20,0);&#xA;    int lblSumTxt1=CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;16进制结果(8bit):&quot;,&quot;left&quot;,200,&quot;top&quot;,38,&quot;width&quot;,170,&quot;height&quot;,20,0);&#xA;    edtSumTxt1=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;&quot;,&quot;left&quot;,300,&quot;top&quot;,35,&quot;width&quot;,70,&quot;height&quot;,20,0);&#xA;    int button2=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;求和&quot;,&quot;left&quot;,10,&quot;top&quot;,85,&quot;width&quot;,240,&quot;height&quot;,30,&quot;onclick&quot;,OnSum,0);&#xA;    int button1=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,260,&quot;top&quot;,85,&quot;width&quot;,240,&quot;height&quot;,30,&quot;onclick&quot;,OnClose,0);&#xA;    //ShowVclWin(150);&#xA;    //ShowOutputWin(200);&#xA;    AutoSetVclWinSize();&#xA;}&#xA;void OnGetSelDat()&#xA;{&#xA;    char s[2000];&#xA;    GetInputWinSelText(s,2000);&#xA;    if(strlen(s)==0) return;&#xA;    SetProperty(edtSdTxt,&quot;text&quot;,s);&#xA;    OnSum();&#xA;}&#xA;void OnGetAllDat()&#xA;{&#xA;    char s[2000];&#xA;    GetInputWinText(s,2000);&#xA;    if(strlen(s)==0) return;&#xA;    SetProperty(edtSdTxt,&quot;text&quot;,s);&#xA;    OnSum();&#xA;}&#xA;&#xA;&#xA;int GetVal(int val)&#xA;{&#xA;    if((val&gt;=48)&amp;&amp;(val&lt;=57))&#xA;        return val-48;&#xA;    else if((val&gt;=97)&amp;&amp;(val&lt;=102))&#xA;        return val+10-97;&#xA;    else if((val&gt;=65)&amp;&amp;(val&lt;=70))&#xA;        return val+10-65;&#xA;&#xA;    return 0;&#xA;}&#xA;&#xA;void isDigit(int val)&#xA;{&#xA;    if((val&gt;=48)&amp;&amp;(val&lt;=57))&#xA;        return 1;&#xA;    else if((val&gt;=97)&amp;&amp;(val&lt;=102))&#xA;        return 1;&#xA;    else if((val&gt;=65)&amp;&amp;(val&lt;=70))&#xA;        return 1;&#xA;    return 0;&#xA;}&#xA;&#xA;void OnSum()&#xA;{&#xA;    int val,val1,gotfirst;&#xA;&#xA;    char s[2000];&#xA;    GetProperty(edtSdTxt,&quot;text&quot;,s,2000);&#xA;&#xA;    //s=myForm.edtSdTxt.Text;&#xA;    int i=0;&#xA;    int sum=0;&#xA;    gotfirst=0;&#xA;    int len=0;&#xA;    int ls=strlen(s);&#xA;    while(i&lt;ls)&#xA;    {&#xA;        i=i+1;&#xA;        if(gotfirst==0)&#xA;        {&#xA;            val=s[i-1];&#xA;            if(isDigit(val))&#xA;                gotfirst=1;&#xA;        }&#xA;        else&#xA;        {&#xA;            val1=s[i-1];&#xA;            if(isDigit(val1))&#xA;            {&#xA;                sum=sum+GetVal(val)*16+GetVal(val1);&#xA;                len=len+1;&#xA;                gotfirst=0;&#xA;            }&#xA;            else&#xA;            {&#xA;                sum=sum+GetVal(val);&#xA;                len=len+1;&#xA;                gotfirst=0;&#xA;            }&#xA;        }&#xA;    }&#xA;    if(gotfirst==1)&#xA;    {&#xA;        sum=sum+GetVal(val);&#xA;        len=len+1;&#xA;    }&#xA;    sprintf(s,&quot;%d&quot;,sum);&#xA;    SetProperty(edtSumTxt,&quot;text&quot;,s);&#xA;    sprintf(s,&quot;%x&quot;,sum);&#xA;    SetProperty(edtSumTxt1,&quot;text&quot;,s);&#xA;    sprintf(s,&quot;%d&quot;,len);&#xA;    SetProperty(edtDatLen,&quot;text&quot;,s);&#xA;&#xA;}&#xA;"/>
    <Command cmdname="数据异或" cmdType="P" cmd="[P]&#xA;void OnGetSelDat();&#xA;void OnGetAllDat();&#xA;void OnSum();&#xA;void OnClose()&#xA;{&#xA;    HideVclWin();&#xA;    // printf(&quot;hided&quot;);&#xA;    CloseVclWin();&#xA;}&#xA;&#xA;int edtSdTxt;&#xA;int edtSumTxt;&#xA;int edtSumTxt1;&#xA;int edtDatLen;&#xA;void main()&#xA;{&#xA;    ClearOutputWin(); //清除输出窗口内容&#xA;    ClearCommWin();&#xA;    CloseCodeWin();&#xA;    HideRightTools();&#xA;    Update();&#xA;    ClearVclControls();&#xA;    int p=GetGuiWin();&#xA;    CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;十六进制求和数据:&quot;,&quot;left&quot;,10,&quot;top&quot;,8,&quot;width&quot;,170,&quot;height&quot;,20,0);&#xA;    edtSdTxt=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;12 D4 AA 8E&quot;,&quot;left&quot;,120,&quot;top&quot;,5,&quot;width&quot;,270,&quot;height&quot;,20,0);&#xA;    int button0=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;取发送区反选数据&quot;,&quot;left&quot;,400,&quot;top&quot;,5,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnGetSelDat,0);&#xA;    int button1=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;取发送区所有数据&quot;,&quot;left&quot;,400,&quot;top&quot;,38,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnGetAllDat,0);&#xA;    CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;十进制求和结果:&quot;,&quot;left&quot;,10,&quot;top&quot;,38,&quot;width&quot;,170,&quot;height&quot;,20,0);&#xA;    edtSumTxt=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;&quot;,&quot;left&quot;,120,&quot;top&quot;,35,&quot;width&quot;,70,&quot;height&quot;,20,0);&#xA;    int lblDatLen=CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;数据长度:&quot;,&quot;left&quot;,10,&quot;top&quot;,60,&quot;width&quot;,170,&quot;height&quot;,20,0);&#xA;    edtDatLen=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;&quot;,&quot;left&quot;,120,&quot;top&quot;,60,&quot;width&quot;,70,&quot;height&quot;,20,0);&#xA;    int lblSumTxt1=CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;16进制结果(8bit):&quot;,&quot;left&quot;,200,&quot;top&quot;,38,&quot;width&quot;,170,&quot;height&quot;,20,0);&#xA;    edtSumTxt1=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;&quot;,&quot;left&quot;,300,&quot;top&quot;,35,&quot;width&quot;,70,&quot;height&quot;,20,0);&#xA;    int button2=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;求和&quot;,&quot;left&quot;,10,&quot;top&quot;,85,&quot;width&quot;,240,&quot;height&quot;,30,&quot;onclick&quot;,OnSum,0);&#xA;    int button1=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,260,&quot;top&quot;,85,&quot;width&quot;,240,&quot;height&quot;,30,&quot;onclick&quot;,OnClose,0);&#xA;    AutoSetVclWinSize();&#xA;}&#xA;char s[2000];&#xA;void OnGetSelDat()&#xA;{&#xA;&#xA;    GetInputWinSelText(s,2000);&#xA;    if(strlen(s)==0) return;&#xA;    SetProperty(edtSdTxt,&quot;text&quot;,s);&#xA;    OnSum();&#xA;}&#xA;void OnGetAllDat()&#xA;{&#xA;    //char s[2000];&#xA;    GetInputWinText(s,2000);&#xA;    if(strlen(s)==0) return;&#xA;    SetProperty(edtSdTxt,&quot;text&quot;,s);&#xA;    OnSum();&#xA;}&#xA;&#xA;&#xA;int GetVal(int val)&#xA;{&#xA;    if((val&gt;=48)&amp;&amp;(val&lt;=57))&#xA;        return val-48;&#xA;    else if((val&gt;=97)&amp;&amp;(val&lt;=102))&#xA;        return val+10-97;&#xA;    else if((val&gt;=65)&amp;&amp;(val&lt;=70))&#xA;        return val+10-65;&#xA;&#xA;    return 0;&#xA;}&#xA;&#xA;void isDigit(int val)&#xA;{&#xA;    if((val&gt;=48)&amp;&amp;(val&lt;=57))&#xA;        return 1;&#xA;    else if((val&gt;=97)&amp;&amp;(val&lt;=102))&#xA;        return 1;&#xA;    else if((val&gt;=65)&amp;&amp;(val&lt;=70))&#xA;        return 1;&#xA;    return 0;&#xA;}&#xA;&#xA;void OnSum()&#xA;{&#xA;    int val,val1,gotfirst;&#xA;&#xA;    //char s[2000];&#xA;    GetProperty(edtSdTxt,&quot;text&quot;,s,2000);&#xA;&#xA;    //   s=myForm.edtSdTxt.Text;&#xA;    int i=0;&#xA;    int sum=0;&#xA;    gotfirst=0;&#xA;    int len=0;&#xA;    int ls=strlen(s);&#xA;    while(i&lt;ls)&#xA;    {&#xA;        i=i+1;&#xA;        if(gotfirst==0)&#xA;        {&#xA;            val=s[i-1];&#xA;            if(isDigit(val))&#xA;                gotfirst=1;&#xA;        }&#xA;        else&#xA;        {&#xA;            val1=s[i-1];&#xA;            if(isDigit(val1))&#xA;            {&#xA;                sum=sum^(GetVal(val)*16)^GetVal(val1);&#xA;                len=len+1;&#xA;                gotfirst=0;&#xA;            }&#xA;            else&#xA;            {&#xA;                sum=sum^GetVal(val);&#xA;                len=len+1;&#xA;                gotfirst=0;&#xA;            }&#xA;        }&#xA;    }&#xA;    if(gotfirst==1)&#xA;    {&#xA;        sum=sum^GetVal(val);&#xA;        len=len+1;&#xA;    }&#xA;    sprintf(s,&quot;%d&quot;,sum);&#xA;    SetProperty(edtSumTxt,&quot;text&quot;,s);&#xA;    sprintf(s,&quot;%x&quot;,sum);&#xA;    SetProperty(edtSumTxt1,&quot;text&quot;,s);&#xA;    sprintf(s,&quot;%d&quot;,len);&#xA;    SetProperty(edtDatLen,&quot;text&quot;,s);&#xA;&#xA;}&#xA;"/>
    <Command cmdname="Ctrl+C" cmdType="H" cmd="[H]03"/>
    <Command cmdname="ZModem发送文件" cmdType="P" cmd="[P]void main()&#xA;{&#xA;   PrintToCommWin(&quot;Start transmit...&quot;);&#xA;   ZModemSendFile(&quot;C:\\crash.txt&quot;,1);&#xA;   PrintToCommWin(&quot;Transmit over.&quot;);&#xA;}"/>
    <Command cmdname="Bin2Hex" cmdType="P" cmd="[P]#include &lt;stdio.h&gt;&#xA;#include &lt;string.h&gt;&#xA;&#xA;#define BUF_LEN 1&#xA;#define LINE     31&#xA;int p;&#xA;&#xA;int edt1,edt2,edt3;&#xA;void Trans();&#xA;long int filesize( FILE *fp )&#xA;{&#xA;    long int save_pos, size_of_file;&#xA;&#xA;    save_pos = ftell( fp );&#xA;    fseek( fp, 0L, SEEK_END );&#xA;    size_of_file = ftell( fp );&#xA;    fseek( fp, save_pos, SEEK_SET );&#xA;    return( size_of_file );&#xA;}&#xA;&#xA;void Upper_chars(char *buffer)&#xA;{&#xA;    unsigned int c;&#xA;&#xA;    for (c=0; c &lt;= strlen(buffer)-1; c++) *(buffer+c)=toupper( *(buffer+c) );&#xA;}&#xA;void OpenFileClick(void *sender)&#xA;{&#xA;    char s[200];&#xA;    GetFileName(s,200,&quot;*.*&quot;);&#xA;    if(strlen(s)&gt;0)&#xA;    {&#xA;        SetProperty(edt1,&quot;text&quot;,s);&#xA;    }&#xA;}&#xA;void OpenFileClick1(void *sender)&#xA;{&#xA;    char s[200];&#xA;    GetFileName(s,200);&#xA;    if(strlen(s)&gt;0)&#xA;    {&#xA;        SetProperty(edt2,&quot;text&quot;,s);&#xA;    }&#xA;}&#xA;void CloseClick(void *Sender)&#xA;{&#xA;&#xA;    ClearOutputWin();   //清除输出窗口内容&#xA;    HideVclWin();&#xA;&#xA;    CloseVclWin();&#xA;    CloseForm(p);&#xA;}&#xA;&#xA;void ViewC()&#xA;{&#xA;    char s[200],s1[200];&#xA;    GetProperty(edt2,&quot;text&quot;,s,200);&#xA;    sprintf(s1,&quot;notepad.exe %s&quot;,s);&#xA;    WinExec(s1);&#xA;&#xA;}&#xA;void CreateGui()&#xA;{&#xA;    CloseCodeWin();&#xA;    ClearVclControls();&#xA;&#xA;    int GuiMode=2;&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;        p=GetGuiWin(GuiMode);&#xA;    else&#xA;        p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;Bin2Hex工具&quot;,&quot;Width&quot;,570,&quot;height&quot;,150,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;, &quot;visible&quot;,1,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;&#xA;    int pnl =p; //CreateComponentEx(p,&quot;panel&quot;,&quot;caption&quot;,&quot;&quot;,&quot;left&quot;,2,&quot;top&quot;,2,&quot;width&quot;,610,&quot;height&quot;,160,NULL);&#xA;    //int txt1= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;                                             Bin2Hex工具&quot;,&quot;left&quot;,30,&quot;top&quot;,10,&quot;width&quot;,350,&quot;color&quot;,0xff00ff,NULL);&#xA;    int txt2= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;二进制文件名称：&quot;,&quot;left&quot;,10,&quot;top&quot;,40-20,&quot;width&quot;,90,NULL);&#xA;    edt1= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;c:\\boot.ini&quot;,&quot;left&quot;,105,&quot;top&quot;,38-20,&quot;width&quot;,345,NULL);&#xA;    int txt3= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;转换到文件名称：&quot;,&quot;left&quot;,10,&quot;top&quot;,68-20,&quot;width&quot;,90,NULL);&#xA;    edt2= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;c:\\tmp.txt&quot;,&quot;left&quot;,105,&quot;top&quot;,65-20,&quot;width&quot;,345,NULL);&#xA;&#xA;    int btn1= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;...&quot;,&quot;left&quot;,465,&quot;top&quot;,36-20,&quot;width&quot;,65,&quot;onclick&quot;,OpenFileClick,NULL);&#xA;    int btn2= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;...&quot;,&quot;left&quot;,465,&quot;top&quot;,63-20,&quot;width&quot;,65,&quot;onclick&quot;,OpenFileClick1,NULL);&#xA;    int btn3= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;转    换&quot; ,&quot;left&quot;,75,&quot;top&quot;,93+28-40,&quot;width&quot;,120,&quot;onclick&quot;,Trans,NULL);&#xA;    int btn4= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;查看转换文件&quot;,&quot;left&quot;,215,&quot;top&quot;,93+28-40,&quot;width&quot;,120,&quot;onclick&quot;,ViewC,NULL);&#xA;    int btn5= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;退    出&quot; ,&quot;left&quot;,375,&quot;top&quot;,93+28-40,&quot;width&quot;,120,&quot;onclick&quot;,CloseClick,NULL);&#xA;}&#xA;void main()&#xA;{&#xA;&#xA;    CreateGui();&#xA;}&#xA;void Trans()&#xA;{&#xA;    char  argv[4][255];&#xA;    char s[100];&#xA;    FILE *source,*dest;&#xA;    unsigned char buffer[BUF_LEN], Dummy[20];&#xA;    int c;&#xA;    GetProperty(edt1,&quot;text&quot;,argv[1],200);&#xA;    GetProperty(edt2,&quot;text&quot;,argv[2],200);&#xA;    //GetProperty(edt3,&quot;text&quot;,argv[3],200);&#xA;    printf(&quot;%s&quot;,argv[1]);&#xA;    printf(&quot;%s&quot;,argv[2]);    &#xA;    //printf(&quot;%s&quot;,argv[3]);    &#xA;    &#xA;    &#xA;    //strcpy(argv[3],&quot;data&quot;);&#xA;    if( (source=fopen( argv[1], &quot;rb&quot; )) == NULL )&#xA;    {&#xA;        printf(&quot;ERROR : I can't find source file   %s\n&quot;,argv[1]);&#xA;&#xA;        sprintf(s,&quot;二进制文件[%s]不存在!&quot;,argv[1]);&#xA;        ShowMessage(s);&#xA;        return;&#xA;    }     &#xA;    strcpy(Dummy,argv[2]);&#xA;&#xA;    if( (dest=fopen( Dummy, &quot;wb+&quot; )) == NULL )&#xA;    {&#xA;        sprintf(s,&quot;目标文件[%s]无法创建!&quot;,argv[1]);&#xA;        ShowMessage(s);&#xA;        printf(&quot;ERROR : I can't open destination file   %s\n&quot;,Dummy);&#xA;        return;&#xA;    }&#xA;           &#xA;    //strcpy(Dummy,argv[3]);&#xA;    //Upper_chars(Dummy);  /* lower to upper chars */&#xA;    //strcat(Dummy,&quot;_LEN&quot;);  /* add the suffix _LEN to the struct name */&#xA;    //fprintf( dest, &quot;\r\n//--------通讯调试工具1.255---------\r\n\r\n&quot;, Dummy, filesize(source) );&#xA;    //fprintf( dest, &quot;#define %s %d\r\n&quot;, Dummy, filesize(source) );&#xA;    //fprintf( dest, &quot;static unsigned char %s[]=\r\n{\r\n&quot;, argv[3] );&#xA;&#xA;    if( ferror( dest ) )&#xA;    {&#xA;        printf( &quot;ERROR writing on target file:  %s\n&quot;,argv[2] );&#xA;        return;&#xA;    }&#xA;   &#xA;    do&#xA;    {&#xA;        //fprintf(dest,&quot;&quot;);&#xA;        for ( c=0; ((c &lt;= LINE) &amp;&amp; (! feof( source ) )) ; c++)&#xA;        {&#xA;            fread(buffer,1,1,source);&#xA;&#xA;            if (!feof( source ) &amp;&amp; c != 0)&#xA;            {&#xA;                //fprintf(dest,&quot;&quot;);&#xA;                //printf(&quot;,&quot;);&#xA;            }&#xA;&#xA;            if (! feof( source ) )&#xA;            {&#xA;                fprintf(dest,&quot; %02x&quot;,*buffer);&#xA;                //printf(&quot;0x%02x&quot;,*buffer);&#xA;            }&#xA;        }&#xA;        fprintf(dest,&quot;\r\n&quot;);&#xA;    }&#xA;    while( ! feof( source ) );&#xA;     &#xA;&#xA;    // fprintf(dest,&quot;};\r\n\r\n&quot;);&#xA;&#xA;    fclose(dest);&#xA;    fclose(source);&#xA;    printf(&quot;OK!&quot;);&#xA;    ShowMessage(&quot;转换完成!        &quot;);&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;"/>
    <Command cmdname="HexDump" cmdType="P" cmd="[P]#include &lt;stdio.h&gt;&#xA;#include &lt;string.h&gt;&#xA;&#xA;#define BUF_LEN 1&#xA;#define LINE 15&#xA;int p;&#xA;&#xA;int edt1,edt2,edt3;&#xA;void Trans();&#xA;long int filesize( FILE *fp )&#xA;{&#xA;    long int save_pos, size_of_file;&#xA;    save_pos = ftell( fp );&#xA;    fseek( fp, 0L, SEEK_END );&#xA;    size_of_file = ftell( fp );&#xA;    fseek( fp, save_pos, SEEK_SET );&#xA;    return( size_of_file );&#xA;}&#xA;&#xA;void Upper_chars(char *buffer)&#xA;{&#xA;    unsigned int c;&#xA;    for (c=0; c &lt;= strlen(buffer)-1; c++)&#xA;        *(buffer+c)=toupper( *(buffer+c) );&#xA;}&#xA;void OpenFileClick(void *sender)&#xA;{&#xA;    char s[200];&#xA;    GetFileName(s,200,&quot;*.*&quot;);&#xA;    if(strlen(s)&gt;0)&#xA;        SetProperty(edt1,&quot;text&quot;,s);&#xA;}&#xA;void OpenFileClick1(void *sender)&#xA;{&#xA;    char s[200];&#xA;    GetFileName(s,200,&quot;*.txt&quot;);&#xA;    if(strlen(s)&gt;0)&#xA;        SetProperty(edt2,&quot;text&quot;,s);&#xA;}&#xA;void CloseClick(void *Sender)&#xA;{&#xA;    ClearOutputWin();   //清除输出窗口内容&#xA;    HideVclWin();&#xA;    CloseVclWin();&#xA;    CloseForm(p);&#xA;}&#xA;&#xA;void ViewC()&#xA;{&#xA;    char s[200],s1[200];&#xA;    GetProperty(edt2,&quot;text&quot;,s,200);&#xA;    sprintf(s1,&quot;notepad.exe %s&quot;,s);&#xA;    WinExec(s1);&#xA;}&#xA;&#xA;void CreateGui()&#xA;{&#xA;    CloseCodeWin();&#xA;    ClearVclControls();&#xA;&#xA;    int GuiMode=2;&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;        p=GetGuiWin(GuiMode);&#xA;    else&#xA;        p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;HexDump工具&quot;,&quot;Width&quot;,570,&quot;height&quot;,150,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;, &quot;visible&quot;,1,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;&#xA;    int pnl =p;&#xA;    int txt2= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;二进制文件名称：&quot;,&quot;left&quot;,10,&quot;top&quot;,40-20,&quot;width&quot;,90,NULL);&#xA;    edt1= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;c:\\boot.ini&quot;,&quot;left&quot;,105,&quot;top&quot;,38-20,&quot;width&quot;,345,NULL);&#xA;    int txt3= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;转换到文件名称：&quot;,&quot;left&quot;,10,&quot;top&quot;,68-20,&quot;width&quot;,90,NULL);&#xA;    edt2= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;c:\\tmp.txt&quot;,&quot;left&quot;,105,&quot;top&quot;,65-20,&quot;width&quot;,345,NULL);&#xA;&#xA;    int btn1= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;...&quot;,&quot;left&quot;,465,&quot;top&quot;,36-20,&quot;width&quot;,65,&quot;onclick&quot;,OpenFileClick,NULL);&#xA;    int btn2= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;...&quot;,&quot;left&quot;,465,&quot;top&quot;,63-20,&quot;width&quot;,65,&quot;onclick&quot;,OpenFileClick1,NULL);&#xA;    int btn3= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;转    换&quot; ,&quot;left&quot;,75,&quot;top&quot;,93+28-40,&quot;width&quot;,120,&quot;onclick&quot;,Trans,NULL);&#xA;    int btn4= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;查看转换文件&quot;,&quot;left&quot;,215,&quot;top&quot;,93+28-40,&quot;width&quot;,120,&quot;onclick&quot;,ViewC,NULL);&#xA;    int btn5= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;退    出&quot; ,&quot;left&quot;,375,&quot;top&quot;,93+28-40,&quot;width&quot;,120,&quot;onclick&quot;,CloseClick,NULL);&#xA;}&#xA;void main()&#xA;{&#xA;    CreateGui();&#xA;}&#xA;void Trans()&#xA;{&#xA;    char  argv[4][255];&#xA;    char s[100];&#xA;    FILE *source,*dest;&#xA;    unsigned char buffer[BUF_LEN], Dummy[20];&#xA;    int c,i;&#xA;    char fname[255];&#xA;    char ext[255];&#xA;    int count=0;&#xA;    unsigned char buf[20];&#xA;&#xA;    GetProperty(edt1,&quot;text&quot;,argv[1],200);&#xA;    GetProperty(edt2,&quot;text&quot;,argv[2],200);&#xA;&#xA;    if( (source=fopen( argv[1], &quot;rb&quot; )) == NULL )&#xA;    {&#xA;        sprintf(s,&quot;二进制文件[%s]不存在!&quot;,argv[1]);&#xA;        ShowMessage(s);&#xA;        return;&#xA;    }&#xA;    strcpy(Dummy,argv[2]);&#xA;    if( (dest=fopen( Dummy, &quot;wb+&quot; )) == NULL )&#xA;    {&#xA;        sprintf(s,&quot;目标文件[%s]无法创建!&quot;,argv[1]);&#xA;        ShowMessage(s);&#xA;        return;&#xA;    }&#xA;    _splitpath(argv[1], NULL,NULL,fname,ext);&#xA;    fprintf( dest, &quot;CommBox V1.26\r\nHEXDUMP 文件名称：%s%s,文件大小：%d Bytes\r\n&quot;, fname,ext, filesize(source) );&#xA;    fprintf( dest, &quot;------------------------------------------------------------------------------\r\n&quot;);&#xA;&#xA;    fprintf( dest, &quot;地址(HEX) 00 01 02 03  04 05 06 07  08 09 0A 0B  0C 0D 0E 0F  0123456789ABCDEF\r\n&quot;);&#xA;    fprintf( dest, &quot;==============================================================================\r\n&quot;);&#xA;    if( ferror( dest ) )&#xA;    {&#xA;        printf( &quot;ERROR writing on target file:  %s\n&quot;,argv[2] );&#xA;        return;&#xA;    }&#xA;&#xA;    do&#xA;    {&#xA;        fprintf( dest, &quot;%08X&quot;,count);&#xA;        count+=LINE;&#xA;        for ( c=0; ((c &lt;= LINE) &amp;&amp; (! feof( source ) )) ; c++)&#xA;        {&#xA;            fread(buffer,1,1,source);&#xA;            buf[c]=buffer[0];&#xA;&#xA;            if (! feof( source ) )&#xA;            {&#xA;                if(c%4==0)fprintf(dest,&quot; &quot;);&#xA;                fprintf(dest,&quot; %02x&quot;,*buffer);&#xA;            }&#xA;            else&#xA;                break;&#xA;        }&#xA;&#xA;        if ( feof( source ) )&#xA;            for(i=c; i&lt;=LINE; i++)&#xA;            {&#xA;                if(i%4==0)fprintf(dest,&quot; &quot;);&#xA;                fprintf(dest,&quot;   &quot;);&#xA;            }&#xA;        fprintf(dest,&quot;  &quot;);&#xA;        char xshz=1;&#xA;&#xA;        i=0;&#xA;        while(i&lt;c)&#xA;        {&#xA;            if(!xshz)&#xA;            {&#xA;                if((buf[i]&gt;0x20)&amp;&amp;(buf[i]&lt;0x80))&#xA;                    fprintf( dest, &quot;%c&quot;,buf[i]);&#xA;                else&#xA;                    fprintf( dest, &quot;.&quot;);&#xA;            }&#xA;            else&#xA;            {&#xA;                unsigned char hz=0;&#xA;                if(i&lt;c-1)&#xA;                    if((buf[i]&gt;=0xa1)&amp;&amp;(buf[i]&lt;=0xfe))&#xA;                        if((buf[i+1]&gt;=0xa1)&amp;&amp;(buf[i+1]&lt;=0xfe))&#xA;                            hz=1;&#xA;                if(hz)&#xA;                {&#xA;                    char tmp[3];&#xA;                    tmp[0]=buf[i];&#xA;                    tmp[1]=buf[i+1];&#xA;                    tmp[2]=0;&#xA;                    fprintf( dest, &quot;%s&quot;,tmp);&#xA;                    i++;&#xA;                }&#xA;                else&#xA;                {&#xA;                    if((buf[i]&gt;0x20)&amp;&amp;(buf[i]&lt;0x80))&#xA;                        fprintf( dest, &quot;%c&quot;,buf[i]);&#xA;                    else&#xA;                        fprintf( dest, &quot;.&quot;);&#xA;                }&#xA;            }&#xA;            i++;&#xA;        }&#xA;&#xA;        fprintf(dest,&quot;\r\n&quot;);&#xA;    }&#xA;    while( ! feof( source ) );&#xA;&#xA;    fclose(dest);&#xA;    fclose(source);&#xA;    printf(&quot;OK!&quot;);&#xA;    ShowMessage(&quot;转换完成!        &quot;);&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;"/>
    <Command cmdname="二进制转C(bin2c)" cmdType="P" cmd="[P]#include &lt;stdio.h&gt;&#xA;#include &lt;string.h&gt;&#xA;&#xA;#define BUF_LEN 1&#xA;#define LINE     15&#xA;int p;&#xA;&#xA;int edt1,edt2,edt3;&#xA;void Trans();&#xA;long int filesize( FILE *fp )&#xA;{&#xA;    long int save_pos, size_of_file;&#xA;&#xA;    save_pos = ftell( fp );&#xA;    fseek( fp, 0L, SEEK_END );&#xA;    size_of_file = ftell( fp );&#xA;    fseek( fp, save_pos, SEEK_SET );&#xA;    return( size_of_file );&#xA;}&#xA;&#xA;void Upper_chars(char *buffer)&#xA;{&#xA;    unsigned int c;&#xA;&#xA;    for (c=0; c &lt;= strlen(buffer)-1; c++) *(buffer+c)=toupper( *(buffer+c) );&#xA;}&#xA;void OpenFileClick(void *sender)&#xA;{&#xA;    char s[200];&#xA;    GetFileName(s,200,&quot;*.*&quot;);&#xA;    if(strlen(s)&gt;0)&#xA;    {&#xA;        SetProperty(edt1,&quot;text&quot;,s);&#xA;    }&#xA;}&#xA;void OpenFileClick1(void *sender)&#xA;{&#xA;    char s[200];&#xA;    GetFileName(s,200,&quot;*.*&quot;);&#xA;    if(strlen(s)&gt;0)&#xA;    {&#xA;        SetProperty(edt2,&quot;text&quot;,s);&#xA;    }&#xA;}&#xA;void CloseClick(void *Sender)&#xA;{&#xA;&#xA;    ClearOutputWin();   //清除输出窗口内容&#xA;    HideVclWin();&#xA;&#xA;    CloseVclWin();&#xA;    CloseForm(p);&#xA;}&#xA;&#xA;void ViewC()&#xA;{&#xA;    char s[200],s1[200];&#xA;    GetProperty(edt2,&quot;text&quot;,s,200);&#xA;    sprintf(s1,&quot;notepad.exe %s&quot;,s);&#xA;    WinExec(s1);&#xA;&#xA;}&#xA;void CreateGui()&#xA;{&#xA;    //ShowVclWin(170);&#xA;    //ShowOutputWin(310);&#xA;    CloseCodeWin();&#xA;    ClearVclControls();&#xA;    //HideLeftTools();&#xA;    //HideRightTools();&#xA;&#xA;    int GuiMode=2;&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;        p=GetGuiWin(GuiMode);&#xA;    else&#xA;        p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;Bin2C工具&quot;,&quot;Width&quot;,560,&quot;height&quot;,170,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;, &quot;visible&quot;,1,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;&#xA;    int pnl = p;&#xA;    int txt2= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;二进制文件名称：&quot;,&quot;left&quot;,10,&quot;top&quot;,40-30,&quot;width&quot;,60,NULL);&#xA;    edt1= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;c:\\boot.ini&quot;,&quot;left&quot;,75,&quot;top&quot;,38-30,&quot;width&quot;,385,NULL);&#xA;    int txt3= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;C文件名称：&quot;,&quot;left&quot;,10,&quot;top&quot;,68-30,&quot;width&quot;,60,NULL);&#xA;    edt2= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;c:\\tmp.c&quot;,&quot;left&quot;,75,&quot;top&quot;,65-30,&quot;width&quot;,385,NULL);&#xA;&#xA;    int txt4= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;结构名称：&quot;,&quot;left&quot;,10,&quot;top&quot;,96-30,&quot;width&quot;,60,NULL);&#xA;    edt3= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;data&quot;,&quot;left&quot;,75,&quot;top&quot;,92-30,&quot;width&quot;,385,NULL);&#xA;&#xA;    int btn1= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;...&quot;,&quot;left&quot;,465,&quot;top&quot;,36-30,&quot;width&quot;,65,&quot;onclick&quot;,OpenFileClick,NULL);&#xA;    int btn2= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;...&quot;,&quot;left&quot;,465,&quot;top&quot;,63-30,&quot;width&quot;,65,&quot;onclick&quot;,OpenFileClick1,NULL);&#xA;    int btn3= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;转    换&quot; ,&quot;left&quot;,75,&quot;top&quot;,93+28-25,&quot;width&quot;,120,&quot;onclick&quot;,Trans,NULL);&#xA;    int btn4= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;查看C文件&quot;,&quot;left&quot;,215,&quot;top&quot;,93+28-25,&quot;width&quot;,120,&quot;onclick&quot;,ViewC,NULL);&#xA;    int btn5= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;退    出&quot; ,&quot;left&quot;,375,&quot;top&quot;,93+28-25,&quot;width&quot;,120,&quot;onclick&quot;,CloseClick,NULL);&#xA;}&#xA;void main()&#xA;{&#xA;    printf(&quot;BIN2C V1.0 by baohongjie\n&quot;);&#xA;    CreateGui();&#xA;}&#xA;void Trans()&#xA;{&#xA;    char  argv[4][255];&#xA;    char s[100];&#xA;    FILE *source,*dest;&#xA;    unsigned char buffer[BUF_LEN], Dummy[20];&#xA;    int c;&#xA;    GetProperty(edt1,&quot;text&quot;,argv[1],200);&#xA;    GetProperty(edt2,&quot;text&quot;,argv[2],200);&#xA;    GetProperty(edt3,&quot;text&quot;,argv[3],200);&#xA;    if( (source=fopen( argv[1], &quot;rb&quot; )) == NULL )&#xA;    {&#xA;        sprintf(s,&quot;二进制文件[%s]不存在!&quot;,argv[1]);&#xA;        ShowMessage(s);&#xA;        return;&#xA;    }&#xA;    strcpy(Dummy,argv[2]);&#xA;&#xA;    if( (dest=fopen( Dummy, &quot;wb+&quot; )) == NULL )&#xA;    {&#xA;        sprintf(s,&quot;目标文件[%s]无法创建!&quot;,argv[1]);&#xA;        ShowMessage(s);&#xA;        return;&#xA;    }&#xA;&#xA;    strcpy(Dummy,argv[3]);&#xA;    Upper_chars(Dummy);  /* lower to upper chars */&#xA;    strcat(Dummy,&quot;_LEN&quot;);  /* add the suffix _LEN to the struct name */&#xA;    fprintf( dest, &quot;\r\n//CommBox V1.256\r\n\r\n&quot;, Dummy, filesize(source) );&#xA;    fprintf( dest, &quot;#define %s %d\r\n&quot;, Dummy, filesize(source) );&#xA;    fprintf( dest, &quot;static unsigned char %s[]=\r\n{\r\n&quot;, argv[3] );&#xA;&#xA;    if( ferror( dest ) )&#xA;    {&#xA;        printf( &quot;ERROR writing on target file:  %s\n&quot;,argv[2] );&#xA;        return;&#xA;    }&#xA;&#xA;    do&#xA;    {&#xA;        fprintf(dest,&quot;    &quot;);&#xA;        for ( c=0; ((c &lt;= LINE) &amp;&amp; (! feof( source ) )) ; c++)&#xA;        {&#xA;            fread(buffer,1,1,source);&#xA;&#xA;            if (!feof( source ) &amp;&amp; c != 0)&#xA;            {&#xA;                fprintf(dest,&quot;,&quot;);&#xA;            }&#xA;&#xA;            if (! feof( source ) )&#xA;            {&#xA;                fprintf(dest,&quot;0x%02x&quot;,*buffer);&#xA;            }&#xA;        }&#xA;        fprintf(dest,&quot;,\r\n&quot;);&#xA;    }&#xA;    while( ! feof( source ) );&#xA;&#xA;    fprintf(dest,&quot;};\r\n\r\n&quot;);&#xA;&#xA;    fclose(dest);&#xA;    fclose(source);&#xA;    printf(&quot;OK!&quot;);&#xA;    ShowMessage(&quot;-------------转换完成!-----------------&quot;);&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;"/>
    <Command cmdname="对接收数据进行C格式化" cmdType="P" cmd="[P]void CFormat(unsigned char *buf,int count)//串口接收到数?&#xA;{&#xA;    int i;&#xA;    unsigned char sbuf[1024];&#xA;&#xA;    unsigned char tmp[100];&#xA;    sbuf[0]=0;&#xA;    for(i=0; i&lt;count; i++)&#xA;    {&#xA;        if(i%16==15)&#xA;            sprintf(tmp,&quot;0x%02x,\r\n&quot;,buf[i]&amp;0xff);&#xA;        else&#xA;            sprintf(tmp,&quot;0x%02x,&quot;,buf[i]&amp;0xff);&#xA;        strcat(sbuf,tmp);&#xA;    }&#xA;    printf(sbuf);&#xA;&#xA;}&#xA;void RecvSerialData(unsigned char *buf,int count) // 串口接收到数?&#xA;{&#xA;    CFormat(buf,count);&#xA;}&#xA;&#xA;&#xA;void main()&#xA;{&#xA;    ShowOutputWin(-1);&#xA;}"/>
    <Command cmdname="单片机Hex文件转Bin文件" cmdType="P" cmd="[P]#include &lt;stdio.h&gt;&#xA;#include &lt;stdlib.h&gt;&#xA;#include &lt;string.h&gt;&#xA;#include &lt;ctype.h&gt;&#xA;&#xA;#define BUF_LEN 1&#xA;#define LINE 15&#xA;int p;&#xA;int edt1,edt2,edt3;&#xA;/* size in bytes */&#xA;#define MEMORY_SIZE 1024*1024&#xA;#define ADDRESS_MASK 0x000F0000&#xA;&#xA;#ifndef TRUE&#xA;#define TRUE 1&#xA;#define FALSE 0&#xA;#endif&#xA;&#xA;#define MAX_FILE_NAME_SIZE 255&#xA;&#xA;/* The data records can contain 255 bytes: this means 512 characters. */&#xA;#define MAX_LINE_SIZE 1024&#xA;&#xA;#define NO_ADDRESS_TYPE_SELECTED 0&#xA;#define LINEAR_ADDRESS 1&#xA;#define SEGMENTED_ADDRESS 2&#xA;&#xA;typedef char filetype[MAX_FILE_NAME_SIZE];&#xA;typedef int boolean;&#xA;typedef unsigned char byte;&#xA;&#xA;filetype    Filename;&#xA;FILE        *Filin,             /* input files */&#xA;            *Filout;            /* output files */&#xA;&#xA;void *NoFailMalloc (size_t size);&#xA;int NoFailOpenInputFile (char *Flnm);&#xA;int NoFailOpenOutputFile (char *Flnm);&#xA;&#xA;void *NoFailMalloc (size_t size)&#xA;{&#xA;    void *result;&#xA;&#xA;    if ((result = malloc (size)) == NULL)&#xA;    {&#xA;        fprintf (stderr,&quot;Can't allocate memory.\n&quot;);&#xA;        exit(1);&#xA;    }&#xA;    return (result);&#xA;}&#xA;&#xA;&#xA;int NoFailOpenInputFile (char *Flnm)&#xA;{&#xA;    if ((Filin = fopen(Flnm,&quot;r&quot;)) == NULL)&#xA;    {&#xA;        printf (&quot;Input file %s cannot be opened. Enter new filename: &quot;,Flnm);&#xA;        return 0;&#xA;    }&#xA;&#xA;    return 1;&#xA;}&#xA;&#xA;/* Open the output file, with error checking */&#xA;int NoFailOpenOutputFile (char *Flnm)&#xA;{&#xA;    if ((Filout = fopen(Flnm,&quot;w&quot;)) == NULL)&#xA;    {&#xA;        fprintf(stderr,&quot;Output file %s cannot be opened. Enter new file name: &quot;, Flnm);&#xA;        return 0;&#xA;    }&#xA;    return 1;&#xA;}&#xA;&#xA;int Trans()&#xA;{&#xA;    /* line inputted from file */&#xA;    char Line[MAX_LINE_SIZE];&#xA;&#xA;    /* flag that a file was read */&#xA;    boolean Fileread;&#xA;    boolean Enable_Checksum_Error = FALSE;&#xA;    boolean Status_Checksum_Error = FALSE;&#xA;&#xA;    /* cmd-line parameter # */&#xA;    char *c,*p;&#xA;&#xA;    unsigned int Param;&#xA;    unsigned int i;&#xA;&#xA;    /* Application specific */&#xA;&#xA;    unsigned int     Nb_Bytes;&#xA;    unsigned int     First_Word, Address, Segment, Upper_Address;&#xA;    unsigned int     Lowest_Address, Highest_Address, Starting_Address;&#xA;    unsigned int     Phys_Addr, Type;&#xA;    unsigned int     temp;&#xA;&#xA;&#xA;    unsigned int    Seg_Lin_Select = NO_ADDRESS_TYPE_SELECTED;&#xA;&#xA;    boolean Starting_Address_Setted = FALSE;&#xA;&#xA;    int temp2;&#xA;&#xA;    byte    Data_Str[MAX_LINE_SIZE];&#xA;    byte     Checksum;&#xA;&#xA;    /* This will hold binary codes translated from hex file. */&#xA;    byte *Memory_Block;&#xA;&#xA;    printf (&quot;hex2bin v1.0, commbox v1.260\n&quot;);&#xA;    Param = 1;&#xA;    GetProperty(edt1,&quot;text&quot;,Filename,200);&#xA;&#xA;    /* Just a normal file name */&#xA;    if(NoFailOpenInputFile (Filename)==0)&#xA;    {&#xA;        ShowMessage(&quot;Hex文件打开错误！&quot;);&#xA;        return;&#xA;    }&#xA;&#xA;    GetProperty(edt2,&quot;text&quot;,Filename,200);&#xA;    if(NoFailOpenOutputFile(Filename)==0)&#xA;    {&#xA;        ShowMessage(&quot;Bin文件打开错误！&quot;);&#xA;        return;&#xA;    }&#xA;    Fileread = TRUE;&#xA;&#xA;    /* allocate a buffer */&#xA;    Memory_Block = (byte *) NoFailMalloc(MEMORY_SIZE);&#xA;    memset (Memory_Block,0xFF,MEMORY_SIZE);&#xA;&#xA;&#xA;    Segment = 0;&#xA;    Upper_Address = 0;&#xA;    Lowest_Address = MEMORY_SIZE - 1;&#xA;    Highest_Address = 0;&#xA;&#xA;    /* Now read the file &amp; process the lines. */&#xA;    do /* repeat until EOF(Filin) */&#xA;    {&#xA;        /* Read a line from input file. */&#xA;        fgets(Line,MAX_LINE_SIZE,Filin);&#xA;&#xA;        /* Remove carriage return/line feed at the end of line. */&#xA;        i = strlen(Line)-1;&#xA;&#xA;        if (Line[i] == '\n') Line[i] = '\0';&#xA;&#xA;        sscanf (Line, &quot;:%2x%4x%2x%s&quot;,&amp;Nb_Bytes,&amp;First_Word,&amp;Type,Data_Str);&#xA;&#xA;        Checksum = Nb_Bytes + (First_Word &gt;&gt; 8) + (First_Word &amp; 0xFF) + Type;&#xA;&#xA;        p = Data_Str;&#xA;&#xA;        /* If we're reading the last record, ignore it. */&#xA;        switch (Type)&#xA;        {&#xA;            /* Data record */&#xA;        case 0:&#xA;            Address = First_Word;&#xA;&#xA;            if (Seg_Lin_Select == SEGMENTED_ADDRESS)&#xA;                Phys_Addr = ((Segment &lt;&lt; 4) &amp; ADDRESS_MASK) + Address;&#xA;            else&#xA;                /* LINEAR_ADDRESS or NO_ADDRESS_TYPE_SELECTED&#xA;                Upper_Address = 0 as specified in the Intel spec. until an extended address&#xA;                record is read. */&#xA;                Phys_Addr = ((Upper_Address &lt;&lt; 16) &amp; ADDRESS_MASK) + Address;&#xA;&#xA;            /* Check that the physical address stays in the buffer's range. */&#xA;            if ((Phys_Addr + Nb_Bytes) &lt;= MEMORY_SIZE -1)&#xA;            {&#xA;                /* Set the lowest address as base pointer. */&#xA;                if (Phys_Addr &lt; Lowest_Address)&#xA;                    Lowest_Address = Phys_Addr;&#xA;&#xA;                /* Same for the top address. */&#xA;                temp = Phys_Addr + Nb_Bytes -1;&#xA;&#xA;                if (temp &gt; Highest_Address)&#xA;                    Highest_Address = temp;&#xA;&#xA;                /* Read the Data bytes. */&#xA;                /* Bytes are written in the Memory block even if checksum is wrong. */&#xA;                for (i= Nb_Bytes; i &gt; 0; i--)&#xA;                {&#xA;                    sscanf (p, &quot;%2x&quot;,&amp;temp2);&#xA;                    p += 2;&#xA;                    Memory_Block[Phys_Addr++] = temp2;&#xA;                    Checksum = (Checksum + temp2) &amp; 0xFF;&#xA;                };&#xA;&#xA;                /* Read the Checksum value. */&#xA;                sscanf (p, &quot;%2x&quot;,&amp;temp2);&#xA;&#xA;                /* Verify Checksum value. */&#xA;                Checksum = (Checksum + temp2) &amp; 0xFF;&#xA;&#xA;                if ((Checksum != 0) &amp;&amp; Enable_Checksum_Error)&#xA;                {&#xA;                    Status_Checksum_Error = TRUE;&#xA;                }&#xA;            }&#xA;            else&#xA;            {&#xA;                if (Seg_Lin_Select == SEGMENTED_ADDRESS)&#xA;                    fprintf(stderr,&quot;Data record skipped at %4X:%4X\n&quot;,Segment,Address);&#xA;                else&#xA;                    fprintf(stderr,&quot;Data record skipped at %8X\n&quot;,Phys_Addr);&#xA;            }&#xA;&#xA;            break;&#xA;&#xA;            /* End of file record */&#xA;        case 1:&#xA;            /* Simply ignore checksum errors in this line. */&#xA;            break;&#xA;&#xA;            /* Extended segment address record */&#xA;        case 2:&#xA;            /* First_Word contains the offset. It's supposed to be 0000 so&#xA;            we ignore it. */&#xA;&#xA;            /* First extended segment address record ? */&#xA;            if (Seg_Lin_Select == NO_ADDRESS_TYPE_SELECTED)&#xA;                Seg_Lin_Select = SEGMENTED_ADDRESS;&#xA;&#xA;            /* Then ignore subsequent extended linear address records */&#xA;            if (Seg_Lin_Select == SEGMENTED_ADDRESS)&#xA;            {&#xA;                sscanf (p, &quot;%4x%2x&quot;,&amp;Segment,&amp;temp2);&#xA;&#xA;                /* Update the current address. */&#xA;                Phys_Addr = (Segment &lt;&lt; 4) &amp; ADDRESS_MASK;&#xA;&#xA;                /* Verify Checksum value. */&#xA;                Checksum = (Checksum + (Segment &gt;&gt; 8) + (Segment &amp; 0xFF) + temp2) &amp; 0xFF;&#xA;&#xA;                if ((Checksum != 0) &amp;&amp; Enable_Checksum_Error)&#xA;                    Status_Checksum_Error = TRUE;&#xA;            }&#xA;            break;&#xA;&#xA;            /* Start segment address record */&#xA;        case 3:&#xA;            /* Nothing to be done since it's for specifying the starting address for&#xA;            execution of the binary code */&#xA;            break;&#xA;&#xA;            /* Extended linear address record */&#xA;        case 4:&#xA;            /* First_Word contains the offset. It's supposed to be 0000 so&#xA;            we ignore it. */&#xA;&#xA;            /* First extended linear address record ? */&#xA;            if (Seg_Lin_Select == NO_ADDRESS_TYPE_SELECTED)&#xA;                Seg_Lin_Select = LINEAR_ADDRESS;&#xA;&#xA;            /* Then ignore subsequent extended segment address records */&#xA;            if (Seg_Lin_Select == LINEAR_ADDRESS)&#xA;            {&#xA;                sscanf (p, &quot;%4x%2x&quot;,&amp;Upper_Address,&amp;temp2);&#xA;&#xA;                /* Update the current address. */&#xA;                Phys_Addr = (Upper_Address &lt;&lt; 16) &amp; ADDRESS_MASK;&#xA;&#xA;                /* Verify Checksum value. */&#xA;                Checksum = (Checksum + (Upper_Address &gt;&gt; 8) + (Upper_Address &amp; 0xFF) + temp2)&#xA;                           &amp; 0xFF;&#xA;&#xA;                if ((Checksum != 0) &amp;&amp; Enable_Checksum_Error)&#xA;                    Status_Checksum_Error = TRUE;&#xA;            }&#xA;            break;&#xA;&#xA;            /* Start linear address record */&#xA;        case 5:&#xA;            /* Nothing to be done since it's for specifying the starting address for&#xA;            execution of the binary code */&#xA;            break;&#xA;        default:&#xA;        }&#xA;    }&#xA;    while (!feof (Filin));&#xA;    /*-----------------------------------------------------------------------------*/&#xA;&#xA;    printf(&quot;Lowest address = %08X\n&quot;,Lowest_Address);&#xA;    printf(&quot;Highest address = %08X\n&quot;,Highest_Address);&#xA;&#xA;&#xA;&#xA;    if(Starting_Address_Setted)&#xA;    {&#xA;        Lowest_Address = Starting_Address;&#xA;    }&#xA;&#xA;    /* write binary file */&#xA;    fwrite (&amp;Memory_Block[Lowest_Address],&#xA;            1,&#xA;            Highest_Address - Lowest_Address +1,&#xA;            Filout);&#xA;&#xA;    free (Memory_Block);&#xA;    fclose (Filin);&#xA;    if (Status_Checksum_Error &amp; Enable_Checksum_Error)&#xA;    {&#xA;        printf(&quot;Checksum error detected.\n&quot;);&#xA;        return 1;&#xA;    }&#xA;    fclose (Filout);&#xA;    ShowDispMode(2);&#xA;    HexEditorLoadFromFile(Filename);&#xA;    ShowMessage(&quot;转换完成!&quot;);&#xA;    return 0;&#xA;}&#xA;&#xA;long int filesize( FILE *fp )&#xA;{&#xA;    long int save_pos, size_of_file;&#xA;    save_pos = ftell( fp );&#xA;    fseek( fp, 0L, SEEK_END );&#xA;    size_of_file = ftell( fp );&#xA;    fseek( fp, save_pos, SEEK_SET );&#xA;    return( size_of_file );&#xA;}&#xA;&#xA;void Upper_chars(char *buffer)&#xA;{&#xA;    unsigned int c;&#xA;    for (c=0; c &lt;= strlen(buffer)-1; c++)&#xA;        *(buffer+c)=toupper( *(buffer+c) );&#xA;}&#xA;void OpenFileClick(void *sender)&#xA;{&#xA;    char s[200];&#xA;    GetFileName(s,200,&quot;*.hex|*.hex&quot;);&#xA;    if(strlen(s)&gt;0)&#xA;        SetProperty(edt1,&quot;text&quot;,s);&#xA;}&#xA;void OpenFileClick1(void *sender)&#xA;{&#xA;    char s[200];&#xA;    GetFileName(s,200,&quot;*.bin|*.bin&quot;);&#xA;    if(strlen(s)&gt;0)&#xA;        SetProperty(edt2,&quot;text&quot;,s);&#xA;}&#xA;void CloseClick(void *Sender)&#xA;{&#xA;    ClearOutputWin();   //清除输出窗口内容&#xA;    HideVclWin();&#xA;    CloseVclWin();&#xA;    CloseForm(p);&#xA;}&#xA;&#xA;void ViewC()&#xA;{&#xA;    char s[200],s1[200];&#xA;    GetProperty(edt2,&quot;text&quot;,s,200);&#xA;    sprintf(s1,&quot;notepad.exe %s&quot;,s);&#xA;    WinExec(s1);&#xA;}&#xA;&#xA;void CreateGui()&#xA;{&#xA;    CloseCodeWin();&#xA;    ClearVclControls();&#xA;&#xA;    int GuiMode=2;&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;        p=GetGuiWin(GuiMode);&#xA;    else&#xA;        p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;Hex2Bin工具&quot;,&quot;Width&quot;,570,&quot;height&quot;,150,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;, &quot;visible&quot;,1,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;&#xA;    int pnl =p;&#xA;    int txt2= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;Hex文件名称：&quot;,&quot;left&quot;,10,&quot;top&quot;,40-20,&quot;width&quot;,90,NULL);&#xA;    edt1= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;c:\\1.hex&quot;,&quot;left&quot;,105,&quot;top&quot;,38-20,&quot;width&quot;,345,NULL);&#xA;    int txt3= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;转换到文件名称：&quot;,&quot;left&quot;,10,&quot;top&quot;,68-20,&quot;width&quot;,90,NULL);&#xA;    edt2= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;c:\\tmp.bin&quot;,&quot;left&quot;,105,&quot;top&quot;,65-20,&quot;width&quot;,345,NULL);&#xA;&#xA;    int btn1= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;...&quot;,&quot;left&quot;,465,&quot;top&quot;,36-20,&quot;width&quot;,65,&quot;onclick&quot;,OpenFileClick,NULL);&#xA;    int btn2= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;...&quot;,&quot;left&quot;,465,&quot;top&quot;,63-20,&quot;width&quot;,65,&quot;onclick&quot;,OpenFileClick1,NULL);&#xA;    int btn3= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;转    换&quot; ,&quot;left&quot;,75,&quot;top&quot;,93+28-40,&quot;width&quot;,120,&quot;onclick&quot;,Trans,NULL);&#xA;    int btn4= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;查看转换文件&quot;,&quot;left&quot;,215,&quot;top&quot;,93+28-40,&quot;width&quot;,120,&quot;onclick&quot;,ViewC,NULL);&#xA;    int btn5= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;退    出&quot; ,&quot;left&quot;,375,&quot;top&quot;,93+28-40,&quot;width&quot;,120,&quot;onclick&quot;,CloseClick,NULL);&#xA;}&#xA;void main()&#xA;{&#xA;    CreateGui();&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;"/>
    <Command cmdname="万年历" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;static unsigned char const sky[][3]=  {&quot;甲&quot;,&quot;乙&quot;,&quot;丙&quot;,&quot;丁&quot;,&quot;戊&quot;,&quot;己&quot;,&quot;庚&quot;,&quot;辛&quot;,&quot;壬&quot;,&quot;癸&quot;,};&#xA;static unsigned char const earth[][3]= {&quot;子&quot;,&quot;丑&quot;,&quot;寅&quot;,&quot;卯&quot;,&quot;辰&quot;,&quot;巳&quot;,&quot;午&quot;,&quot;未&quot;,&quot;申&quot;,&quot;酉&quot;,&quot;戌&quot;,&quot;亥&quot;,};&#xA;static unsigned char const monthcode[][3]= {&quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;,&quot;七&quot;,&quot;八&quot;,&quot;九&quot;,&quot;十&quot;,&quot;冬&quot;,&quot;腊&quot;,};&#xA;static unsigned char const nongliday[][3]= {&quot;初&quot;,&quot;十&quot;,&quot;廿&quot;,&quot;三&quot;,};&#xA;static unsigned char const weekhz[][3]= {&quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;,&quot;日&quot;};&#xA;static unsigned char const MonthDayMax[]= {31,28,31,30,31,30,31,31,30,31,30,31,};&#xA;&#xA;/*********************************************************************************************************&#xA;** 函数名称:GetChinaCalendar&#xA;** 功能描述:公农历转换(只允许1901-2099年)&#xA;** 输　入:  year        公历年&#xA;**          month       公历月&#xA;**          day         公历日&#xA;**          p           储存农历日期地址&#xA;** 输　出:  1           成功&#xA;**          0           失败&#xA;*/&#xA;&#xA;extern unsigned char GetChinaCalendar(&#xA;    unsigned int  year,&#xA;    unsigned char month,&#xA;    unsigned char day,&#xA;    unsigned char *p);&#xA;/*********************************************************************************************************&#xA;** 函数名称:GetWeek&#xA;** 功能描述:输入公历日期得到星期(只允许1901-2099年)&#xA;** 输　入:  year        公历年&#xA;**          month       公历月&#xA;**          day            公历日&#xA;**          p           储存星期地址&#xA;** 输　出:  无&#xA;*/&#xA;extern void GetWeek(&#xA;    unsigned int year,&#xA;    unsigned char month,&#xA;    unsigned char day,&#xA;    unsigned char *p);&#xA;/*********************************************************************************************************&#xA;** 函数名称:GetChinaCalendarStr&#xA;** 功能描述:输入公历日期得到农历字符串&#xA;**          如:GetChinaCalendarStr(2007,02,06,str) 返回str=&quot;丙戌年腊月十九&quot;&#xA;** 输　入:  year        公历年&#xA;**          month       公历月&#xA;**          day         公历日&#xA;**          str         储存农历日期字符串地址   15Byte&#xA;** 输　出:  无&#xA;*/&#xA;extern void GetChinaCalendarStr(&#xA;    unsigned int  year,&#xA;    unsigned char month,&#xA;    unsigned char day,&#xA;    char *str);&#xA;&#xA;/*********************************************************************************************************&#xA;** 函数名称:GetJieQi&#xA;** 功能描述:输入公历日期得到本月24节气日期 day&lt;15返回上半月节气,反之返回下半月&#xA;**          如:GetJieQiStr(2007,02,08,str) 返回str[0]=4&#xA;** 输　入:  year        公历年&#xA;**          month       公历月&#xA;**          day         公历日&#xA;**          str         储存对应本月节气日期地址   1Byte&#xA;** 输　出:  1           成功&#xA;**          0           失败&#xA;*/&#xA;extern unsigned char GetJieQi(&#xA;    unsigned  int year,&#xA;    unsigned char month,&#xA;    unsigned char day,&#xA;    unsigned char *JQdate);&#xA;/*********************************************************************************************************&#xA;** 函数名称:GetJieQiStr&#xA;** 功能描述:输入公历日期得到24节气字符串&#xA;**          如:GetJieQiStr(2007,02,08,str) 返回str=&quot;离雨水还有11天&quot;&#xA;** 输　入:  year        公历年&#xA;**          month       公历月&#xA;**          day         公历日&#xA;**          str         储存24节气字符串地址   15Byte&#xA;** 输　出:  1           成功&#xA;**          0           失败&#xA;*/&#xA;extern unsigned char GetJieQiStr(&#xA;    unsigned int year,&#xA;    unsigned char month,&#xA;    unsigned char day,&#xA;    char *str);                &#xA;HANDLE dc;&#xA;int img,pfm;&#xA;int mx,my;&#xA;int GuiMode=2;//GUI窗口显示模式          &#xA;int imgLeft=10;&#xA;int imgTop=40;&#xA;int curYear,curMonth;&#xA;void OnClose()&#xA;{&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;    {&#xA;        ClearVclControls();&#xA;        HideVclWin(200);&#xA;    }&#xA;    else&#xA;    {&#xA;        CloseForm(pfm);&#xA;    }&#xA;}&#xA;void DrawMonth(int year,int month)&#xA;{&#xA;    int dc;&#xA;    int i,j,count;&#xA;    char s[20];&#xA;    char str[15];&#xA;    unsigned char NLyear[4];&#xA;    int wk;&#xA;    HPEN pen;&#xA;    HBRUSH brush; HFONT	fontChr,fontHz;&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);   &#xA;        										// Windows Font ID&#xA;    &#xA;    fontChr = CreateFont(	-22,							// Height Of Font&#xA;                        0,								// Width Of Font&#xA;                        0,								// Angle Of Escapement&#xA;                        0,								// Orientation Angle&#xA;                        FW_BOLD,						// Font Weight&#xA;                        TRUE,							// Italic&#xA;                        FALSE,							// Underline&#xA;                        FALSE,							// Strikeout&#xA;                        ANSI_CHARSET,					// Character Set Identifier&#xA;                        OUT_TT_PRECIS,					// Output Precision&#xA;                        CLIP_DEFAULT_PRECIS,			// Clipping Precision&#xA;                        ANTIALIASED_QUALITY,			// Output Quality&#xA;                        FF_DONTCARE|DEFAULT_PITCH,		// Family And Pitch&#xA;&#xA;                        //&quot;Courier New&quot;);					// Font Name&#xA;                        &quot;Bodoni MT Black&quot;);&#xA;    fontHz = CreateFont(	-15,							// Height Of Font&#xA;                        0,								// Width Of Font&#xA;                        0,								// Angle Of Escapement&#xA;                        0,								// Orientation Angle&#xA;                        FW_BOLD,						// Font Weight&#xA;                        FALSE,							// Italic&#xA;                        FALSE,							// Underline&#xA;                        FALSE,							// Strikeout&#xA;                        ANSI_CHARSET,					// Character Set Identifier&#xA;                        OUT_TT_PRECIS,					// Output Precision&#xA;                        CLIP_DEFAULT_PRECIS,			// Clipping Precision&#xA;                        ANTIALIASED_QUALITY,			// Output Quality&#xA;                        FF_DONTCARE|DEFAULT_PITCH,		// Family And Pitch&#xA;&#xA;                        //&quot;Courier New&quot;);					// Font Name&#xA;                        &quot;Bodoni MT Black&quot;);                        &#xA;                        &#xA;                        SelectObject(dc,fontHz);&#xA;                         &#xA;    RECT rect= {0,0,640,780};&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    HBRUSH brush=CreateSolidBrush(0xffffff);&#xA;    SelectObject(dc,brush);&#xA;    FillRect(dc,&amp;rect,brush);&#xA;    DeleteObject(brush);&#xA;&#xA;    for(i=0; i&lt;7; i++)&#xA;    {&#xA;        sprintf(s,&quot;星期%s&quot;,weekhz[i]);&#xA;        TextOutA(dc,12+i*70,10,s,strlen(s));&#xA;    }&#xA;    GetWeek(year,month,1,&amp;wk);&#xA;    wk=wk&amp;0xff;&#xA;    if(wk==0)wk=7;&#xA;&#xA;    pen=CreatePen(PS_SOLID,1, 0x000000);&#xA;    SelectObject(dc,pen);&#xA;    DeleteObject(pen);&#xA;    SetTextColor(dc,0x000000);&#xA;    count=MonthDayMax[month-1];&#xA;    if(month==2)&#xA;        if((year%4==0)&amp;&amp;((year%100!=0)||(year%400==0)))&#xA;            count++;&#xA;    for(i=0; i&lt;count; i++)&#xA;    {&#xA;        SetTextColor(dc,0x000000);&#xA;        SetBkColor(dc, 0xffffff);&#xA;        sprintf(s,&quot; %d &quot;,i+1);&#xA;        SelectObject(dc,fontChr);&#xA;        if(i&lt;10)&#xA;        TextOutA(dc,22 +((wk+i-1)%7)*70,34+70*((wk+i-1)/7),s,strlen(s));&#xA;        else&#xA;        TextOutA(dc,16+((wk+i-1)%7)*70,34+70*((wk+i-1)/7),s,strlen(s));&#xA;        GetChinaCalendarStr(year,month,i+1,str);     //str   ={&quot;丙戌年腊月廿一&quot;}&#xA;        GetChinaCalendar   (year,month,i+1,NLyear);  //NLyear={20,06,12,21}&#xA;        SelectObject(dc,fontHz);&#xA;        if(NLyear[3]==1)&#xA;        {&#xA;            DeleteObject(brush);&#xA;            brush=CreateSolidBrush(0xafafaf);&#xA;            SelectObject(dc,brush);&#xA;            SetTextColor(dc,0x00ffff);&#xA;            SetBkColor(dc,0xff0000 );&#xA;            TextOutA(dc,20+((wk+i-1)%7)*70,60+70*((wk+i-1)/7),str+6,4);&#xA;        }&#xA;        else&#xA;        {&#xA;            DeleteObject(brush);&#xA;            brush=CreateSolidBrush(0xafafaf);&#xA;            SelectObject(dc,brush);&#xA;            SetTextColor(dc,0x000000);&#xA;            SetBkColor(dc, 0xffffff);&#xA;            TextOutA(dc,20+((wk+i-1)%7)*70,60+70*((wk+i-1)/7),str+10,strlen(str)-10);&#xA;        }&#xA;&#xA;        GetJieQiStr(year,month,i+1,str);&#xA;        if(str[4]==0)&#xA;        {&#xA;            SetTextColor(dc,0x0000ff);&#xA;            SetBkColor(dc,0x00ffff );&#xA;            TextOutA(dc,20+((wk+i-1)%7)*70,80+70*((wk+i-1)/7),str ,strlen(str) );&#xA;        }&#xA;        //printf(&quot;day:%d %s&quot;,i+1,str);&#xA;    }            &#xA;    MoveToEx(dc,0, 0,0);&#xA;    LineTo(dc,600, 0);    &#xA;    for(i=0; i&lt;10; i++)&#xA;    {&#xA;        MoveToEx(dc,0,-40+i*70,0);&#xA;        LineTo(dc,600,-40+i*70);&#xA;    }&#xA;    for(i=0; i&lt;10; i++)&#xA;    {&#xA;        MoveToEx(dc, i*70,0,0);&#xA;        LineTo(dc, i*70,600);&#xA;    }&#xA;&#xA;    sprintf(s,&quot;%d年%d月&quot;,curYear,curMonth);&#xA;    SetProperty(pfm,&quot;caption&quot;,s);&#xA;    printf(&quot;week:%d&quot;,wk );&#xA;    Invalidate(img);&#xA;    DeleteObject(fontChr);&#xA;    DeleteObject(fontHz);    &#xA;}&#xA;&#xA;void OnLastMonth()&#xA;{&#xA;    if(curMonth==1)&#xA;    {&#xA;        curMonth=12;&#xA;        curYear--;&#xA;    }&#xA;    else  &#xA;        curMonth--;    &#xA;    DrawMonth(curYear,curMonth);  &#xA;}&#xA;void OnNextMonth()&#xA;{&#xA;&#xA;    if(curMonth==12)&#xA;    {&#xA;        curMonth=1;&#xA;        curYear++;&#xA;    }&#xA;    else   &#xA;        curMonth++;   &#xA;    DrawMonth(curYear,curMonth);&#xA;}&#xA;void OnLastYear()&#xA;{&#xA;    curYear--;&#xA;    DrawMonth(curYear,curMonth);&#xA;}&#xA;&#xA;void OnNextYear()&#xA;{&#xA;    curYear++;&#xA;    DrawMonth(curYear,curMonth);  &#xA;}&#xA;void main(void)&#xA;{&#xA;    unsigned char week;&#xA;    unsigned char NLyear[4];&#xA;    unsigned char JQdate;&#xA;    char str[15];&#xA;    int i,j;&#xA;    int mi,mi1;&#xA;    SYSTEMTIME st;&#xA;    GetLocalTime(&amp;st);  &#xA;    //HideLeftTools();&#xA;    ClearVclControls();&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;    {&#xA;        pfm=GetGuiWin(GuiMode);&#xA;    }&#xA;    else&#xA;        pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;分站模拟&quot;,&quot;Width&quot;,520,&quot;height&quot;,480+50,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;    //CreateComponentEx(pfm,&quot;timer&quot;,&quot;interval&quot;,100,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮&#xA;    CreateComponentEx(pfm,&quot;Button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,400,&quot;top&quot;,5,&quot;width&quot;,100,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);&#xA;    CreateComponentEx(pfm,&quot;Button&quot;,&quot;caption&quot;,&quot;上月&quot;,&quot;left&quot;,20,&quot;top&quot;,5,&quot;width&quot;,70,&quot;height&quot;,20,&quot;OnClick&quot;,OnLastMonth,0);&#xA;    CreateComponentEx(pfm,&quot;Button&quot;,&quot;caption&quot;,&quot;下月&quot;,&quot;left&quot;,100,&quot;top&quot;,5,&quot;width&quot;,70,&quot;height&quot;,20,&quot;OnClick&quot;,OnNextMonth,0);&#xA;    CreateComponentEx(pfm,&quot;Button&quot;,&quot;caption&quot;,&quot;上年&quot;,&quot;left&quot;,220,&quot;top&quot;,5,&quot;width&quot;,70,&quot;height&quot;,20,&quot;OnClick&quot;,OnLastYear,0);&#xA;    CreateComponentEx(pfm,&quot;Button&quot;,&quot;caption&quot;,&quot;下年&quot;,&quot;left&quot;,300,&quot;top&quot;,5,&quot;width&quot;,70,&quot;height&quot;,20,&quot;OnClick&quot;,OnNextYear,0);&#xA;&#xA;    img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,imgLeft,&quot;top&quot;,imgTop,&quot;width&quot;,491,&quot;height&quot;,381+70 ,0);  &#xA;    SetProperty(pfm,&quot;visible&quot;,1);&#xA;    //SetProperty(pfm,&quot;caption&quot;,&quot;20120531&quot;);    &#xA;    curYear=st.wYear;&#xA;    curMonth=st.wMonth;&#xA;    DrawMonth(curYear,curMonth);&#xA;}&#xA;&#xA;static unsigned char const year_code[]=&#xA;{&#xA;    0x04,0xAe,0x53, //1901 0&#xA;    0x0A,0x57,0x48, //1902 3&#xA;    0x55,0x26,0xBd, //1903 6&#xA;    0x0d,0x26,0x50, //1904 9&#xA;    0x0d,0x95,0x44, //1905 12&#xA;    0x46,0xAA,0xB9, //1906 15&#xA;    0x05,0x6A,0x4d, //1907 18&#xA;    0x09,0xAd,0x42, //1908 21&#xA;    0x24,0xAe,0xB6, //1909&#xA;    0x04,0xAe,0x4A, //1910&#xA;    0x6A,0x4d,0xBe, //1911&#xA;    0x0A,0x4d,0x52, //1912&#xA;    0x0d,0x25,0x46, //1913&#xA;    0x5d,0x52,0xBA, //1914&#xA;    0x0B,0x54,0x4e, //1915&#xA;    0x0d,0x6A,0x43, //1916&#xA;    0x29,0x6d,0x37, //1917&#xA;    0x09,0x5B,0x4B, //1918&#xA;    0x74,0x9B,0xC1, //1919&#xA;    0x04,0x97,0x54, //1920&#xA;    0x0A,0x4B,0x48, //1921&#xA;    0x5B,0x25,0xBC, //1922&#xA;    0x06,0xA5,0x50, //1923&#xA;    0x06,0xd4,0x45, //1924&#xA;    0x4A,0xdA,0xB8, //1925&#xA;    0x02,0xB6,0x4d, //1926&#xA;    0x09,0x57,0x42, //1927&#xA;    0x24,0x97,0xB7, //1928&#xA;    0x04,0x97,0x4A, //1929&#xA;    0x66,0x4B,0x3e, //1930&#xA;    0x0d,0x4A,0x51, //1931&#xA;    0x0e,0xA5,0x46, //1932&#xA;    0x56,0xd4,0xBA, //1933&#xA;    0x05,0xAd,0x4e, //1934&#xA;    0x02,0xB6,0x44, //1935&#xA;    0x39,0x37,0x38, //1936&#xA;    0x09,0x2e,0x4B, //1937&#xA;    0x7C,0x96,0xBf, //1938&#xA;    0x0C,0x95,0x53, //1939&#xA;    0x0d,0x4A,0x48, //1940&#xA;    0x6d,0xA5,0x3B, //1941&#xA;    0x0B,0x55,0x4f, //1942&#xA;    0x05,0x6A,0x45, //1943&#xA;    0x4A,0xAd,0xB9, //1944&#xA;    0x02,0x5d,0x4d, //1945&#xA;    0x09,0x2d,0x42, //1946&#xA;    0x2C,0x95,0xB6, //1947&#xA;    0x0A,0x95,0x4A, //1948&#xA;    0x7B,0x4A,0xBd, //1949&#xA;    0x06,0xCA,0x51, //1950&#xA;    0x0B,0x55,0x46, //1951&#xA;    0x55,0x5A,0xBB, //1952&#xA;    0x04,0xdA,0x4e, //1953&#xA;    0x0A,0x5B,0x43, //1954&#xA;    0x35,0x2B,0xB8, //1955&#xA;    0x05,0x2B,0x4C, //1956&#xA;    0x8A,0x95,0x3f, //1957&#xA;    0x0e,0x95,0x52, //1958&#xA;    0x06,0xAA,0x48, //1959&#xA;    0x7A,0xd5,0x3C, //1960&#xA;    0x0A,0xB5,0x4f, //1961&#xA;    0x04,0xB6,0x45, //1962&#xA;    0x4A,0x57,0x39, //1963&#xA;    0x0A,0x57,0x4d, //1964&#xA;    0x05,0x26,0x42, //1965&#xA;    0x3e,0x93,0x35, //1966&#xA;    0x0d,0x95,0x49, //1967&#xA;    0x75,0xAA,0xBe, //1968&#xA;    0x05,0x6A,0x51, //1969&#xA;    0x09,0x6d,0x46, //1970&#xA;    0x54,0xAe,0xBB, //1971&#xA;    0x04,0xAd,0x4f, //1972&#xA;    0x0A,0x4d,0x43, //1973&#xA;    0x4d,0x26,0xB7, //1974&#xA;    0x0d,0x25,0x4B, //1975&#xA;    0x8d,0x52,0xBf, //1976&#xA;    0x0B,0x54,0x52, //1977&#xA;    0x0B,0x6A,0x47, //1978&#xA;    0x69,0x6d,0x3C, //1979&#xA;    0x09,0x5B,0x50, //1980&#xA;    0x04,0x9B,0x45, //1981&#xA;    0x4A,0x4B,0xB9, //1982&#xA;    0x0A,0x4B,0x4d, //1983&#xA;    0xAB,0x25,0xC2, //1984&#xA;    0x06,0xA5,0x54, //1985&#xA;    0x06,0xd4,0x49, //1986&#xA;    0x6A,0xdA,0x3d, //1987&#xA;    0x0A,0xB6,0x51, //1988&#xA;    0x09,0x37,0x46, //1989&#xA;    0x54,0x97,0xBB, //1990&#xA;    0x04,0x97,0x4f, //1991&#xA;    0x06,0x4B,0x44, //1992&#xA;    0x36,0xA5,0x37, //1993&#xA;    0x0e,0xA5,0x4A, //1994&#xA;    0x86,0xB2,0xBf, //1995&#xA;    0x05,0xAC,0x53, //1996&#xA;    0x0A,0xB6,0x47, //1997&#xA;    0x59,0x36,0xBC, //1998&#xA;    0x09,0x2e,0x50, //1999 294&#xA;    0x0C,0x96,0x45, //2000 297&#xA;    0x4d,0x4A,0xB8, //2001&#xA;    0x0d,0x4A,0x4C, //2002&#xA;    0x0d,0xA5,0x41, //2003&#xA;    0x25,0xAA,0xB6, //2004&#xA;    0x05,0x6A,0x49, //2005&#xA;    0x7A,0xAd,0xBd, //2006&#xA;    0x02,0x5d,0x52, //2007&#xA;    0x09,0x2d,0x47, //2008&#xA;    0x5C,0x95,0xBA, //2009&#xA;    0x0A,0x95,0x4e, //2010&#xA;    0x0B,0x4A,0x43, //2011&#xA;    0x4B,0x55,0x37, //2012&#xA;    0x0A,0xd5,0x4A, //2013&#xA;    0x95,0x5A,0xBf, //2014&#xA;    0x04,0xBA,0x53, //2015&#xA;    0x0A,0x5B,0x48, //2016&#xA;    0x65,0x2B,0xBC, //2017&#xA;    0x05,0x2B,0x50, //2018&#xA;    0x0A,0x93,0x45, //2019&#xA;    0x47,0x4A,0xB9, //2020&#xA;    0x06,0xAA,0x4C, //2021&#xA;    0x0A,0xd5,0x41, //2022&#xA;    0x24,0xdA,0xB6, //2023&#xA;    0x04,0xB6,0x4A, //2024&#xA;    0x69,0x57,0x3d, //2025&#xA;    0x0A,0x4e,0x51, //2026&#xA;    0x0d,0x26,0x46, //2027&#xA;    0x5e,0x93,0x3A, //2028&#xA;    0x0d,0x53,0x4d, //2029&#xA;    0x05,0xAA,0x43, //2030&#xA;    0x36,0xB5,0x37, //2031&#xA;    0x09,0x6d,0x4B, //2032&#xA;    0xB4,0xAe,0xBf, //2033&#xA;    0x04,0xAd,0x53, //2034&#xA;    0x0A,0x4d,0x48, //2035&#xA;    0x6d,0x25,0xBC, //2036&#xA;    0x0d,0x25,0x4f, //2037&#xA;    0x0d,0x52,0x44, //2038&#xA;    0x5d,0xAA,0x38, //2039&#xA;    0x0B,0x5A,0x4C, //2040&#xA;    0x05,0x6d,0x41, //2041&#xA;    0x24,0xAd,0xB6, //2042&#xA;    0x04,0x9B,0x4A, //2043&#xA;    0x7A,0x4B,0xBe, //2044&#xA;    0x0A,0x4B,0x51, //2045&#xA;    0x0A,0xA5,0x46, //2046&#xA;    0x5B,0x52,0xBA, //2047&#xA;    0x06,0xd2,0x4e, //2048&#xA;    0x0A,0xdA,0x42, //2049&#xA;    0x35,0x5B,0x37, //2050&#xA;    0x09,0x37,0x4B, //2051&#xA;    0x84,0x97,0xC1, //2052&#xA;    0x04,0x97,0x53, //2053&#xA;    0x06,0x4B,0x48, //2054&#xA;    0x66,0xA5,0x3C, //2055&#xA;    0x0e,0xA5,0x4f, //2056&#xA;    0x06,0xB2,0x44, //2057&#xA;    0x4A,0xB6,0x38, //2058&#xA;    0x0A,0xAe,0x4C, //2059&#xA;    0x09,0x2e,0x42, //2060&#xA;    0x3C,0x97,0x35, //2061&#xA;    0x0C,0x96,0x49, //2062&#xA;    0x7d,0x4A,0xBd, //2063&#xA;    0x0d,0x4A,0x51, //2064&#xA;    0x0d,0xA5,0x45, //2065&#xA;    0x55,0xAA,0xBA, //2066&#xA;    0x05,0x6A,0x4e, //2067&#xA;    0x0A,0x6d,0x43, //2068&#xA;    0x45,0x2e,0xB7, //2069&#xA;    0x05,0x2d,0x4B, //2070&#xA;    0x8A,0x95,0xBf, //2071&#xA;    0x0A,0x95,0x53, //2072&#xA;    0x0B,0x4A,0x47, //2073&#xA;    0x6B,0x55,0x3B, //2074&#xA;    0x0A,0xd5,0x4f, //2075&#xA;    0x05,0x5A,0x45, //2076&#xA;    0x4A,0x5d,0x38, //2077&#xA;    0x0A,0x5B,0x4C, //2078&#xA;    0x05,0x2B,0x42, //2079&#xA;    0x3A,0x93,0xB6, //2080&#xA;    0x06,0x93,0x49, //2081&#xA;    0x77,0x29,0xBd, //2082&#xA;    0x06,0xAA,0x51, //2083&#xA;    0x0A,0xd5,0x46, //2084&#xA;    0x54,0xdA,0xBA, //2085&#xA;    0x04,0xB6,0x4e, //2086&#xA;    0x0A,0x57,0x43, //2087&#xA;    0x45,0x27,0x38, //2088&#xA;    0x0d,0x26,0x4A, //2089&#xA;    0x8e,0x93,0x3e, //2090&#xA;    0x0d,0x52,0x52, //2091&#xA;    0x0d,0xAA,0x47, //2092&#xA;    0x66,0xB5,0x3B, //2093&#xA;    0x05,0x6d,0x4f, //2094&#xA;    0x04,0xAe,0x45, //2095&#xA;    0x4A,0x4e,0xB9, //2096&#xA;    0x0A,0x4d,0x4C, //2097&#xA;    0x0d,0x15,0x41, //2098&#xA;    0x2d,0x92,0xB5, //2099&#xA;};&#xA;&#xA;/*月份数据表*/&#xA;static unsigned char  const day_code1[9]= {0x0,0x1f,0x3b,0x5a,0x78,0x97,0xb5,0xd4,0xf3};&#xA;static unsigned short const day_code2[3]= {0x111,0x130,0x14e};&#xA;/****************************************************************************&#xA;* 子函数,用于读取数据表中农历月的大月或小月,如果该月为大返回1,为小返回0&#xA;****************************************************************************/&#xA;static unsigned char GetMoonDay(unsigned char month_p,unsigned short table_addr)&#xA;{&#xA;    switch (month_p)&#xA;    {&#xA;    case 1:&#xA;        if((year_code[table_addr]&amp;0x08)==0)    return(0);&#xA;        else                                 return(1);&#xA;    case 2:&#xA;        if((year_code[table_addr]&amp;0x04)==0)    return(0);&#xA;        else                                 return(1);&#xA;    case 3:&#xA;        if((year_code[table_addr]&amp;0x02)==0)    return(0);&#xA;        else                                 return(1);&#xA;    case 4:&#xA;        if((year_code[table_addr]&amp;0x01)==0)    return(0);&#xA;        else                                 return(1);&#xA;    case 5:&#xA;        if((year_code[table_addr+1]&amp;0x80)==0)    return(0);&#xA;        else                                     return(1);&#xA;    case 6:&#xA;        if((year_code[table_addr+1]&amp;0x40)==0)    return(0);&#xA;        else                                     return(1);&#xA;    case 7:&#xA;        if((year_code[table_addr+1]&amp;0x20)==0)    return(0);&#xA;        else                                     return(1);&#xA;    case 8:&#xA;        if((year_code[table_addr+1]&amp;0x10)==0)    return(0);&#xA;        else                                     return(1);&#xA;    case 9:&#xA;        if((year_code[table_addr+1]&amp;0x08)==0)    return(0);&#xA;        else                                     return(1);&#xA;    case 10:&#xA;        if((year_code[table_addr+1]&amp;0x04)==0)    return(0);&#xA;        else                                     return(1);&#xA;    case 11:&#xA;        if((year_code[table_addr+1]&amp;0x02)==0)    return(0);&#xA;        else                                     return(1);&#xA;    case 12:&#xA;        if((year_code[table_addr+1]&amp;0x01)==0)    return(0);&#xA;        else                                     return(1);&#xA;    case 13:&#xA;        if((year_code[table_addr+2]&amp;0x80)==0)    return(0);&#xA;        else                                     return(1);&#xA;    }&#xA;    return(0);&#xA;}&#xA;&#xA;/*********************************************************************************************************&#xA;** 函数名称:GetChinaCalendar&#xA;** 功能描述:公农历转换(只允许1901-2099年)&#xA;** 输　入:  year        公历年&#xA;**          month       公历月&#xA;**          day         公历日&#xA;**          p           储存农历日期地址&#xA;** 输　出:  1           成功&#xA;**          0           失败&#xA;*****/&#xA;unsigned char GetChinaCalendar(&#xA;    unsigned int  year,&#xA;    unsigned char month,&#xA;    unsigned char day,&#xA;    unsigned char *p)&#xA;{&#xA;    unsigned char temp1,temp2,temp3,month_p,yearH,yearL;&#xA;    unsigned char flag_y;&#xA;    unsigned short temp4,table_addr;&#xA;&#xA;    yearH=year/100;&#xA;    yearL=year%100;&#xA;    if((yearH!=19)&amp;&amp;(yearH!=20))    return(0);&#xA;&#xA;    /* 定位数据表地址 */&#xA;    if(yearH==20)    table_addr=(yearL+100-1)*3;&#xA;    else              table_addr=(yearL-1)*3;&#xA;&#xA;    /* 取当年春节所在的公历月份 */&#xA;    temp1=year_code[table_addr+2]&amp;0x60;&#xA;    temp1&gt;&gt;=5;&#xA;&#xA;    /* 取当年春节所在的公历日 */&#xA;    temp2=year_code[table_addr+2]&amp;31;&#xA;&#xA;    /* 计算当年春年离当年元旦的天数,春节只会在公历1月或2月 */&#xA;    if(temp1==1)     temp3=temp2-1;&#xA;    else             temp3=temp2+31-1;&#xA;&#xA;    /* 计算公历日离当年元旦的天数 */&#xA;    if (month&lt;10)     temp4=day_code1[month-1]+day-1;&#xA;    else              temp4=day_code2[month-10]+day-1;&#xA;    /* 如果公历月大于2月并且该年的2月为闰月,天数加1 */&#xA;    if ((month&gt;2)&amp;&amp;(yearL%4==0))     temp4++;&#xA;&#xA;    /* 判断公历日在春节前还是春节后 */&#xA;    if (temp4&gt;=temp3)&#xA;    {&#xA;        temp4-=temp3;&#xA;        month=1;&#xA;        month_p=1;&#xA;&#xA;        flag_y=0;&#xA;        if(GetMoonDay(month_p,table_addr)==0)    temp1=29; //小月29天&#xA;        else                                     temp1=30; //大小30天&#xA;        /* 从数据表中取该年的闰月月份,如为0则该年无闰月 */&#xA;        temp2=year_code[table_addr]/16;&#xA;        while(temp4&gt;=temp1)&#xA;        {&#xA;            temp4-=temp1;&#xA;            month_p++;&#xA;            if(month==temp2)&#xA;            {&#xA;                flag_y=~flag_y;&#xA;                if(flag_y==0)month++;&#xA;            }&#xA;            else month++;&#xA;            if(GetMoonDay(month_p,table_addr)==0)    temp1=29;&#xA;            else                                     temp1=30;&#xA;        }&#xA;        day=temp4+1;&#xA;    }&#xA;    /* 公历日在春节前使用下面代码进行运算 */&#xA;    else&#xA;    {&#xA;        temp3-=temp4;&#xA;        if (yearL==0)&#xA;        {&#xA;            yearL=100-1;&#xA;            yearH=19;&#xA;        }&#xA;        else yearL--;&#xA;        table_addr-=3;&#xA;        month=12;&#xA;        temp2=year_code[table_addr]/16;&#xA;        if (temp2==0)    month_p=12;&#xA;        else             month_p=13;&#xA;&#xA;        flag_y=0;&#xA;        if(GetMoonDay(month_p,table_addr)==0)    temp1=29;&#xA;        else                                     temp1=30;&#xA;        while(temp3&gt;temp1)&#xA;        {&#xA;            temp3-=temp1;&#xA;            month_p--;&#xA;            if(flag_y==0)        month--;&#xA;            if(month==temp2)    flag_y=~flag_y;&#xA;            if(GetMoonDay(month_p,table_addr)==0)    temp1=29;&#xA;            else                                     temp1=30;&#xA;        }&#xA;        day=temp1-temp3+1;&#xA;    }&#xA;&#xA;    *p++=yearH;&#xA;    *p++=yearL;&#xA;    *p++=month;&#xA;    *p=day;&#xA;    return(1);&#xA;}&#xA;&#xA;static unsigned char const table_week[12]= {0,3,3,6,1,4,6,2,5,0,3,5}; //月修正数据表&#xA;/*********************************************************************************************************&#xA;** 函数名称:GetWeek&#xA;** 功能描述:输入公历日期得到星期(只允许1901-2099年)&#xA;** 输　入:  year        公历年&#xA;**          month       公历月&#xA;**          day            公历日&#xA;**          p           储存星期地址&#xA;** 输　出:  无&#xA;***********************/&#xA;void GetWeek(&#xA;    unsigned int year,&#xA;    unsigned char month,&#xA;    unsigned char day,&#xA;    unsigned char *p)&#xA;{&#xA;    unsigned int temp2;&#xA;    unsigned char yearH,yearL;&#xA;&#xA;    yearH=year/100;&#xA;    yearL=year%100;&#xA;&#xA;    /* 如果为21世纪,年份数加100 */&#xA;    if (yearH&gt;19)         yearL+=100;&#xA;    /* 所过闰年数只算1900年之后的 */&#xA;    temp2=yearL+yearL/4;&#xA;    temp2=temp2%7;&#xA;    temp2=temp2+day+table_week[month-1];&#xA;    if (yearL%4==0&amp;&amp;month&lt;3)    temp2--;&#xA;    *p=(temp2%7);&#xA;}&#xA;&#xA;/*********************************************************************************************************&#xA;** 函数名称:GetSkyEarth&#xA;** 功能描述:输入公历日期得到一个甲子年(只允许1901-2099年)&#xA;** 输　入:  year        公历年&#xA;**          p           储存星期地址&#xA;** 输　出:  无&#xA;**********************************************************************************/&#xA;static void GetSkyEarth(unsigned int year,unsigned char *p)&#xA;{&#xA;    unsigned char x;&#xA;&#xA;    if(year&gt;=1984)&#xA;    {&#xA;        year=year-1984;&#xA;        x=year%60;&#xA;    }&#xA;    else&#xA;    {&#xA;        year=1984-year;&#xA;        x=60-year%60;&#xA;    }&#xA;    *p=x;&#xA;}&#xA;static void StrCopy(char *target,unsigned char const *source,unsigned char no)&#xA;{&#xA;    unsigned int i;&#xA;&#xA;    for(i=0; i&lt;no; i++)&#xA;    {&#xA;        *target++=*source++;&#xA;    }&#xA;}&#xA;/*********************************************************************************************************&#xA;** 函数名称:GetChinaCalendarStr&#xA;** 功能描述:输入公历日期得到农历字符串&#xA;**          如:GetChinaCalendarStr(2007,02,06,str) 返回str=&quot;丙戌年腊月十九&quot;&#xA;** 输　入:  year        公历年&#xA;**          month       公历月&#xA;**          day         公历日&#xA;**          str         储存农历日期字符串地址   15Byte&#xA;** 输　出:  无&#xA;*******************************************************************************/&#xA;void GetChinaCalendarStr(&#xA;    unsigned int  year,&#xA;    unsigned char month,&#xA;    unsigned char day,&#xA;    char *str)&#xA;{&#xA;    unsigned char NLyear[4];&#xA;    unsigned char SEyear;&#xA;&#xA;    StrCopy(&amp;str[0],(unsigned char *)&quot;甲子年正月初一&quot;,15);&#xA;    if(GetChinaCalendar(year,month,day,(unsigned char *)NLyear)==0)	return;&#xA;    GetSkyEarth(NLyear[0]*100+NLyear[1],&amp;SEyear);&#xA;    StrCopy(&amp;str[0],(unsigned char *)  sky[SEyear%10],2);	//  甲&#xA;    StrCopy(&amp;str[2],(unsigned char *)earth[SEyear%12],2);	//  子&#xA;&#xA;    if(NLyear[2]==1)	StrCopy(&amp;str[6],(unsigned char *)&quot;正&quot;,2);&#xA;    else				StrCopy(&amp;str[6],(unsigned char *)monthcode[NLyear[2]-1],2);&#xA;&#xA;    if(NLyear[3]&gt;10) 	StrCopy(&amp;str[10],(unsigned char *)nongliday[NLyear[3]/10],2);&#xA;    else				StrCopy(&amp;str[10],(unsigned char *)&quot;初&quot;,2);&#xA;    StrCopy(&amp;str[12],(unsigned char *)monthcode[(NLyear[3]-1)%10],2);&#xA;}&#xA;&#xA;/*********************************************************************************************************&#xA;**         以下为24节气计算相关程序&#xA;**------------------------------------------------------------------------------------------------------&#xA;********************************************************************************************************/&#xA;&#xA;&#xA;/*&#xA;    每年24节气标志表&#xA;    有兴趣的朋友可按照上面给的原理添加其它年份的表格&#xA;    &#xA;*/&#xA;static unsigned char const YearMonthBit[]=&#xA;{&#xA;    0x4E,0xA6,0x99,		//2000&#xA;    0x9C,0xA2,0x98,		//2001&#xA;    0x80,0x00,0x18,		//2002&#xA;    0x00,0x10,0x24,		//2003&#xA;    0x4E,0xA6,0x99,		//2004&#xA;    0x9C,0xA2,0x98,		//2005&#xA;    0x80,0x82,0x18,		//2006&#xA;    0x00,0x10,0x24,		//2007&#xA;    0x4E,0xA6,0xD9,		//2008&#xA;    0x9E,0xA2,0x98,		//2009&#xA;&#xA;    0x80,0x82,0x18,		//2010&#xA;    0x00,0x10,0x04,		//2011&#xA;    0x4E,0xE6,0xD9,		//2012&#xA;    0x9E,0xA6,0xA8,		//2013&#xA;    0x80,0x82,0x18,		//2014&#xA;    0x00,0x10,0x00,		//2015&#xA;    0x0F,0xE6,0xD9,		//2016&#xA;    0xBE,0xA6,0x98,		//2017&#xA;    0x88,0x82,0x18,		//2018&#xA;    0x80,0x00,0x00,		//2019&#xA;&#xA;    0x0F,0xEF,0xD9,		//2020&#xA;    0xBE,0xA6,0x99,		//2021&#xA;    0x8C,0x82,0x98,		//2022&#xA;    0x80,0x00,0x00,		//2023&#xA;    0x0F,0xEF,0xDB,		//2024&#xA;    0xBE,0xA6,0x99,		//2025&#xA;    0x9C,0xA2,0x98,		//2026&#xA;    0x80,0x00,0x18,		//2027&#xA;    0x0F,0xEF,0xDB,		//2028&#xA;    0xBE,0xA6,0x99,		//2029&#xA;&#xA;    0x9C,0xA2,0x98,		//2030&#xA;    0x80,0x00,0x18,		//2031&#xA;    0x0F,0xEF,0xDB,		//2032&#xA;    0xBE,0xA2,0x99,		//2033&#xA;    0x8C,0xA0,0x98,		//2034&#xA;    0x80,0x82,0x18,		//2035&#xA;    0x0B,0xEF,0xDB,		//2036&#xA;    0xBE,0xA6,0x99,		//2037&#xA;    0x8C,0xA2,0x98,		//2038&#xA;    0x80,0x82,0x18,		//2039&#xA;&#xA;    0x0F,0xEF,0xDB,		//2040&#xA;    0xBE,0xE6,0xD9,		//2041&#xA;    0x9E,0xA2,0x98,		//2042&#xA;    0x80,0x82,0x18,		//2043&#xA;    0x0F,0xEF,0xFB,		//2044&#xA;    0xBF,0xE6,0xD9,		//2045&#xA;    0x9E,0xA6,0x98,		//2046&#xA;    0x80,0x82,0x18,		//2047&#xA;    0x0F,0xFF,0xFF,		//2048&#xA;    0xFC,0xEF,0xD9,		//2049&#xA;    0xBE,0xA6,0x18,		//2050&#xA;};&#xA;static unsigned char const days[]=&#xA;{&#xA;    6,20,4,19,6,21,         //一月到三月  的节气基本日期&#xA;    5,20,6,21,6,21,         //四月到六月  的节气基本日期&#xA;    7,23,8,23,8,23,         //七月到九月  的节气基本日期&#xA;    8,24,8,22,7,22,         //十月到十二月的节气基本日期&#xA;};&#xA;static char const JieQiStr[][5]=  //以公历日期先后排序&#xA;{&#xA;    /*  名称        角度    公历日期     周期 */&#xA;    &quot;小寒&quot;,     //285     1月 6日&#xA;    &quot;大寒&quot;,     //300     1月20日    29.5天&#xA;    &quot;立春&quot;,     //315     2月 4日&#xA;    &quot;雨水&quot;,     //330     2月19日    29.8天&#xA;    &quot;惊蛰&quot;,     //345     3月 6日&#xA;    &quot;春分&quot;,     //  0     3月21日    30.2天&#xA;    &quot;清明&quot;,     // 15     4月 5日&#xA;    &quot;谷雨&quot;,     // 30     4月20日    30.7天&#xA;    &quot;立夏&quot;,     // 45     5月 6日&#xA;    &quot;夏满&quot;,     // 60     5月21日    31.2天&#xA;    &quot;芒种&quot;,     // 75     6月 6日&#xA;    &quot;夏至&quot;,     // 90     6月21日    31.4天&#xA;    &quot;小暑&quot;,     //105     7月 7日&#xA;    &quot;大暑&quot;,     //120     7月23日    31.4天&#xA;    &quot;立秋&quot;,     //135     8月 8日&#xA;    &quot;处暑&quot;,     //150     8月23日    31.1天&#xA;    &quot;白露&quot;,     //165     9月 8日&#xA;    &quot;秋分&quot;,     //180     9月23日    30.7天&#xA;    &quot;寒露&quot;,     //195    10月 8日&#xA;    &quot;霜降&quot;,     //210    10月24日    30.1天&#xA;    &quot;立冬&quot;,     //225    11月 8日&#xA;    &quot;小雪&quot;,     //240    11月22日    29.7天&#xA;    &quot;大雪&quot;,     //255    12月 7日&#xA;    &quot;冬至&quot;,     //270    12月22日    29.5天&#xA;};&#xA;/*********************************************************************************************************&#xA;** 函数名称:GetJieQi&#xA;** 功能描述:输入公历日期得到本月24节气日期 day&lt;15返回上半月节气,反之返回下半月&#xA;**          如:GetJieQiStr(2007,02,08,str) 返回str[0]=4&#xA;** 输　入:  year        公历年&#xA;**          month       公历月&#xA;**          day         公历日&#xA;**          str         储存对应本月节气日期地址   1Byte&#xA;** 输　出:  1           成功&#xA;**          0           失败&#xA;************************************************************************************/&#xA;unsigned char GetJieQi(&#xA;    unsigned  int year,&#xA;    unsigned char month,&#xA;    unsigned char day,&#xA;    unsigned char *JQdate)&#xA;{&#xA;    unsigned char bak1,value,JQ;&#xA;&#xA;    if((year&lt;2000)||(year&gt;2050))     return 0;&#xA;    if((month==0) ||(month&gt;12))      return 0;&#xA;    JQ = (month-1) *2 ;		                        //获得节气顺序标号(0～23&#xA;    if(day &gt;= 15) JQ++; 	                        //判断是否是上半月&#xA;&#xA;    bak1=YearMonthBit[(year-2000)*3+JQ/8];          //获得节气日期相对值所在字节&#xA;    value =((bak1&lt;&lt;(JQ%8))&amp;0x80);                   //获得节气日期相对值状态&#xA;&#xA;    *JQdate=days[JQ];&#xA;    if( value != 0 )&#xA;    {&#xA;        //判断年份,以决定节气相对值1代表1,还是－1。&#xA;        if( (JQ== 1||JQ== 11||JQ== 18||JQ== 21)&amp;&amp;year&lt; 2044)  (*JQdate)++;&#xA;        else                                                  (*JQdate)--;&#xA;    }&#xA;    return 1;&#xA;}&#xA;static unsigned char const MonthDayMax[]= {31,28,31,30,31,30,31,31,30,31,30,31,};&#xA;/*********************************************************************************************************&#xA;** 函数名称:GetJieQiStr&#xA;** 功能描述:输入公历日期得到24节气字符串&#xA;**          如:GetJieQiStr(2007,02,08,str) 返回str=&quot;离雨水还有11天&quot;&#xA;** 输　入:  year        公历年&#xA;**          month       公历月&#xA;**          day         公历日&#xA;**          str         储存24节气字符串地址   15Byte&#xA;** 输　出:  1           成功&#xA;**          0           失败&#xA;**********************************************************************************/&#xA;unsigned char GetJieQiStr(&#xA;    unsigned int year,&#xA;    unsigned char month,&#xA;    unsigned char day,&#xA;    char *str)&#xA;{&#xA;    unsigned char JQdate,JQ,MaxDay;&#xA;&#xA;    if(GetJieQi(year,month,day,&amp;JQdate)==0)	return 0;&#xA;&#xA;    JQ = (month-1) *2 ;                             //获得节气顺序标号(0～23&#xA;    if(day &gt;= 15) JQ++;                             //判断是否是上半月&#xA;&#xA;    if(day==JQdate)                                 //今天正是一个节气日&#xA;    {&#xA;        StrCopy(str,(unsigned char *)JieQiStr[JQ],5);&#xA;        return 1;&#xA;    }&#xA;    //今天不是一个节气日&#xA;    StrCopy(str,(unsigned char *)&quot;离小寒还有??天&quot;,15);&#xA;    if(day&lt;JQdate)                                  //如果今天日期小于本月的节气日期&#xA;    {&#xA;        StrCopy(&amp;str[2],(unsigned char *)JieQiStr[JQ],4);&#xA;        day=JQdate-day;&#xA;    }&#xA;    else                                            //如果今天日期大于本月的节气日期&#xA;    {&#xA;        StrCopy(&amp;str[2],(unsigned char *)JieQiStr[JQ+1],4);&#xA;        if(day &lt; 15)&#xA;        {&#xA;            GetJieQi(year,month,15,&amp;JQdate);&#xA;            day=JQdate-day;&#xA;        }&#xA;        else                                        //翻月&#xA;        {&#xA;            MaxDay=MonthDayMax[month-1];&#xA;            if(month==2)                            //润月问题&#xA;            {&#xA;                if((year%4==0)&amp;&amp;((year%100!=0)||(year%400==0))) MaxDay++;&#xA;            }&#xA;            if(++month==13)	month=1;&#xA;            GetJieQi(year,month,1,&amp;JQdate);&#xA;            day=MaxDay-day+JQdate;&#xA;        }&#xA;    }&#xA;    str[10]=day/10+'0';&#xA;    str[11]=day%10+'0';&#xA;    return 1;&#xA;}"/>
    <Command cmdname="默认显示" cmdType="P" cmd="[P]void main()&#xA;{&#xA;   //ClearOutput();   //清除输出窗口内容  &#xA;   //ClearCommWin();&#xA;   SetLayoutMode(0);&#xA;   OpenInputWin();&#xA;   HideTerminalWin();&#xA;   ClearVclControls();&#xA;   HideVclWin();&#xA;   HideLeftTools();&#xA;   HideRightTools();&#xA;}"/>
    <Command cmdname="万年历(flash)" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;void main()&#xA;{      &#xA;    char dir[255],s[255];    &#xA;    GetExeDir(dir,255);&#xA;    sprintf(s,&quot;%s\\Dat\\wnl.swf&quot;,dir);&#xA;    int p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;万年历&quot;,&quot;Width&quot;,3000,&quot;height&quot;,370,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize];  &#xA;    int flash=CreateComponentEx(p,&quot;ShockwaveFlash&quot;,&quot;left&quot;,2,&quot;top&quot;,5,&quot;width&quot;,330,&quot;height&quot;,200,&quot;scalemode&quot;,3,NULL);&#xA;    SetProperty(flash,&quot;movie&quot;,s,strlen(s));&#xA;    int h=GetFlashMovieHeight(flash);&#xA;    int w=GetFlashMovieWidth(flash);&#xA;    SetProperty(p,&quot;width&quot;,550);&#xA;    SetProperty(p,&quot;height&quot;,530);  &#xA;    SetProperty(flash,&quot;align&quot;,&quot;alClient&quot;,19);&#xA;    SetProperty(p,&quot;visible&quot;,1);////&#xA;}&#xA;"/>
    <Command cmdname="计算器(flash)" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;void main()&#xA;{  &#xA;    char dir[255],s[255];    &#xA;    GetExeDir(dir,255);&#xA;    sprintf(s,&quot;%s\\Dat\\calc_b.swf&quot;,dir);&#xA;    int p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;计算器&quot;,&quot;Width&quot;,3000,&quot;height&quot;,370,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize];  &#xA;    int flash=CreateComponentEx(p,&quot;ShockwaveFlash&quot;,&quot;left&quot;,2,&quot;top&quot;,5,&quot;width&quot;,330,&quot;height&quot;,200,&quot;scalemode&quot;,3,NULL);&#xA;    SetProperty(flash,&quot;movie&quot;,s,strlen(s));&#xA;    int h=GetFlashMovieHeight(flash);&#xA;    int w=GetFlashMovieWidth(flash);&#xA;    SetProperty(p,&quot;width&quot;,490); //w+10&#xA;    SetProperty(p,&quot;height&quot;,h+14); //600&#xA;    SetProperty(flash,&quot;align&quot;,&quot;alClient&quot;,19);&#xA;    SetProperty(p,&quot;visible&quot;,1);&#xA;}&#xA;"/>
    <Command cmdname="颜色拾取器(flash)" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;void main()&#xA;{&#xA;    char dir[255],s[255];&#xA;    GetExeDir(dir,255);&#xA;    sprintf(s,&quot;%s\\Dat\\colorpick.swf&quot;,dir);&#xA;    int p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;颜色拾取器&quot;,&quot;Width&quot;,660,&quot;height&quot;,370,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize];&#xA;    int flash=CreateComponentEx(p,&quot;ShockwaveFlash&quot;,&quot;left&quot;,2,&quot;top&quot;,5,&quot;width&quot;,330,&quot;height&quot;,200,&quot;scalemode&quot;,3,NULL);&#xA;    SetProperty(flash,&quot;movie&quot;,s,strlen(s));&#xA;    int h=GetFlashMovieHeight(flash);&#xA;    int w=GetFlashMovieWidth(flash);&#xA;    SetProperty(p,&quot;width&quot;,555);&#xA;    SetProperty(p,&quot;height&quot;,440);&#xA;    SetProperty(flash,&quot;align&quot;,&quot;alClient&quot;,19);&#xA;    SetProperty(p,&quot;visible&quot;,1);&#xA;}"/>
    <Command cmdname="单位换算器(flash)" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;void main()&#xA;{      &#xA;    char dir[255],s[255];    &#xA;    GetExeDir(dir,255);&#xA;    sprintf(s,&quot;%s\\Dat\\unitsConvert.swf&quot;,dir);&#xA;    int p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;单位换算器&quot;,&quot;Width&quot;,3000,&quot;height&quot;,370,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize];  &#xA;    int flash=CreateComponentEx(p,&quot;ShockwaveFlash&quot;,&quot;left&quot;,2,&quot;top&quot;,5,&quot;width&quot;,330,&quot;height&quot;,200,&quot;scalemode&quot;,3,NULL);&#xA;    SetProperty(flash,&quot;movie&quot;,s,strlen(s));&#xA;    int h=GetFlashMovieHeight(flash);&#xA;    int w=GetFlashMovieWidth(flash);&#xA;    SetProperty(p,&quot;width&quot;,w+6);&#xA;    SetProperty(p,&quot;height&quot;,h+40);  &#xA;    SetProperty(flash,&quot;align&quot;,&quot;alClient&quot;,19);&#xA;    SetProperty(p,&quot;visible&quot;,1);////&#xA;}&#xA;"/>
  </Command>
  <Command cmdname="嵌入式开发" cmdType="S" cmd="[S]=====数据发送区/C语言脚本编辑区=====&#xA;1.[F5]键发送/执行、[F4]键终止脚本运行。&#xA;2.[F8]键显示、隐藏输出栏。&#xA;3.[Ctrl+.]调出脚本接口函数列表、[Ctrl+/]提示函数参数信息、[Ctrl+P]列出代码模板。&#xA;4.[Ctrl+Enter]发送数据。&#xA;5.支持&quot;预处理&quot;功能，采用C语言脚本回调函数，对发送的数据进行预处理后发送。">
    <Command cmdname="2410/2440 DNW" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;void OpenFileClick(void *sender);&#xA;void DownLoadClick(void *sender);&#xA;void CancelClick(void *sender);&#xA;void AddFileToLv(unsigned char* s,unsigned char *time,int save);&#xA;void UpdateLv();&#xA;int edt1;&#xA;int cancel;&#xA;int pgb1;&#xA;int txt6;&#xA;int edt2;&#xA;int tmr1;&#xA;int txt2,btn2,btn3,lv;&#xA;int cb1;&#xA;&#xA;char *sIID=&quot;{8e120c45-4968-4188-ba19-9a82361c8fa8}&quot;;//usb 驱动程序 IID&#xA;#include &quot;windows.h&quot;&#xA;void DropFileFromTFtpServer(char* filename)&#xA;{&#xA;    char s[200];&#xA;    printf(&quot;get tftp file:%s&quot;,filename);&#xA;    sprintf(s,&quot;tftp -g -r %s 192.168.11.2&quot;,filename);&#xA;#if 0&#xA;    if(MessageBox(GetAppHandle(),s,&quot;是否执行命令？&quot;,4)==6)&#xA;#endif&#xA;        SendString(s);&#xA;}&#xA;void DropFileToTFtpServer(char* filename)&#xA;{&#xA;    char s[200];&#xA;    printf(&quot;Send tftp file:%s&quot;,filename);&#xA;    sprintf(s,&quot;tftp -p -l %s 192.168.11.2&quot;,filename);&#xA;#if 0&#xA;    if(MessageBox(GetAppHandle(),s,&quot;是否执行命令？&quot;,4)==6)&#xA;#endif&#xA;        SendString(s);&#xA;}&#xA;void CommWinDbClick()&#xA;{&#xA;    char s[100];&#xA;    char s1[20];&#xA;    int len1=-1;&#xA;    int i;&#xA;&#xA;    int len=GetCommWinSelText(s,100);&#xA;&#xA;    int ck= GetProperty(cb1,&quot;checked&quot;,NULL,0);&#xA;    //printf(&quot;checked:%d&quot;,ck);&#xA;    if(ck==0)return;&#xA;    for(i=0; i&lt;len; i++)&#xA;    {&#xA;        if(len1==-1)&#xA;        {&#xA;            if((s[i]&gt;='0')&amp;&amp;(s[i]&lt;='9'))&#xA;            {&#xA;                len1=0;&#xA;                s1[len1++]=s[i];&#xA;            }&#xA;        }&#xA;        else&#xA;        {&#xA;            if((s[i]&gt;='0')&amp;&amp;(s[i]&lt;='9'))&#xA;            {&#xA;                s1[len1++]=s[i];&#xA;                if(len1&gt;10)break;&#xA;            }&#xA;            else break;&#xA;        }&#xA;    }&#xA;&#xA;    printf(&quot;len:%d-[%s]&quot;,len,s);&#xA;    if(len1&gt;0)&#xA;    {&#xA;        s1[len1]=0;&#xA;        len1=atoi(s1);&#xA;        printf(s1);&#xA;        printf(&quot;%d&quot;,len1);&#xA;        sprintf(s,&quot;数据内容:[%s]&quot;,s1);&#xA;#if 0&#xA;        int opt=MessageBox(GetAppHandle(),s,&quot;是否发送数据？&quot;,4);&#xA;        printf(&quot;opt:%d&quot;,opt);&#xA;        if(opt==6)&#xA;#endif&#xA;            SendString(s1);&#xA;&#xA;    }&#xA;}&#xA;void DownLoad()&#xA;{&#xA;    char s[200];&#xA;    CHAR *pBuffer;&#xA;    DWORD RSize;&#xA;    int fileSize = 0;&#xA;    int i;&#xA;    cancel=0;&#xA;    SetProperty(btn2,&quot;enabled&quot;,0);&#xA;    SetProperty(btn3,&quot;enabled&quot;,1);&#xA;    SetProperty(pgb1,&quot;position&quot;,0);&#xA;    SetProperty(txt6,&quot;caption&quot;,&quot;0%&quot;);&#xA;&#xA;    int iTmp=GetPathName(sIID,s,200);&#xA;&#xA;    if(iTmp&gt;0)  //devName~=&quot;&quot; then&#xA;        printf(&quot;Usb device PathName:%s&quot;,s);&#xA;    else&#xA;    {&#xA;        ShowMessage(&quot;Usb host not connected!&quot;);&#xA;        return ;&#xA;    }&#xA;    sprintf(s,&quot;%s\\\\PIPE01&quot;,s);&#xA;    printf(&quot;usb name:%s&quot;,s);&#xA;&#xA;    HANDLE Handle=CreateFile(s, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);&#xA;    if (Handle&lt;=0)&#xA;    {&#xA;        printf(&quot;打开文件%s错误！&quot;,s);&#xA;        return;&#xA;    }&#xA;    GetProperty(edt1,&quot;text&quot;,s,200);&#xA;    SaveIniString(&quot;DNW&quot;,&quot;FileName&quot;,s);&#xA;    AddFileToLv(s,0,1);&#xA;    GetProperty(edt2,&quot;text&quot;,s,200);&#xA;    SaveIniString(&quot;DNW&quot;,&quot;Address&quot;,s);&#xA;    GetProperty(edt1,&quot;text&quot;,s,200);&#xA;&#xA;    HANDLE Handle1=CreateFile(s, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);&#xA;&#xA;    printf(&quot;发送文件名称：%s&quot;,s);&#xA;&#xA;    if(Handle1&lt;=0)&#xA;    {&#xA;        sprintf(s,&quot;打开文件【%s】错误！&quot;,s);&#xA;        ShowMessage(s);//&quot;打开文件【&quot;..pb.edit1.text..&quot;】错误！&quot;);&#xA;        return  ;&#xA;    }&#xA;&#xA;    int Length =SetFilePointer(Handle1,0,NULL,FILE_END);&#xA;    SetFilePointer(Handle1,0,NULL,FILE_BEGIN);&#xA;    char *Buffer = malloc(Length + 10);  //   --addr(4bytes)+length(4bytes)+filedata(length bytes)+checksum(2bytes)&#xA;    int BytesRead ;&#xA;    ReadFile(Handle1, Buffer+8, Length,&amp;BytesRead,NULL);&#xA;    CloseHandle(Handle1);&#xA;    GetProperty(edt2,&quot;text&quot;,s,200);&#xA;    int downloadAddress=StrToInt(s); //0x32000000;&#xA;&#xA;    printf(&quot;Address:0x%x&quot;,downloadAddress);&#xA;    Buffer[0]=(downloadAddress&gt;&gt;0)&amp;0xff;&#xA;    Buffer[1]=(downloadAddress&gt;&gt;8)&amp;0xff;&#xA;    Buffer[2]=(downloadAddress&gt;&gt;16)&amp;0xff;&#xA;    Buffer[3]=(downloadAddress&gt;&gt;24)&amp;0xff;&#xA;    int len1=Length+10;&#xA;    Buffer[4]=(len1&gt;&gt;0)&amp;0xff;&#xA;    Buffer[5]=(len1&gt;&gt;8)&amp;0xff;&#xA;    Buffer[6]=(len1&gt;&gt;16)&amp;0xff;&#xA;    Buffer[7]=(len1&gt;&gt;24)&amp;0xff;&#xA;&#xA;    unsigned short cs=0;&#xA;    for(i=0; i&lt;Length; i++)&#xA;    {&#xA;        cs+=Buffer[8+i];      //  计算校验和&#xA;    }&#xA;    cs&amp;=0xffff; //                               --取16bits&#xA;    printf(&quot;check sum is :%x&quot;,cs);&#xA;    Buffer[Length+8]=(cs&gt;&gt;0)&amp;0xff;&#xA;    Buffer[Length+9]=(cs&gt;&gt;8)&amp;0xff;&#xA;    Length=Length+10;//addr(4bytes)+length(4bytes)+filedata(length bytes)+checksum(2bytes)&#xA;    int TxBufCount=0;&#xA;    int txBlkSize=0;&#xA;    int TX_SIZE=4096*4;&#xA;    int BytesWrite ;&#xA;    printf(&quot;Download to device ...&quot;);&#xA;    Update();&#xA;    while(1)&#xA;    {&#xA;        if (cancel==1)break;&#xA;        if((Length-TxBufCount) &gt; TX_SIZE)&#xA;            txBlkSize =TX_SIZE;&#xA;        else&#xA;            txBlkSize = Length-TxBufCount;&#xA;&#xA;        //printf(&quot;filewrite:%d...&quot;, txBlkSize);&#xA;        int wlen=WriteFile( Handle, Buffer+TxBufCount, txBlkSize, &amp;BytesWrite,NULL);&#xA;        //printf(&quot;wrote %d&quot;,BytesWrite);&#xA;        if(BytesWrite&lt;=0)&#xA;        {&#xA;            printf(&quot;下载失败，请重新启动开发板！&quot;);&#xA;            CloseHandle(Handle);&#xA;            free(Buffer);&#xA;            return;&#xA;        };&#xA;&#xA;        TxBufCount =TxBufCount+txBlkSize;&#xA;        float fPer=1.0f;&#xA;        //fPer=&#xA;        int per=((TxBufCount+1)*100)/Length;&#xA;        SetProperty(pgb1,&quot;position&quot;,per);&#xA;        sprintf(s,&quot;%d%s&quot;,per,&quot;%&quot;);&#xA;        SetProperty(txt6,&quot;caption&quot;,s);&#xA;        Update();&#xA;        //printf(&quot;write %d of %d:%d%&quot;,TxBufCount,Length,per);&#xA;        if (TxBufCount&gt;=  Length) break;&#xA;        Wait(0);&#xA;    };&#xA;    printf(&quot;close file ...&quot;);&#xA;    CloseHandle(Handle);&#xA;    printf(&quot;free mem ...&quot;);&#xA;    free(Buffer);&#xA;    printf(&quot;Download end&quot;);&#xA;    SetProperty(btn2,&quot;enabled&quot;,1);&#xA;    SetProperty(btn3,&quot;enabled&quot;,0);&#xA;}&#xA;&#xA;&#xA;&#xA;void OnTimer()&#xA;{&#xA;    char s[200];&#xA;    //printf(&quot;aaa&quot;);&#xA;    int iTmp=GetPathName(sIID,s,200);&#xA;    //printf(&quot;bbb&quot;);&#xA;    if(iTmp&gt;0)  //devName~=&quot;&quot; then&#xA;    {&#xA;        //printf(&quot;Usb device PathName:%s&quot;,s);&#xA;        SetProperty(txt2,&quot;caption&quot;,&quot;   USB:OK&quot;);&#xA;        SetProperty(txt2,&quot;color&quot;,0x00ff00);&#xA;        SetProperty(btn2,&quot;enabled&quot;,1);&#xA;    }&#xA;    else&#xA;    {&#xA;        //printf(&quot;Usb device PathName:%s&quot;,s);&#xA;        SetProperty(txt2,&quot;caption&quot;,&quot;   USB:x&quot;);&#xA;        SetProperty(txt2,&quot;color&quot;,0x0000ff);&#xA;        SetProperty(btn2,&quot;enabled&quot;,0);&#xA;    }&#xA;    //printf(&quot;ccc&quot;);&#xA;    UpdateLv();&#xA;    //printf(&quot;ddd&quot;);&#xA;}&#xA;&#xA;void Save()&#xA;{&#xA;    int i;&#xA;    char s1[200],s2[200];&#xA;    int count=GetListViewItemCount(lv);&#xA;    sprintf(s1,&quot;%d&quot;,count);&#xA;    SaveIniString(&quot;DNW&quot;,&quot;FileCount&quot;,s1);&#xA;    for(i=0; i&lt;count; i++)&#xA;    {&#xA;        GetListViewItem(lv,i,2,s1,200);&#xA;        sprintf(s2,&quot;FileName%d&quot;,i);&#xA;        SaveIniString(&quot;DNW&quot;,s2,s1);&#xA;&#xA;        GetListViewItem(lv,i,0,s1,200);&#xA;        sprintf(s2,&quot;FileDt%d&quot;,i);&#xA;        SaveIniString(&quot;DNW&quot;,s2,s1);&#xA;    }&#xA;}&#xA;&#xA;void KeyBtnClick(void *Sender)&#xA;{&#xA;    int tag,t;&#xA;    t=GetProperty(Sender,&quot;tag&quot;,&amp;tag,4);&#xA;    printf(&quot;tag:%d&quot;,t);&#xA;    SendByte(t);&#xA;}&#xA;void DelClick(void *Sender)&#xA;{&#xA;    int idx;&#xA;    idx=GetListViewItemIndex(lv);&#xA;    DelListViewItem(lv,idx);&#xA;    Save();&#xA;}&#xA;void ClearClick(void *Sender)&#xA;{&#xA;    while(GetListViewItemCount(lv)&gt;0)&#xA;        DelListViewItem(lv,0);&#xA;    Save();&#xA;}&#xA;void lvDbClick(void *Sender)&#xA;{&#xA;    int idx;&#xA;    char s1[200];&#xA;    idx=GetListViewItemIndex(lv);&#xA;&#xA;    GetListViewItem(lv,idx,2,s1,200);&#xA;    SetProperty(edt1,&quot;text&quot;,s1);&#xA;&#xA;}&#xA;void CloseClick(void *Sender)&#xA;{&#xA;    //UpdateLv();&#xA;    //return;&#xA;    ClearOutputWin();   //清除输出窗口内容&#xA;&#xA;    HideVclWin();&#xA;    // printf(&quot;hided&quot;);&#xA;    CloseVclWin();&#xA;}&#xA;&#xA;void main()&#xA;{&#xA;    ClearOutputWin();   //清除输出窗口内容&#xA;    //ClearCommWin();&#xA;&#xA;    CloseInputWin();&#xA;    ClearVclControls();&#xA;    printf(&quot;=============SAMSUNG S3C2410/2440 USB 下载工具(DNW)==============&quot;);&#xA;    int p=GetGuiWin();&#xA;    int pnl = CreateComponentEx(p,&quot;panel&quot;,&quot;caption&quot;,&quot;&quot;,&quot;left&quot;,2,&quot;top&quot;,2,&quot;width&quot;,650,&quot;height&quot;,230,NULL);&#xA;    int txt1= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;                  SAMSUNG S3C2410/2440 USB 下载工具(DNW)&quot;,&quot;left&quot;,30,&quot;top&quot;,10,&quot;width&quot;,350,&quot;color&quot;,0xff00ff,NULL);&#xA;    txt2= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;   USB:x&quot;,&quot;left&quot;,385,&quot;top&quot;,10,&quot;width&quot;,60,&quot;autosize&quot;,0,&quot;color&quot;,0x0000ff,NULL);&#xA;    int txt3= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;文件名称：&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,60,NULL);&#xA;    edt1= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;请输入文件名...&quot;,&quot;left&quot;,75,&quot;top&quot;,38,&quot;width&quot;,385,NULL);&#xA;&#xA;    int txt4= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;下载地址：&quot;,&quot;left&quot;,10,&quot;top&quot;,68,&quot;width&quot;,60,NULL);&#xA;    edt2= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;0x32000000&quot;,&quot;left&quot;,75,&quot;top&quot;,65,&quot;width&quot;,90,NULL);&#xA;&#xA;    int txt5= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;下载进度：&quot;,&quot;left&quot;,170,&quot;top&quot;,68,&quot;width&quot;,60,NULL);&#xA;    txt6= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;0%&quot;,&quot;left&quot;,228,&quot;top&quot;,68,&quot;width&quot;,40,NULL);&#xA;    pgb1= CreateComponentEx(pnl,&quot;progressbar&quot;,&quot;left&quot;,258,&quot;top&quot;,65,&quot;width&quot;,200,&quot;height&quot;,20,&quot;position&quot;,0,NULL);&#xA;    cb1= CreateComponentEx(pnl,&quot;checkbox&quot;,&quot;left&quot;,460,&quot;top&quot;,65,&quot;width&quot;,90,&quot;height&quot;,20,&quot;caption&quot;,&quot;双击直接操作&quot;,NULL);&#xA;&#xA;&#xA;&#xA;    int btn1= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;...&quot;,&quot;left&quot;,465,&quot;top&quot;,36,&quot;width&quot;,65,&quot;onclick&quot;,OpenFileClick,NULL);&#xA;    btn2= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;通过USB下载&quot;,&quot;left&quot;,535,&quot;top&quot;,10,&quot;width&quot;,105,&quot;height&quot;,50,&quot;onclick&quot;,DownLoadClick,NULL);&#xA;    btn3= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;取  消&quot;,&quot;left&quot;,555,&quot;top&quot;,65,&quot;width&quot;,85,&quot;onclick&quot;,CancelClick,NULL);&#xA;&#xA;    CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;删  除&quot;,&quot;left&quot;,555,&quot;top&quot;,110,&quot;width&quot;,85,&quot;onclick&quot;,DelClick,NULL);&#xA;    CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;清  空&quot;,&quot;left&quot;,555,&quot;top&quot;,140,&quot;width&quot;,85,&quot;onclick&quot;,ClearClick,NULL);&#xA;    CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;关  闭&quot;,&quot;left&quot;,555,&quot;top&quot;,190,&quot;width&quot;,85,&quot;onclick&quot;,CloseClick,NULL);&#xA;    int key_left=370;&#xA;    int key_top=10;&#xA;&#xA;&#xA;    lv=CreateComponentEx(pnl,&quot;listview&quot;,&quot;left&quot;,12,&quot;top&quot;,95,&quot;width&quot;,540,&quot;height&quot;,125,&quot;ondblclick&quot;,lvDbClick,NULL);&#xA;    AddListViewColumn(lv,&quot;更新&quot;,40);&#xA;    AddListViewColumn(lv,&quot;下载时间&quot;,115);&#xA;    AddListViewColumn(lv,&quot;更新时间&quot;,115);&#xA;    AddListViewColumn(lv,&quot;文件名称&quot;,880);&#xA;&#xA;&#xA;    tmr1=CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,1000,&quot;enabled&quot;,0,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮&#xA;    //ShowVclWin(230+8);&#xA;    //ShowOutputWin(330);&#xA;    CloseCodeWin();&#xA;    HideLeftTools();&#xA;    HideRightTools();&#xA;    ShowTerminalWin();&#xA;    PrintToCommWin(&quot; &quot;);&#xA;    PrintToCommWin(&quot; &quot;);&#xA;    //PrintToCommWin(&quot;                                                 &quot;);&#xA;    //PrintToCommWin(&quot;                                                   &quot;);&#xA;    //PrintToCommWin(&quot;                                                 &quot;);&#xA;    //PrintToCommWin(&quot;                                               &quot;);&#xA;    //PrintToCommWin(&quot;                                                     &quot;);&#xA;    //PrintToCommWin(&quot;                                           &quot;);&#xA;    /**/&#xA;    char s[200],s1[200],s2[200];&#xA;    GetIniString(&quot;DNW&quot;,&quot;FileName&quot;,s,200);&#xA;    SetProperty(edt1,&quot;text&quot;,s);&#xA;    GetIniString(&quot;DNW&quot;,&quot;Address&quot;,s,200);&#xA;    SetProperty(edt2,&quot;text&quot;,s);&#xA;    AutoSetVclWinSize();&#xA;    //printf(&quot;1...&quot;);&#xA;    GetIniString(&quot;DNW&quot;,&quot;FileCount&quot;,s,200);&#xA;&#xA;    //printf(&quot;2...&quot;);&#xA;    //printf(&quot;s:%s&quot;,s);&#xA;    if(strlen(s)&gt;0)&#xA;    {&#xA;        int count=StrToInt(s);&#xA;        //printf(&quot;2.1&quot;);&#xA;        int i;&#xA;        for(i=0; i&lt;count; i++)&#xA;        {&#xA;            //printf(&quot;2.i:%d&quot;,i);&#xA;            sprintf(s2,&quot;FileName%d&quot;,i);&#xA;            GetIniString(&quot;DNW&quot;,s2,s,200);&#xA;            sprintf(s2,&quot;FileDt%d&quot;,i);&#xA;            GetIniString(&quot;DNW&quot;,s2,s1,200);&#xA;            AddFileToLv(s,s1,0);&#xA;        }&#xA;    }&#xA;&#xA;    //printf(&quot;3...&quot;);&#xA;    UpdateLv();&#xA;&#xA;    char *IID=&quot;{8e120c45-4968-4188-ba19-9a82361c8fa8}&quot;;//usb 驱动程序 IID&#xA;    SetProperty(btn2,&quot;enabled&quot;,0);&#xA;    int addCount=0;&#xA;    SetProperty(tmr1,&quot;enabled&quot;,1);&#xA;&#xA;    DragAcceptFiles(GetWinHandle(lv),1);&#xA;    DragAcceptFiles(GetWinHandle(edt1),1);&#xA;&#xA;    SetMenuItemText(0,&quot;tftp 快速传输&quot;);&#xA;&#xA;    printf(&quot;inited&quot;);&#xA;}&#xA;&#xA;&#xA;void MenuItemClick(int idx)&#xA;{&#xA;    printf(&quot;MenuItem %d clicked!&quot;,idx);&#xA;    if(idx==0)&#xA;    {&#xA;        char s[100];&#xA;        int len=GetCommWinSelText(s,100);&#xA;        char buf[100];&#xA;        sprintf(buf,&quot;tftp -s -l ./%s 192.168.11.2\n&quot;,s);&#xA;        SendString(buf);&#xA;    }&#xA;}&#xA;void DropFile(int handle,unsigned char *filename)&#xA;{&#xA;    if(handle==GetWinHandle(edt1))&#xA;    {&#xA;        SetProperty(edt1,&quot;text&quot;,filename);&#xA;        SaveIniString(&quot;DNW&quot;,&quot;FileName&quot;,filename);&#xA;    }&#xA;    else if(handle==GetWinHandle(lv))&#xA;    {&#xA;        AddFileToLv(filename,0,1);&#xA;    }&#xA;    //printf(&quot;handle:%x,filename:%s&quot;,hd,filename);&#xA;}&#xA;&#xA;void AddFileToLv(unsigned char* s,unsigned char *time,int save)&#xA;{&#xA;    char s1[200],s2[200];&#xA;    int i,idx;&#xA;    idx=-1;&#xA;&#xA;    int count=GetListViewItemCount(lv);&#xA;    for(i=0; i&lt;count; i++)&#xA;    {&#xA;        GetListViewItem(lv,i,2,s1,200);&#xA;        if(strcmp(s,s1)==0)&#xA;        {&#xA;            idx=i;&#xA;            break;&#xA;        }&#xA;    }&#xA;    if(idx==-1)&#xA;    {&#xA;        StringsAdd(lv,&quot;&quot;);&#xA;        idx=GetListViewItemCount(lv)-1;&#xA;    }&#xA;    if(time!=0)&#xA;    {&#xA;        SetListViewItem(lv,idx,0,time);&#xA;    }&#xA;    else&#xA;    {&#xA;        GetDateTimeStr(s1,50);&#xA;        SetListViewItem(lv,idx,0,s1);&#xA;    }&#xA;    GetFileWriteTime(s,s1,200);&#xA;&#xA;&#xA;    SetListViewItem(lv,idx,1,s1);//&quot;2011-05-12 16:23:56&quot;);&#xA;    SetListViewItem(lv,idx,2,s);&#xA;&#xA;    if(save)&#xA;        Save();&#xA;}&#xA;void UpdateLv()&#xA;{&#xA;    char s1[200],s2[200];&#xA;    char fn[200];&#xA;    int i,idx;&#xA;    idx=-1;&#xA;&#xA;    int count=GetListViewItemCount(lv);&#xA;    for(i=0; i&lt;count; i++)&#xA;    {&#xA;&#xA;        GetListViewItem(lv,i,0,s1,200);&#xA;        GetListViewItem(lv,i,2,fn,200);&#xA;        GetFileWriteTime(fn,s2,200);&#xA;        SetListViewItem(lv,i,1,s2);&#xA;        //printf(&quot;%s ,%s&quot;,s1,s2);&#xA;        if(strcmp(s1,s2)&lt;0)&#xA;        {&#xA;            SetListViewItem(lv,i,-1,&quot; Y&quot;);&#xA;        }&#xA;        else&#xA;            SetListViewItem(lv,i,-1,&quot; &quot;);&#xA;    }&#xA;}&#xA;&#xA;&#xA;void OpenFileClick(void *sender)&#xA;{&#xA;    char s[200];&#xA;    GetFileName(s,200,&quot;*.*&quot;);&#xA;    if(strlen(s)&gt;0)&#xA;    {&#xA;        SetProperty(edt1,&quot;text&quot;,s);&#xA;        SaveIniString(&quot;DNW&quot;,&quot;FileName&quot;,s);&#xA;    }&#xA;    SetFocusToCommWin();&#xA;}&#xA;void DownLoadClick(void *sender)&#xA;{&#xA;    DownLoad();&#xA;    SetFocusToCommWin();&#xA;}&#xA;void CancelClick(void *sender)&#xA;{&#xA;    //char s[100];&#xA;    cancel=1;&#xA;    //GetProperty(edt1,&quot;text&quot;,s,100);&#xA;    //AddFileToLv(s,0,1);&#xA;}&#xA;&#xA;"/>
    <Command cmdname="GPRS的AT命令应用" cmdType="S" cmd="[S]new command">
      <Command cmdname="MC55 GPRS" cmdType="S" cmd="[S]none">
        <Command cmdname="TEXT方式发短信" cmdType="S" cmd="[S][E][E][E][E]none">
          <Command cmdname="取消指令回显" cmdType="S" cmd="[S]ATE0"/>
          <Command cmdname="打开指令回显" cmdType="S" cmd="[S]ATE1"/>
          <Command cmdname="设置TEXT方式发送短消息" cmdType="S" cmd="[S]AT+CMGF=1"/>
          <Command cmdname="设置端消息中心" cmdType="S" cmd="[S]AT+CSCA=&quot;+8613800551500&quot;"/>
          <Command cmdname="发出短消息(ctrl^Z) " cmdType="H" cmd="[H]1a"/>
        </Command>
        <Command cmdname="读出所有短信" cmdType="S" cmd="[S]AT+CMGL=&quot;ALL&quot;"/>
        <Command cmdname="打电话" cmdType="S" cmd="[S]ATD13905699792"/>
        <Command cmdname="Socket通讯" cmdType="S" cmd="[S][E][E][E][E]none">
          <Command cmdname="AT测试" cmdType="S" cmd="[S]AT"/>
          <Command cmdname="获取本机号码" cmdType="S" cmd="[S]AT+CNUM"/>
          <Command cmdname="查看信号强度" cmdType="S" cmd="[S]at+csq"/>
          <Command cmdname="设置连接方式" cmdType="S" cmd="[S]at^sics=0,conType,GPRS0"/>
          <Command cmdname="设置用户名" cmdType="S" cmd="[S]at^sics=0,user,gprs"/>
          <Command cmdname="设置口令" cmdType="S" cmd="[S]at^sics=0,passwd,gprs"/>
          <Command cmdname="设置连接方式1" cmdType="S" cmd="[S]at^sics=0,apn,cmnet"/>
          <Command cmdname="设置Socket" cmdType="S" cmd="[S]at^siss=1,srvType,socket"/>
          <Command cmdname="设置Socket1" cmdType="S" cmd="[S]at^siss=1,conId,0"/>
          <Command cmdname="设置目标IP地址、端口" cmdType="S" cmd="[S]at^siss=1,address,&quot;socktcp://220.248.243.211:6666&quot;"/>
          <Command cmdname="设置目标IP地址、端口google" cmdType="S" cmd="[S]at^siss=1,address,&quot;socktcp://210.45.246.4:80&quot;"/>
          <Command cmdname="打开socket连接" cmdType="S" cmd="[S]AT^SISO=1"/>
          <Command cmdname="发出10个字节内容" cmdType="S" cmd="[S]AT^SISW=1,10"/>
          <Command cmdname="具体内容" cmdType="S" cmd="[S]123456789s"/>
          <Command cmdname="具体内容1A [^Z]" cmdType="H" cmd="[H]1A"/>
          <Command cmdname="读出收到的内容" cmdType="S" cmd="[S]AT^SISR=1,10"/>
          <Command cmdname="关闭socket连接" cmdType="S" cmd="[S]AT^SISC=1  "/>
        </Command>
      </Command>
      <Command cmdname="SIM300 GPRS" cmdType="S" cmd="[S]none">
        <Command cmdname="基本AT指令" cmdType="S" cmd="[S]new command">
          <Command cmdname="AT测试" cmdType="S" cmd="[S]AT"/>
          <Command cmdname="AT测试" cmdType="P" cmd="[P]SendByte(0x41);&#xA;Wait(2);&#xA;SendByte(0x54);&#xA;Wait(2);&#xA;SendByte(0x0D);&#xA;Wait(2);&#xA;"/>
          <Command cmdname="取消指令回显" cmdType="S" cmd="[S]ATE0"/>
          <Command cmdname="打开指令回显" cmdType="S" cmd="[S]ATE1"/>
          <Command cmdname="查询设备厂商" cmdType="T" cmd="[T]AT+CGMI\rAT+CGMM\r "/>
          <Command cmdname="查询可用网络" cmdType="S" cmd="[S]at+cops=?"/>
        </Command>
        <Command cmdname="GPRS Socket" cmdType="S" cmd="[S]new command">
          <Command cmdname="查看信号强度" cmdType="S" cmd="[S]at+csq"/>
          <Command cmdname="设置连接方式0" cmdType="S" cmd="[S]AT+CIPMODE=0"/>
          <Command cmdname="设置连接方式1" cmdType="S" cmd="[S]AT+CIPMODE=1"/>
          <Command cmdname="设置目标IP地址、端口0" cmdType="S" cmd="[S]AT+CIPSTART=&quot;TCP&quot;,&quot;220.248.243.211&quot;,&quot;6666&quot;"/>
          <Command cmdname="设置目标IP地址、端口1" cmdType="S" cmd="[S]AT+CIPSTART=&quot;TCP&quot;,&quot;210.145.246.47&quot;,&quot;80&quot;"/>
          <Command cmdname="设置目标IP地址、端口2" cmdType="S" cmd="[S]AT+CIPSTART=&quot;TCP&quot;,&quot;210.145.246.4&quot;,&quot;6666&quot;"/>
          <Command cmdname="设置目标IP地址、端口1-google" cmdType="S" cmd="[S]AT+CIPSTART=&quot;TCP&quot;,&quot;203.208.137.104&quot;,&quot;80&quot;"/>
          <Command cmdname="设置目标IP地址、端口1-ustc telnet" cmdType="S" cmd="[S]AT+CIPSTART=&quot;TCP&quot;,&quot;202.38.164.9&quot;,&quot;23&quot;"/>
          <Command cmdname="发送5个字节" cmdType="S" cmd="[S]AT+CIPSEND=5"/>
          <Command cmdname="发送http请求" cmdType="T" cmd="[T]GET   /cgi-bin/qaweb.forte?inputXML=test.xml \r\n\r\n"/>
          <Command cmdname="5个字节内容" cmdType="S" cmd="[S]12345"/>
          <Command cmdname="发送数据，以1A结束" cmdType="S" cmd="[S]AT+CIPSEND"/>
          <Command cmdname="发送数据" cmdType="P" cmd="[P]SendString(GetString('请输入发送内容','abcd'));SendByte(0x1a);"/>
          <Command cmdname="结束符1a" cmdType="H" cmd="[H]1A"/>
          <Command cmdname="关闭socket连接" cmdType="S" cmd="[S]AT+CIPSHUT "/>
        </Command>
        <Command cmdname="GPRS连接到-Google网站" cmdType="S" cmd="[S]new command">
          <Command cmdname="1、查看信号强度" cmdType="S" cmd="[S]at+csq"/>
          <Command cmdname="2、设置连接方式0" cmdType="S" cmd="[S]AT+CIPMODE=0"/>
          <Command cmdname="3、显示接收数据的数据头" cmdType="S" cmd="[S]AT+CIPHEAD=1"/>
          <Command cmdname="4、设置目标IP地址、端口:谷歌" cmdType="S" cmd="[S]AT+CIPSTART=&quot;TCP&quot;,&quot;203.208.37.104&quot;,&quot;80&quot;"/>
          <Command cmdname="5、发送数据，以1A结束" cmdType="S" cmd="[S]AT+CIPSEND"/>
          <Command cmdname="6、发送http请求" cmdType="T" cmd="[T]GET   /index.html \r\n\r\n\x1a"/>
          <Command cmdname="6、发送http请求" cmdType="T" cmd="[T]GET   /cgi-bin/qaweb.forte?inputXML=test.xml \r\n\r\n\x1a"/>
          <Command cmdname="7、关闭socket连接" cmdType="S" cmd="[S]AT+CIPSHUT "/>
        </Command>
        <Command cmdname="打电话" cmdType="S" cmd="[S]new command">
          <Command cmdname="call" cmdType="S" cmd="[S]ATD13305223456"/>
        </Command>
        <Command cmdname="短信" cmdType="S" cmd="[S]new command">
          <Command cmdname="设置端消息中心" cmdType="S" cmd="[S]AT+CSCA=&quot;+8613800551500&quot;"/>
          <Command cmdname="设置文本短信方式" cmdType="S" cmd="[S]at+cmgf=1"/>
          <Command cmdname="发短信" cmdType="S" cmd="[S]AT+CMGS=&quot;+8613901233442&quot;"/>
          <Command cmdname="所发短信内容" cmdType="T" cmd="[T]12345\x1a "/>
          <Command cmdname="读出短信" cmdType="S" cmd="[S]at+cmgl=&quot;all&quot;"/>
          <Command cmdname="发送数据,以0x1A结尾" cmdType="P" cmd="[P]SendString(GetString('请输入发送内容','Hello!'));SendByte(0x1a);"/>
        </Command>
        <Command cmdname="测试数据" cmdType="H" cmd="[H]3f 00 06 99 99 31 69"/>
        <Command cmdname="setIP" cmdType="P" cmd="[P]    local s;&#xA;    s=GetParam(&quot;ABC&quot;,&quot;IP&quot;);&#xA;    --PrintToCommWin(&quot;config ip is:&quot;..s);&#xA;    if s==&quot;&quot; then s=&quot;114.96.16.4&quot;;  end;&#xA;   --&#xA;   s=GetString(&quot;设置IP地址:&quot;, s);&#xA;   SaveParam(&quot;ABC&quot;,&quot;IP&quot;,s);&#xA;   --     s=&quot;10.20.30.40&quot;;&#xA;   val=inet_addr(s);&#xA;   data1= bit_shr(val,24);   data2= bit_shr(val,16);    data3= bit_shr(val,8);   data4= bit_shr(val,0);&#xA;&#xA;   s4=IntToStr(bit_and(data4,255)); len=#s4;  for i=1,3-len do s4=&quot;0&quot;..s4; end;&#xA;   s3=IntToStr(bit_and(data3,255)); len=#s3;  for i=1,3-len do s3=&quot;0&quot;..s3; end;&#xA;   s2=IntToStr(bit_and(data2,255)); len=#s2;  for i=1,3-len do s2=&quot;0&quot;..s2; end;&#xA;   s1=IntToStr(bit_and(data1,255)); len=#s1;  for i=1,3-len do s1=&quot;0&quot;..s1; end;&#xA;   s=&quot;IP&quot;..s4..s3..s2..s1;&#xA;&#xA;   PrintToCommWin(&quot;Input ip is:&quot;..s);&#xA;   SendString(s);"/>
        <Command cmdname="connect" cmdType="H" cmd="[H]01"/>
        <Command cmdname="setIP" cmdType="S" cmd="[S]IP114096022016"/>
        <Command cmdname="senddata" cmdType="H" cmd="[H]02"/>
        <Command cmdname="close socket" cmdType="H" cmd="[H]04"/>
      </Command>
      <Command cmdname="EM310" cmdType="P" cmd="[P]&#xA;void click(int node)&#xA;{&#xA;   char buf[20],buf1[20];&#xA;   PrintToCommWin(&quot;aaaaaaaaabc&quot;);&#xA;   GetTreeNodeValue(node,buf,20);&#xA;   GetTreeNodeCaption(node,buf1,20);&#xA;   printf(&quot;%s:%s&quot;,buf1,buf);&#xA;}&#xA;&#xA;void main()&#xA;{&#xA;   ClearTreeNode();&#xA;   int a=AddButtonTreeNode(0,&quot;串口命令&quot; ,0);&#xA;   int b=AddButtonTreeNode(0,&quot;网络命令&quot; ,0);&#xA;&#xA;   AddSpinTreeNode(a,&quot;1. 设串口号&quot; ,click,5,1,10); //name,event,value,min,max&#xA;   AddTextTreeNode(a,&quot;2. IP地址&quot; ,click,&quot;192.168.1.1&quot;);&#xA;   AddPickTreeNode(a,&quot;3. 设波特率&quot; ,click,&quot;9600&quot;,&quot;1200&quot;,&quot;2400&quot;,&quot;4800&quot;,&quot;9600&quot;,&quot;19200&quot;,0);&#xA;   AddCheckTreeNode(a,&quot;4. 设串口号&quot; ,click,1); //name,event,value,min,max&#xA;   AddButtonTreeNode(a,&quot;5. 发送地址&quot; ,click);&#xA;   AddButtonTreeNode(b,&quot;1. ping&quot; ,click);&#xA;}&#xA;">
        <Command cmdname="初始化" cmdType="S" cmd="[S]数据发送区">
          <Command cmdname="AT" cmdType="S" cmd="[S]AT"/>
          <Command cmdname="测试SIM 卡是否存在" cmdType="S" cmd="[S]AT%TSIM"/>
          <Command cmdname="SIM 卡在位和PIN1 码状态查询" cmdType="S" cmd="[S]AT+CPIN?"/>
          <Command cmdname="检查当地的网络信号强度，31最大，0最小" cmdType="S" cmd="[S]AT+CSQ"/>
          <Command cmdname="启用网络注册非请求结果码" cmdType="S" cmd="[S]AT+CREG=1"/>
          <Command cmdname="网络运营商注册查询" cmdType="S" cmd="[S]AT+COPS?"/>
          <Command cmdname="启用GPRS网络注册非请求结果码" cmdType="S" cmd="[S]AT+CGATT=1"/>
          <Command cmdname="设备厂商" cmdType="S" cmd="[S]AT+GMI"/>
          <Command cmdname="版本号查询" cmdType="S" cmd="[S]AT+CGMR"/>
          <Command cmdname="GSN" cmdType="S" cmd="[S]AT+GSN"/>
          <Command cmdname="查询模块当前的IMSI号" cmdType="S" cmd="[S]AT+CIMI"/>
        </Command>
        <Command cmdname="TCP/IP" cmdType="S" cmd="[S]new command">
          <Command cmdname="初始化_不缓冲" cmdType="S" cmd="[S]AT%IOMODE=1,1,1"/>
          <Command cmdname="注册移动的CMNET网关" cmdType="S" cmd="[S]AT+CGDCONT=1,&quot;IP&quot;,&quot;CMNET&quot;"/>
          <Command cmdname="注册用户名密码，并等分配IP" cmdType="S" cmd="[S]AT%ETCPIP=&quot;user&quot;,&quot;gprs&quot;"/>
          <Command cmdname="查询GPRS 初始化是否成功" cmdType="S" cmd="[S]AT%ETCPIP?"/>
          <Command cmdname="设置TCP、ip、port" cmdType="S" cmd="[S]AT%IPOPEN=&quot;TCP&quot;,&quot;61.144.176.175&quot;,3000"/>
          <Command cmdname="设置TCP、ip、port[1]" cmdType="S" cmd="[S]AT%IPOPEN=&quot;TCP&quot;,&quot;220.248.243.211&quot;,6666"/>
          <Command cmdname="发送数据12345AB" cmdType="S" cmd="[S]AT%IPSEND=&quot;31323334354142&quot;"/>
          <Command cmdname="读取数据" cmdType="S" cmd="[S]AT%IPDR"/>
          <Command cmdname="关闭" cmdType="S" cmd="[S]AT%IPCLOSE=1"/>
          <Command cmdname="模块从GPRS 网络注销" cmdType="S" cmd="[S]AT%IPCLOSE=5"/>
        </Command>
      </Command>
    </Command>
    <Command cmdname="ARM开发板命令" cmdType="S" cmd="[S]new command">
      <Command cmdname="Mini2440" cmdType="S" cmd="[S]ERROR">
        <Command cmdname="Set parameter " cmdType="S" cmd="[S]new command">
          <Command cmdname="mach_type" cmdType="S" cmd="[S]mach_type"/>
          <Command cmdname="media_type" cmdType="S" cmd="[S]media_type"/>
          <Command cmdname="boot_mem_base" cmdType="S" cmd="[S]boot_mem_base"/>
          <Command cmdname="baudrate" cmdType="S" cmd="[S]baudrate"/>
          <Command cmdname="xmodem" cmdType="S" cmd="[S]xmodem"/>
          <Command cmdname="xmodem_one_nak" cmdType="S" cmd="[S]xmodem_one_nak"/>
          <Command cmdname="xmodem_initial_timeout" cmdType="S" cmd="[S]xmodem_initial_timeout"/>
          <Command cmdname="xmodem_timeout " cmdType="S" cmd="[S]xmodem_timeout "/>
          <Command cmdname="boot_delay " cmdType="S" cmd="[S]boot_delay"/>
          <Command cmdname="Linux command line" cmdType="S" cmd="[S]Linux command line"/>
        </Command>
        <Command cmdname="parameter value" cmdType="S" cmd="[S]new command">
          <Command cmdname="MACH_TYPE [782]" cmdType="S" cmd="[S]782"/>
          <Command cmdname="Linux command line" cmdType="S" cmd="[S]&quot;noinitrd root=/dev/mtdblock2 init=/linuxrc console=ttySAC1,115200&quot;"/>
        </Command>
        <Command cmdname="通过串口终端操作开发板" cmdType="S" cmd="[S]new command">
          <Command cmdname="2.5.1 播放mp3" cmdType="S" cmd="[S]madplay your.mp3"/>
          <Command cmdname="2.5.2 如何中止程序的运行" cmdType="H" cmd="[H]03"/>
          <Command cmdname="2.5.5 如何通过串口与PC 互相传送文件" cmdType="P" cmd="[P]void main()&#xA;{&#xA;  //char ss[]=&quot;请使用本工具右侧工具栏的【ZModem接收】与【ZModem发送】来测试本命令&quot;;&#xA;  //ShowMessage(ss);&#xA;  ShowMessage(&quot;请使用本工具右侧工具栏的【ZModem接收】与【ZModem发送】来测试本命令&quot;);&#xA;}&#xA;"/>
          <Command cmdname="2.5.6 控制板上的LED" cmdType="S" cmd="[S]new command">
            <Command cmdname="4 个用户led 将会以每个间隔0.2 秒的时间运行跑马灯" cmdType="S" cmd="[S]echo 0 0.2 &gt; /tmp/led-control"/>
            <Command cmdname="4 个用户led 将会以间隔0.2 秒的时间运行累加器" cmdType="S" cmd="[S]echo 1 0.2 &gt;/tmp/led-control"/>
            <Command cmdname="4 个用户led 将会停止闪动" cmdType="S" cmd="[S]etc/rc.d/init.d/leds stop"/>
            <Command cmdname="4 个用户led 将会重新开始闪动" cmdType="S" cmd="[S]etc/rc.d/init.d/leds start"/>
          </Command>
          <Command cmdname="2.5.7 测试板上的按键" cmdType="S" cmd="[S]buttons"/>
          <Command cmdname="2.5.8 串口2 和3 的测试" cmdType="S" cmd="[S]armcomtest Cd /dev/ttySAC0 -o"/>
          <Command cmdname="2.5.9 测试蜂鸣器" cmdType="S" cmd="[S]pwm_test"/>
          <Command cmdname="2.5.10 控制LCD 的背光" cmdType="S" cmd="[S]new command">
            <Command cmdname="关闭LCD 背光" cmdType="S" cmd="[S]echo 0 &gt; /dev/backlight"/>
            <Command cmdname="打开LCD 背光" cmdType="S" cmd="[S]echo 1 &gt; /dev/backlight"/>
          </Command>
          <Command cmdname="2.5.11 测试I2C－EEPROM" cmdType="S" cmd="[S]i2c Cw"/>
          <Command cmdname="2.5.13 如何设置网络以访问互联网网址" cmdType="S" cmd="[S]route add default gw 192.168.1.1"/>
          <Command cmdname="2.5.14 如何设置MAC 地址" cmdType="S" cmd="[S]ifconfig&#xA;ifconfig eth0 down&#xA;ifconfig eth0 hw ether 00:11:AA:BB:CC:DD&#xA;ifconfig eth0 up&#xA;ifconfig&#xA;ping 192.168.1.1"/>
          <Command cmdname="2.5.15 如何使用Telnet 远程登录开发板" cmdType="P" cmd="[P]main()&#xA;{&#xA;   char s[200]=&quot;请先使用本工具的【控制菜单】-&gt;【新建窗口】命令来新建一个窗口，\r\n&quot;;&#xA;   char *s1=&quot;然后使用本工具的【控制菜单】-&gt;【通讯类型】-&gt;【Telnet客户端】 命令进行Telnet测试！&quot;;&#xA;   strcat(s,s1);&#xA;   ShowMessage(s);&#xA;}"/>
          <Command cmdname="2.5.17 通过网页控制板上的LED" cmdType="S" cmd="[S]new command">
            <Command cmdname="要停止 web 服务器" cmdType="S" cmd="[S]etc/rc.d/init.d/httpd stop"/>
            <Command cmdname="重新启动" cmdType="S" cmd="[S]etc/rc.d/init.d/httpd start"/>
          </Command>
          <Command cmdname="2.5.18 如何挂接使用网络文件系统NFS" cmdType="S" cmd="[S]new command">
            <Command cmdname="挂接" cmdType="S" cmd="[S]mount Ct nfs Co nolock 192.168.1.111:/opt/FriendlyARM/mini2440/root_nfs /mnt"/>
            <Command cmdname="取消挂接" cmdType="S" cmd="[S]umount /mnt"/>
          </Command>
          <Command cmdname="2.5.19 设置并保存系统实时时钟" cmdType="S" cmd="[S]new command">
            <Command cmdname="设置时间为 2007-04-29 16:34" cmdType="S" cmd="[S]date -s 042916352007"/>
            <Command cmdname="把刚刚设置的时间存入S3C2440 内部的RTC" cmdType="S" cmd="[S]hwclock -w"/>
            <Command cmdname="恢复 linux 系统时钟为RTC" cmdType="S" cmd="[S]hwclock -s"/>
          </Command>
        </Command>
        <Command cmdname="5.5.3 通过NFS 启动系统" cmdType="S" cmd="[S]param set linux_cmd_line &quot;console=ttySAC0 root=/dev/nfs nfsroot=192.168.1.111:/opt/FriendlyARM/mini2440/root_qtopia ip=192.168.1.70:192.168.1.111:192.168.1.111:255.255.255.0:sbc2440.arm9.net:eth0:off&quot;"/>
      </Command>
      <Command cmdname="VIVI-TE2410" cmdType="S" cmd="[S]none">
        <Command cmdname="分区操作" cmdType="S" cmd="[S]none">
          <Command cmdname="显示分区" cmdType="S" cmd="[S]part show"/>
          <Command cmdname="添加jffs2分区" cmdType="S" cmd="[S]part add mypart 0x500000 0x100000 JFFS2"/>
          <Command cmdname="添加分区" cmdType="P" cmd="[P]name=GetString(&quot;分区名称&quot;,&quot;usr&quot;);&#xA;offset=GetString(&quot;起始地址&quot;,&quot;0x00600000&quot;);&#xA;size=GetString(&quot;分区大小&quot;,&quot;0x03a00000&quot;);&#xA;flag=GetString(&quot;分区类型&quot;,&quot;0&quot;);&#xA;cmd=&quot;part add &quot;..name..&quot; &quot;..offset..&quot; &quot;..size..&quot; &quot;..flag; &#xA;SendString(cmd);                                                    "/>
          <Command cmdname="删除分区" cmdType="P" cmd="[P]name=GetString('分区名称','usr');&#xA;cmd='part del '..name;&#xA;SendString(cmd);                                                  "/>
          <Command cmdname="擦除分区" cmdType="P" cmd="[P]name=GetString('分区名称','usr');&#xA;cmd='part erase '..name;&#xA;SendString(cmd);&#xA;"/>
          <Command cmdname="恢复分区表" cmdType="P" cmd="[P]SendString('part reset');   "/>
          <Command cmdname="保存分区" cmdType="P" cmd="[P]SendString('part save');   "/>
        </Command>
        <Command cmdname="文件操作" cmdType="S" cmd="[S]none">
          <Command cmdname="load flash" cmdType="S" cmd="[S]load flash kernel t"/>
          <Command cmdname="load flash" cmdType="S" cmd="[S]load ram 0X30008000 t"/>
          <Command cmdname="boot" cmdType="S" cmd="[S]boot ram"/>
        </Command>
        <Command cmdname="参数操作" cmdType="S" cmd="[S]none">
          <Command cmdname="help" cmdType="S" cmd="[S]param help"/>
          <Command cmdname="show" cmdType="S" cmd="[S]param show"/>
          <Command cmdname="reset" cmdType="S" cmd="[S]param reset"/>
          <Command cmdname="save" cmdType="S" cmd="[S]param save"/>
          <Command cmdname="设置参数" cmdType="P" cmd="[P]name=GetString('参数名称','ip');&#xA;val=GetString('值','192.168.0.253');&#xA;cmd='param set '..name..' '..val;&#xA;SendString(cmd);  "/>
          <Command cmdname="set ip" cmdType="S" cmd="[S]param set ip 192.168.0.253"/>
          <Command cmdname="set mac" cmdType="S" cmd="[S]param set mac 00:01:02:03:04:05"/>
          <Command cmdname="linux_cmd_line" cmdType="S" cmd="[S]param set linux_cmd_line noinitrd root=/dev/mtdblock/3 init=/linuxrc console=ttyS0"/>
          <Command cmdname="wince_part_name" cmdType="S" cmd="[S]param set wince_part_name wince"/>
        </Command>
      </Command>
      <Command cmdname="DevKit8000 OMAP3530" cmdType="S" cmd="[S]none">
        <Command cmdname="4.3&quot;LCD" cmdType="S" cmd="[S]none">
          <Command cmdname="NandFlash" cmdType="S" cmd="[S]none">
            <Command cmdname="bootargs" cmdType="S" cmd="[S]setenv bootargs console=ttyS2,115200n8 ubi.mtd=4 root=ubi0:rootfs rootfstype=ubifs video=omapfb:mode:4.3inch_LCD"/>
            <Command cmdname="bootcmd" cmdType="S" cmd="[S]setenv bootcmd nand read.i 80300000 280000 200000\;bootm 80300000"/>
            <Command cmdname="saveenv" cmdType="S" cmd="[S]saveenv"/>
          </Command>
          <Command cmdname="SD Card" cmdType="S" cmd="[S]none">
            <Command cmdname="bootargs" cmdType="S" cmd="[S]setenv bootargs console=ttyS2,115200n8 root=/dev/ram initrd=0x81600000,40M video=omapfb:mode:4.3inch_LCD"/>
            <Command cmdname="bootcmd" cmdType="S" cmd="[S]setenv bootcmd 'mmcinit;fatload mmc 0 80300000 uImage;fatload mmc 0 81600000 ramdisk.gz;bootm 80300000'"/>
            <Command cmdname="saveenv" cmdType="S" cmd="[S]saveenv "/>
          </Command>
        </Command>
        <Command cmdname="7&quot;LCD" cmdType="S" cmd="[S]none&#xA;">
          <Command cmdname="NandFlash" cmdType="S" cmd="[S]none">
            <Command cmdname="bootargs" cmdType="S" cmd="[S]setenv bootargs console=ttyS2,115200n8 ubi.mtd=4 root=ubi0:rootfs rootfstype=ubifs video=omapfb:mode:7inch_LCD"/>
            <Command cmdname="bootcmd" cmdType="S" cmd="[S]setenv bootcmd nand read.i 80300000 280000 200000\;bootm 80300000"/>
            <Command cmdname="saveenv" cmdType="S" cmd="[S]saveenv"/>
          </Command>
          <Command cmdname="SD Card" cmdType="S" cmd="[S]none">
            <Command cmdname="bootargs" cmdType="S" cmd="[S]setenv bootargs console=ttyS2,115200n8 root=/dev/ram initrd=0x81600000,40M video=omapfb:mode:7inch_LCD"/>
            <Command cmdname="bootcmd" cmdType="S" cmd="[S]setenv bootcmd 'mmcinit;fatload mmc 0 80300000 uImage;fatload mmc 0 81600000 ramdisk.gz;bootm 80300000'"/>
            <Command cmdname="saveenv" cmdType="S" cmd="[S]saveenv "/>
          </Command>
        </Command>
        <Command cmdname="DVI" cmdType="S" cmd="[S]none&#xA;">
          <Command cmdname="NandFlash" cmdType="S" cmd="[S]none">
            <Command cmdname="bootargs" cmdType="S" cmd="[S]setenv bootargs console=ttyS2,115200n8 ubi.mtd=4 root=ubi0:rootfs rootfstype=ubifs video=omapfb:mode:720p60"/>
            <Command cmdname="bootcmd" cmdType="S" cmd="[S]setenv bootcmd nand read.i 80300000 280000 200000\;bootm 80300000"/>
            <Command cmdname="saveenv" cmdType="S" cmd="[S]saveenv"/>
          </Command>
          <Command cmdname="SD Card" cmdType="S" cmd="[S]none">
            <Command cmdname="bootargs" cmdType="S" cmd="[S]setenv bootargs console=ttyS2,115200n8 root=/dev/ram initrd=0x81600000,40M video=omapfb:mode:720p60"/>
            <Command cmdname="bootcmd" cmdType="S" cmd="[S]setenv bootcmd 'mmcinit;fatload mmc 0 80300000 uImage;fatload mmc 0 81600000 ramdisk.gz;bootm 80300000'"/>
            <Command cmdname="saveenv" cmdType="S" cmd="[S]saveenv "/>
          </Command>
        </Command>
        <Command cmdname="测试程序" cmdType="S" cmd="[S]none">
          <Command cmdname="点亮led3" cmdType="S" cmd="[S]echo -n 1 &gt;/sys/class/leds/led3/brightness"/>
          <Command cmdname="熄灭led3" cmdType="S" cmd="[S]echo -n 0 &gt;/sys/class/leds/led3/brightness"/>
          <Command cmdname="KEYPAD 测试" cmdType="S" cmd="[S]evtest /dev/input/event0"/>
          <Command cmdname="触摸屏校正" cmdType="S" cmd="[S]ts_calibrate"/>
          <Command cmdname="触摸屏测试" cmdType="S" cmd="[S]ts_test"/>
          <Command cmdname="RTC 测试" cmdType="S" cmd="[S] date 080820002008"/>
          <Command cmdname="系统时钟写入RTC" cmdType="S" cmd="[S] hwclock Cw"/>
          <Command cmdname="读取RTC" cmdType="S" cmd="[S]  hwclock"/>
        </Command>
        <Command cmdname="Angstrom(GPE)桌面发布版本演示" cmdType="S" cmd="[S]none">
          <Command cmdname="make sd card" cmdType="S" cmd="[S]none">
            <Command cmdname="cp" cmdType="S" cmd="[S]cp /media/cdrom/linux/demo/angstrom/MLO /media/LABEL1"/>
            <Command cmdname="cp" cmdType="S" cmd="[S]cp /media/cdrom/linux/demo/angstrom/u-boot.bin /media/LABEL1"/>
            <Command cmdname="cp" cmdType="S" cmd="[S]cp /media/cdrom/linux/demo/angstrom/uImage /media/LABEL1"/>
            <Command cmdname="rm" cmdType="S" cmd="[S]rm Crf /media/LABEL2/*"/>
            <Command cmdname="tar" cmdType="S" cmd="[S]sudo tar jxvf linux/demo/angstrom/Angstrom-DevKit8000-demo-image-glibc-ipk-2008.1-test-2 0080111-DevKit8000.rootfs.tar.bz2 CC /media/LABEL2"/>
            <Command cmdname="sync" cmdType="S" cmd="[S]sync"/>
            <Command cmdname="umount" cmdType="S" cmd="[S]umount /media/LABEL1"/>
            <Command cmdname="umount" cmdType="S" cmd="[S]umount /media/LABEL2"/>
          </Command>
          <Command cmdname="4.3&quot;lcd" cmdType="S" cmd="[S]none">
            <Command cmdname="set bootargs" cmdType="S" cmd="[S]set bootargs mem=128M console=ttyS2,115200n8 root=/dev/mmcblk0p2 rw noinitrd rootdelay=1"/>
            <Command cmdname="mmcinit" cmdType="S" cmd="[S] mmcinit"/>
            <Command cmdname="fatload" cmdType="S" cmd="[S] fatload mmc 0 80300000 uimage"/>
            <Command cmdname="bootm" cmdType="S" cmd="[S] bootm 80300000"/>
          </Command>
          <Command cmdname="7&quot;lcd" cmdType="S" cmd="[S]none">
            <Command cmdname="set bootargs" cmdType="S" cmd="[S]  set bootargs mem=128M console=ttyS2,115200n8 root=/dev/mmcblk0p2 rw noinitrd rootdelay=1 video=omapfb:mode:7inch_LCD"/>
            <Command cmdname="mmcinit" cmdType="S" cmd="[S] mmcinit"/>
            <Command cmdname="fatload" cmdType="S" cmd="[S] fatload mmc 0 80300000 uimage"/>
            <Command cmdname="bootm" cmdType="S" cmd="[S] bootm 80300000"/>
          </Command>
          <Command cmdname="DVI" cmdType="S" cmd="[S]none">
            <Command cmdname="set bootargs" cmdType="S" cmd="[S]set bootargs mem=128M console=ttyS2,115200n8 root=/dev/mmcblk0p2 rw noinitrd rootdelay=1 video=omapfb:mode:720p60"/>
            <Command cmdname="mmcinit" cmdType="S" cmd="[S] mmcinit"/>
            <Command cmdname="fatload" cmdType="S" cmd="[S] fatload mmc 0 80300000 uimage"/>
            <Command cmdname="bootm" cmdType="S" cmd="[S] bootm 80300000"/>
          </Command>
        </Command>
      </Command>
      <Command cmdname="UBOOT" cmdType="S" cmd="[S]none">
        <Command cmdname="打印环境变量" cmdType="S" cmd="[S]printenv"/>
        <Command cmdname="设置新的变量" cmdType="S" cmd="[S]setenv myboard AT91RM9200DK"/>
        <Command cmdname="设置MAC地址" cmdType="S" cmd="[S]setenv ethaddr 12:34:56:78:9A:BC"/>
        <Command cmdname="设置IP地址" cmdType="S" cmd="[S]setenv serverip 192.168.1.254"/>
        <Command cmdname="设置服务器IP地址" cmdType="S" cmd="[S]setenv ipaddr 192.168.1.1"/>
        <Command cmdname="设置服务器IP地址" cmdType="S" cmd="[S]tftp 20000000 application.bin"/>
      </Command>
    </Command>
    <Command cmdname="UsbGadget_udisk" cmdType="S" cmd="[S]new command">
      <Command cmdname="insmod s3c2410_udc.ko" cmdType="S" cmd="[S]insmod s3c2410_udc.ko"/>
      <Command cmdname="insmod g_file_storage.ko" cmdType="S" cmd="[S]insmod g_file_storage.ko file=/dev/mmcblk0p1 stall=0 removable=1"/>
      <Command cmdname="insmod g_file_storage.ko1" cmdType="S" cmd="[S]insmod g_file_storage.ko file=/dev/sdcard stall=0 removable=1"/>
      <Command cmdname="mount sd" cmdType="S" cmd="[S]cd /&#xA;umount sd&#xA;mount /dev/mmcblk0p1 /sd&#xA;cd /sd"/>
      <Command cmdname="umount sd" cmdType="S" cmd="[S]cd /&#xA;umount /sd"/>
      <Command cmdname="./testapp" cmdType="S" cmd="[S]./testapp"/>
      <Command cmdname="re mount &amp; run" cmdType="S" cmd="[S]cd /&#xA;umount /sd&#xA;mount /dev/mmcblk0p1 /sd&#xA;cd /sd&#xA;./testapp"/>
      <Command cmdname="test data" cmdType="H" cmd="[H]F1  F2  06  F9  00  00  30  00  AA  BB  95"/>
      <Command cmdname="remount &amp; Run1" cmdType="S" cmd="[S]umount /sdcard&#xA;mount /dev/sdcard /sdcard&#xA;/sdcard/testapp"/>
      <Command cmdname="==========" cmdType="S" cmd="[S]数据发送区"/>
      <Command cmdname="umount" cmdType="S" cmd="[S]umount /sdcard"/>
      <Command cmdname="mount" cmdType="S" cmd="[S] mount /dev/sdcard /sdcard"/>
      <Command cmdname="run" cmdType="S" cmd="[S]/sdcard/testapp"/>
      <Command cmdname="Auto" cmdType="P" cmd="[P]void main()&#xA;{&#xA;    SendByte(0x03); // --Ctrl+C&#xA;    Wait(20);&#xA;    SendString(&quot;umount /sdcard\r\n&quot;);&#xA;    Wait(1000);&#xA;    SendString(&quot;mount /dev/sdcard /sdcard\r\n&quot;);&#xA;    Wait(1000);&#xA;    SendString(&quot;/sdcard/testapp\r\n&quot;);&#xA;}"/>
      <Command cmdname="^C" cmdType="H" cmd="[H]03"/>
    </Command>
  </Command>
  <Command cmdname="例子命令" cmdType="S" cmd="[S]none">
    <Command cmdname="基本命令" cmdType="S" cmd="[S]new command">
      <Command cmdname="字符串命令" cmdType="S" cmd="[S]12345 -&quot;abcd&quot;&#xA;56789\&#xA;llll"/>
      <Command cmdname="十六进制命令" cmdType="H" cmd="[H]0001020304aabbccdd"/>
      <Command cmdname="转义命令" cmdType="T" cmd="[T]abc\x34\123\r\xyzabcdef"/>
      <Command cmdname="脚本命令0" cmdType="P" cmd="[P]main()&#xA;{&#xA;   PrintfToCommWin(&quot;12345:%08d,%02x&quot;,666,0x83);&#xA;}"/>
      <Command cmdname="脚本命令2" cmdType="P" cmd="[P]void main()&#xA;{&#xA;    int i;&#xA;    PrintToCommWin(&quot;下面发送100个字节:&quot;);&#xA;    for(i=1; i&lt;=100; i++)&#xA;        SendByte(i);&#xA;}"/>
    </Command>
    <Command cmdname="控件示例" cmdType="S" cmd="[S]new command">
      <Command cmdname="扩展树节点" cmdType="P" cmd="[P]int c;&#xA;void NodeClick(int node)&#xA;{&#xA;    char buf[20],buf1[20],buf2[40];&#xA;    GetTreeNodeValue(node,buf,20);&#xA;    GetTreeNodeCaption(node,buf1,20);&#xA;    sprintf(buf2,&quot;%s:%s&quot;,buf1,buf);&#xA;    printf(&quot;%s&quot;,buf2);&#xA;    PrintToCommWin(buf2);&#xA;}&#xA;void NodeClick1(int node)&#xA;{&#xA;    char buf[20],buf1[20],buf2[40];&#xA;    GetTreeNodeValue(node,buf,20);&#xA;    sprintf(buf2,&quot;设置的串口波特率为:%s&quot;,buf);&#xA;    printf(&quot;%s&quot;,buf2);&#xA;    PrintToCommWin(buf2);&#xA;    ShowMessage(buf2);&#xA;}&#xA;&#xA;void TreeNodeDbClick(int node)&#xA;{&#xA;    if(node==c)&#xA;        NodeClick1(node);&#xA;    else&#xA;        NodeClick(node);&#xA;}&#xA;&#xA;void main()&#xA;{&#xA;&#xA;    ClearTreeNode();&#xA;    int a=AddButtonTreeNode(0,&quot;串口命令&quot; ,0);&#xA;    int b=AddButtonTreeNode(0,&quot;网络命令&quot; ,0);&#xA;&#xA;&#xA;    AddSpinTreeNode(a,&quot;1. 设串口号&quot; ,5,1,10); //name,event,value,min,max&#xA;    c=AddTextTreeNode(a,&quot;2. IP地址&quot; ,&quot;192.168.1.1&quot;);&#xA;    SetTreeNodeBkColor(c,0xffff00);&#xA;&#xA;    //SetTreeNodeCaption(c,&quot;1. ip address&quot;);&#xA;    SetTreeNodeValue(c,&quot;3&quot;);&#xA;&#xA;&#xA;    c=AddPickTreeNode(a,&quot;3. 设波特率&quot; ,&quot;9600&quot;,&quot;1200&quot;,&quot;2400&quot;,&quot;4800&quot;,&quot;9600&quot;,&quot;19200&quot;,0);&#xA;    SetTreeNodeValue(c,&quot;1200&quot;);&#xA;    SetTreeNodeBkColor(c,0x0000ff);&#xA;    int d=AddCheckTreeNode(a,&quot;4. 设串口号&quot; ,1);&#xA;    SetTreeNodeValue(d,&quot;False&quot;);&#xA;    c=AddButtonTreeNode(a,&quot;5. 发送地址(双击发送)&quot; );&#xA;    SetTreeNodeBkColor(d,0x00ff00);&#xA;&#xA;    AddButtonTreeNode(b,&quot;1. ping&quot; );&#xA;    AddButtonTreeNode(b,&quot;2. ping2&quot; );&#xA;    AddButtonTreeNode(b,&quot;3. ping3&quot; );&#xA;&#xA;    ShowLeftToolPage(1);&#xA;    ExplandAllTreeNode();&#xA;}&#xA;"/>
      <Command cmdname="控件示例" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;void click(int btn)&#xA;{&#xA;    char s[20];&#xA;    printf(&quot;clicked&quot;);&#xA;    //SetProperty(btn,&quot;enabled&quot;,&quot;false&quot;);&#xA;    GetProperty(btn,&quot;caption&quot;,s,20);&#xA;    printf(&quot;button caption is '%s'&quot;,s);&#xA;};&#xA;void click1(int btn)&#xA;{&#xA;    char s[20];&#xA;    printf(&quot;clicked&quot;);&#xA;    //SetProperty(btn,&quot;enabled&quot;,&quot;false&quot;);&#xA;    GetProperty(btn,&quot;text&quot;,s,20);&#xA;    printf(&quot;edit text is '%s'&quot;,s);&#xA;};&#xA;&#xA;void main()&#xA;{&#xA;    int i;&#xA;    int btn;&#xA;    int node;&#xA;    char s[100];&#xA;&#xA;    ClearVclControls();&#xA;    ShowVclWin(150);&#xA;    ShowOutputWin(300);&#xA;    int p=GetGuiWin();&#xA;    for(  i=0; i&lt;3; i++)&#xA;    {&#xA;        sprintf(s,&quot;按钮:%d&quot;,i);&#xA;        btn=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,s,0);&#xA;        SetProperty(btn,&quot;left&quot;,10+i*70);&#xA;        SetPropertyList(btn,&quot;top&quot;,30,&quot;width&quot;,65,&quot;onclick&quot;,click,NULL);//创建按钮&#xA;    }&#xA;    for(  i=0; i&lt;3; i++)&#xA;    {&#xA;        sprintf(s,&quot;Text:%d&quot;,i);&#xA;        btn=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,s,0);&#xA;        SetProperty(btn,&quot;left&quot;,10+i*70);&#xA;        SetPropertyList(btn,&quot;top&quot;,60,&quot;width&quot;,65,&quot;onclick&quot;,click1,NULL);//创建按钮&#xA;    }&#xA;    for(  i=0; i&lt;3; i++)&#xA;    {&#xA;        sprintf(s,&quot;check:%d&quot;,i);&#xA;        btn=CreateComponentEx(p,&quot;checkbox&quot;,&quot;caption&quot;,s,0);&#xA;        SetProperty(btn,&quot;left&quot;,10+i*70);&#xA;        SetPropertyList(btn,&quot;top&quot;,90,&quot;width&quot;,65,&quot;onclick&quot;,click,NULL);//创建按钮&#xA;    }&#xA;&#xA;};&#xA;"/>
      <Command cmdname="KS8995MA" cmdType="P" cmd="[P]#include&quot;windows.h&quot;&#xA;int rootNode;&#xA;unsigned char Data[200];&#xA;unsigned char skip=1;&#xA;void ReadDataFromFile(unsigned char *filename)&#xA;{&#xA;    char s[100];&#xA;    HANDLE Handle=CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);&#xA;    printf(&quot;读取文件名称：%s&quot;,filename);&#xA;    if(Handle&lt;=0)&#xA;    {&#xA;        sprintf(s,&quot;打开文件【%s】错误！&quot;,s);&#xA;        ShowMessage(s);//&quot;打开文件【&quot;..pb.edit1.text..&quot;】错误！&quot;);&#xA;        return  ;&#xA;    }&#xA;    int BytesRead ;&#xA;    ReadFile(Handle, Data,128,&amp;BytesRead,NULL);&#xA;    CloseHandle(Handle);&#xA;}&#xA;void WriteDataToFile(unsigned char *filename)&#xA;{&#xA;    char s[100];&#xA;    HANDLE Handle=CreateFile(filename, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);&#xA;    printf(&quot;保存文件名称：%s&quot;,filename);&#xA;    if(Handle&lt;=0)&#xA;    {&#xA;        sprintf(s,&quot;打开文件【%s】错误！&quot;,s);&#xA;        ShowMessage(s);//&quot;打开文件【&quot;..pb.edit1.text..&quot;】错误！&quot;);&#xA;        return  ;&#xA;    }&#xA;&#xA;    int BytesWrite ;&#xA;    WriteFile(Handle, Data,128,&amp;BytesWrite,NULL);&#xA;    CloseHandle(Handle);&#xA;}&#xA;&#xA;int GetRegisterIdx(int node)&#xA;{&#xA;    char buf[50],buf1[20];&#xA;    int i,j,k,idx;&#xA;    GetTreeNodeCaption(node,buf,50);&#xA;    j=0;&#xA;    if(buf[0]!='(') return -1;&#xA;    for(i=1; i&lt;50; i++)&#xA;        if( ((buf[i]&gt;='0')&amp;&amp;(buf[i]&lt;='9')) ||&#xA;                ((buf[i]=='x')||(buf[i]=='X')) ||&#xA;                ((buf[i]&gt;='a')&amp;&amp;(buf[i]=='f')) ||&#xA;                ((buf[i]&gt;='A')&amp;&amp;(buf[i]=='F')) )&#xA;        {&#xA;            buf1[j++]=buf[i];&#xA;        }&#xA;        else if(buf[i]==')')&#xA;        {&#xA;            if(j==0) return -1;&#xA;            buf1[j++]=0;&#xA;            idx=HexStrToInt(buf1);&#xA;            return idx;&#xA;        }&#xA;        else return -1;&#xA;}&#xA;&#xA;int GetRegistBits(int node,int *start,int *len)&#xA;{&#xA;    char buf[50],buf1[20];&#xA;    int i,j,k,idx;&#xA;    *start=-1;&#xA;    j=0;&#xA;    GetTreeNodeCaption(node,buf,50);&#xA;    for(i=0; i&lt;50; i++)&#xA;        if((buf[i]&gt;='0')&amp;&amp;(buf[i]&lt;='9'))&#xA;        {&#xA;            buf1[j++]=buf[i];&#xA;        }&#xA;        else if(buf[i]=='-')&#xA;        {&#xA;            if(j==0) return -1;&#xA;            if(*start!=-1) return -1;&#xA;            idx=0;&#xA;            for(k=0; k&lt;j; k++)&#xA;                idx=idx*10+buf1[k]-'0';&#xA;            *start=idx;&#xA;            j=0;&#xA;        }&#xA;        else if(buf[i]==' ')&#xA;        {&#xA;            if(j==0) return -1;&#xA;            idx=0;&#xA;            for(k=0; k&lt;j; k++)&#xA;                idx=idx*10+buf1[k]-'0';&#xA;            if(*start==-1)&#xA;            {&#xA;                *start=idx;&#xA;                *len=1;&#xA;                return len;&#xA;            }&#xA;            else&#xA;            {&#xA;                if(idx&gt;*start) return -1;&#xA;&#xA;                k=*start;&#xA;                *start=idx;&#xA;                idx=k;//swap&#xA;                *len=idx-*start+1;&#xA;                return len;&#xA;            }&#xA;        }&#xA;        else return -1;&#xA;}&#xA;&#xA;unsigned int BinStrToInt(char *str)&#xA;{&#xA;    int i,j,k;&#xA;    unsigned int val=0;&#xA;    for(i=0; i&lt;10; i++)&#xA;        if(str[i]=='0')&#xA;            val=val&lt;&lt;1;&#xA;        else if(str[i]=='1')&#xA;            val=(val&lt;&lt;1)|1;&#xA;        else return val;&#xA;    return val;&#xA;}&#xA;&#xA;void NodeProc(int node,int ReadOrWrite,int loop)&#xA;{&#xA;    char buf[50],buf1[50];&#xA;    int idx,i;&#xA;    int start,len;&#xA;    unsigned char bits,val;&#xA;    unsigned char mask;&#xA;    int nd=node;&#xA;    int value=0x85;&#xA;    int set=ReadOrWrite;&#xA;    if(node==0) return;&#xA;    do&#xA;    {&#xA;        idx=GetRegisterIdx(nd); // printf(&quot;idx:%d&quot;,idx);&#xA;        if(idx&gt;=0)&#xA;        {&#xA;            if(set)&#xA;            {&#xA;                sprintf(buf,&quot;%02X&quot;,Data[idx]);//;&#xA;                SetTreeNodeValue(nd,buf);// set value&#xA;            }&#xA;            int child=GetFirstChild(nd);&#xA;            int start,len;&#xA;            while(child!=0)&#xA;            {&#xA;                if(GetRegistBits(child,&amp;start,&amp;len)&gt;=0)&#xA;                {&#xA;                    //sprintf(buf,&quot;(%d-%d) &quot;,start,start+len-1);PrintToCommWin(buf);&#xA;                    GetTreeNodeValue(child,buf,20);&#xA;                    bits=BinStrToInt(buf);  //sprintf(buf1,&quot;%d &quot;, bits);PrintToCommWin(buf1);&#xA;                    mask=0xff&gt;&gt;start;&#xA;                    mask=mask&lt;&lt;start;&#xA;                    mask=mask&lt;&lt;(7-(start+len-1));&#xA;                    mask=mask&gt;&gt;(7-(start+len-1));&#xA;&#xA;                    if(set)&#xA;                    {&#xA;                        bits=Data[idx]&amp;mask;&#xA;                        bits&gt;&gt;=start;&#xA;                        for(i=0; i&lt;len; i++)&#xA;                            if(bits&amp;(1&lt;&lt;i))buf[len-i-1]='1';&#xA;                            else buf[len-i-1]='0';&#xA;                        buf[len]=0;&#xA;                        SetTreeNodeValue(child,buf);&#xA;                    }&#xA;                    else&#xA;                    {&#xA;                        bits&lt;&lt;=start;&#xA;                        GetTreeNodeValue(nd,buf,20);&#xA;                        val=HexStrToInt(buf);&#xA;                        val=val&amp;(~mask);&#xA;                        val=val|(bits&amp;mask);&#xA;                        sprintf(buf,&quot;%02X&quot;,val);//PrintToCommWin(buf);&#xA;                        SetTreeNodeValue(nd,buf);&#xA;                    }&#xA;                }&#xA;                child=GetNextSibing(child);&#xA;            }&#xA;            if(!set)&#xA;            {&#xA;                GetTreeNodeValue(nd,buf,20);&#xA;                val=HexStrToInt(buf);&#xA;                Data[idx]=val;&#xA;                SetHexEditorDat(idx,val);&#xA;                SetHexEditorSelection(idx,1);&#xA;            }&#xA;        }&#xA;        nd=GetNextSibing(nd);&#xA;    }&#xA;    while((nd!=0)&amp;&amp;(loop));&#xA;&#xA;}&#xA;void NodeProcAll(int rdwr)&#xA;{&#xA;    int child;&#xA;    char buf[20],buf1[200];&#xA;    int nd=rootNode;&#xA;&#xA;    while(nd!=0)&#xA;    {&#xA;        NodeProc(GetFirstChild(nd),rdwr,1);&#xA;        nd=GetNextSibing(nd);&#xA;    }&#xA;&#xA;    nd=rootNode;&#xA;    while(nd!=0)&#xA;    {&#xA;        buf1[0]=0;&#xA;        child=GetFirstChild(nd);&#xA;        while(child!=0)&#xA;        {&#xA;            GetTreeNodeValue(child,buf,20);&#xA;            if(buf1[0]!=0)&#xA;                sprintf(buf1,&quot;%s,%s&quot;,buf1,buf);&#xA;            else&#xA;                sprintf(buf1,&quot;%s&quot;,buf);&#xA;&#xA;            child=GetNextSibing(child);&#xA;        }&#xA;        SetTreeNodeValue(nd,buf1);&#xA;        nd=GetNextSibing(nd);&#xA;    }&#xA;}&#xA;&#xA;&#xA;void NodeClick(int node)&#xA;{&#xA;    node=GetNodeParent(node);&#xA;    if(node==0)return;&#xA;    int idx=GetRegisterIdx(node); // printf(&quot;idx:%d&quot;,idx);&#xA;    if(idx&lt;0) return;&#xA;&#xA;    NodeProc(node,0,0);&#xA;&#xA;    node=GetNodeParent(node);&#xA;    if(node==0)return;&#xA;    int nd=node;&#xA;&#xA;    char buf[20],buf1[200];&#xA;    buf1[0]=0;&#xA;    int child=GetFirstChild(nd);&#xA;    while(child!=0)&#xA;    {&#xA;        GetTreeNodeValue(child,buf,20);&#xA;        if(buf1[0]!=0)&#xA;            sprintf(buf1,&quot;%s,%s&quot;,buf1,buf);&#xA;        else&#xA;            sprintf(buf1,&quot;%s&quot;,buf);&#xA;&#xA;        child=GetNextSibing(child);&#xA;    }&#xA;    SetTreeNodeValue(nd,buf1);&#xA;}&#xA;&#xA;void TreeNodeDbClick(int node)&#xA;{&#xA;    NodeClick(node);&#xA;}&#xA;void TreeNodeEdited(int node)&#xA;{&#xA;    char buf[20];&#xA;    int val;&#xA;    if(node==0)return;&#xA;    int idx=GetRegisterIdx(node); // printf(&quot;idx:%d&quot;,idx);&#xA;    if(idx&lt;0)&#xA;        NodeClick(node);&#xA;    else&#xA;    {&#xA;&#xA;        GetTreeNodeValue(node,buf,20);&#xA;        int val=HexStrToInt(buf);&#xA;        Data[idx]=val;&#xA;        NodeProc(node,1,0);&#xA;        SetHexEditorDat(idx,val);&#xA;        SetHexEditorSelection(idx,1);&#xA;    }&#xA;}&#xA;void HexEditorChanged(int editor)&#xA;{&#xA;    int i;&#xA;    if(skip) return;&#xA;    for(i=0; i&lt;200; i++)&#xA;        Data[i]=GetHexEditorDat(i);&#xA;    NodeProcAll(1);&#xA;&#xA;}&#xA;&#xA;void BtnClick0()&#xA;{&#xA;    skip=1;&#xA;    ReadDataFromFile(&quot;c:\\zz.bin&quot;);&#xA;    HexEditorLoadFromFile(&quot;c:\\zz.bin&quot;);&#xA;    NodeProcAll(1);&#xA;    skip=0;&#xA;}&#xA;void BtnClick1()&#xA;{&#xA;    int i;&#xA;    //NodeProcAll(0);&#xA;    for(i=0; i&lt;20; i++)&#xA;        printf(&quot;%d&quot;,Data[i]);&#xA;    WriteDataToFile(&quot;c:\\zz.bin&quot;);&#xA;}&#xA;&#xA;void main()&#xA;{&#xA;    char buf[50],buf1[50];&#xA;    ClearVclControls();&#xA;    ShowVclWin(80);&#xA;    CloseInputWin();&#xA;    ShowOutputWin(300);&#xA;    int p=GetGuiWin();&#xA;    int btn=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;读取文件&quot;,0);&#xA;    SetPropertyList(btn,&quot;left&quot;,10+0*90,&quot;top&quot;,30,&quot;width&quot;,85,&quot;onclick&quot;,BtnClick0,NULL);//创建按钮&#xA;&#xA;    btn=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;输出文件&quot;,0);&#xA;    SetPropertyList(btn,&quot;left&quot;,10+1*90,&quot;top&quot;,30,&quot;width&quot;,85,&quot;onclick&quot;,BtnClick1,NULL);//创建按钮&#xA;&#xA;&#xA;    ClearTreeNode();&#xA;    int i,node0,node1;&#xA;    for(i=0; i&lt;200; i++)Data[i]=rand(255);&#xA;&#xA;    int a=AddTextTreeNode(0,&quot;0-1 字节：Chip ID Registers&quot; ,&quot;&quot;);&#xA;    int b=AddTextTreeNode(0,&quot;2-11  字节：Global Control Registers&quot; ,&quot;&quot;);&#xA;    int c=AddTextTreeNode(0,&quot;12-15 字节：保留&quot; ,&quot;&quot;);&#xA;    int d=AddTextTreeNode(0,&quot;16-29 Port 1 Control Registers&quot; ,&quot;&quot;);&#xA;    int e=AddTextTreeNode(0,&quot;30-31 Port 1 Status Registers&quot;  ,&quot;&quot;);&#xA;    int f=AddTextTreeNode(0,&quot;32-45 Port 2 Control Registers&quot; ,&quot;&quot;);&#xA;    int g=AddTextTreeNode(0,&quot;46-47 Port 2 Status Registers&quot;  ,&quot;&quot;);&#xA;    int h=AddTextTreeNode(0,&quot;48-61 Port 3 Control Registers&quot; ,&quot;&quot;);&#xA;    int i=AddTextTreeNode(0,&quot;62-63 Port 3 Status Registers&quot;  ,&quot;&quot;);&#xA;    int j=AddTextTreeNode(0,&quot;64-77 Port 4 Control Registers&quot; ,&quot;&quot;);&#xA;    int k=AddTextTreeNode(0,&quot;78-79 Port 4 Status Registers&quot;  ,&quot;&quot;);&#xA;    int l=AddTextTreeNode(0,&quot;80-93 Port 5 Control Registers&quot; ,&quot;&quot;);&#xA;    int m=AddTextTreeNode(0,&quot;94-95 Port 5 Status Registers&quot;  ,&quot;&quot;);&#xA;&#xA;&#xA;    c=AddTextTreeNode(a,&quot;(0x00): 第0字节&quot; ,&quot;0&quot;); //name,event,value,min,max&#xA;    node0=AddTextTreeNode(a,&quot;(01): 第1字节 / Start Switch&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;7-4 Chip ID&quot; ,&quot;000&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;3-1 Revision ID&quot; ,&quot;000&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;0 Start Switch&quot; ,&quot;0&quot;);&#xA;&#xA;    node0=AddTextTreeNode(b,&quot;(0x02): Global Control 0&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;7-3 hour&quot; ,&quot;00000&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;2-0 min hi3bit&quot; ,&quot;000&quot;);&#xA;&#xA;    node0=AddTextTreeNode(b,&quot;(0x03): Global Control 1&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;7-5 min low3 bit&quot;  ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;4-0 sec hi 5bit &quot;         ,&quot;0&quot;);&#xA;&#xA;&#xA;    node0=AddTextTreeNode(b,&quot;(0x04): Global Control 2&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;7 sec low 1 bit &quot;  ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;6 Multicast Storm&quot;         ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;5 Back Pressure Mode&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;4 Flow Control and Back&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;3 No Excessive Collision Drop&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;2 Huge Packet Support&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;1 Legal Maximum Packet&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;0 Priority Buffer Reserve&quot; ,&quot;0&quot;);&#xA;&#xA;&#xA;    node0=AddTextTreeNode(d,&quot;(0x10): Port 1 Control 0&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;7 Broadcast Storm&quot;  ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;6 DiffServ Priority&quot;         ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;5 802.1p Priority&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;4 Port-Based Priority&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;3 Reserved&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;2 Tag Insertion&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;1 Tag Removal&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;0 Priority Enable&quot; ,&quot;0&quot;);&#xA;&#xA;&#xA;&#xA;    node0=AddTextTreeNode(d,&quot;(0x20): Port 2 Control 0&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;7 Broadcast Storm&quot;  ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;6 DiffServ Priority&quot;         ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;5 802.1p Priority&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;4 Port-Based Priority&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;3 Reserved&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;2 Tag Insertion&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;1 Tag Removal&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;0 Priority Enable&quot; ,&quot;0&quot;);&#xA;&#xA;&#xA;    node0=AddTextTreeNode(f,&quot;(0x20): Port 2 Control 0&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;7 Broadcast Storm&quot;  ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;6 DiffServ Priority&quot;         ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;5 802.1p Priority&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;4 Port-Based Priority&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;3 Reserved&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;2 Tag Insertion&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;1 Tag Removal&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;0 Priority Enable&quot; ,&quot;0&quot;);&#xA;&#xA;    node0=AddTextTreeNode(h,&quot;(0x30): Port 3 Control 0&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;7 Broadcast Storm&quot;  ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;6 DiffServ Priority&quot;         ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;5 802.1p Priority&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;4 Port-Based Priority&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;3 Reserved&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;2 Tag Insertion&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;1 Tag Removal&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;0 Priority Enable&quot; ,&quot;0&quot;);&#xA;&#xA;    node0=AddTextTreeNode(j,&quot;(0x40): Port 4 Control 0&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;7 Broadcast Storm&quot;  ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;6 DiffServ Priority&quot;         ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;5 802.1p Priority&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;4 Port-Based Priority&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;3 Reserved&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;2 Tag Insertion&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;1 Tag Removal&quot; ,&quot;0&quot;);&#xA;    node1=AddTextTreeNode(node0,&quot;0 Priority Enable&quot; ,&quot;0&quot;);&#xA;&#xA;    rootNode=a;&#xA;    NodeProcAll(1);&#xA;    SetHexEditorDataList(0,Data,200);&#xA;    skip=0;&#xA;    ShowLeftToolPage(1);&#xA;    ShowDispMode(2);&#xA;    ShowMessage(&quot;试试修改左侧树中的数据或右侧十六进制数。两侧数据会同步显示。\r\n[左侧]：为数据含义\r\n[右侧]：为数据内容&quot;);&#xA;}&#xA;"/>
      <Command cmdname="GB/T19056汽车行驶记录仪" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;&#xA;//////////////// 接收队列处理 ///////////////////////////////////&#xA;#define MAXRXBUFLEN (1024*20)&#xA;#define GetRxBufLen()  ((RxBufTail+MAXRXBUFLEN-RxBufHead) % MAXRXBUFLEN)&#xA;#define IsRxBufEmpty() (RxBufHead==RxBufTail)&#xA;#define IsRxBufFull()  ((RxBufTail+1)%MAXRXBUFLEN==RxBufHead)&#xA;#define ClearRxBuf()   RxBufHead=RxBufTail=0&#xA;void main()&#xA;{&#xA;  int pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;form1&quot;,&quot;Width&quot;,400,&quot;height&quot;,300,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;visible&quot;,1,NULL);  &#xA;};&#xA;&#xA;BYTE RxBuf[MAXRXBUFLEN];&#xA;BYTE RxBufHead=0;&#xA;BYTE RxBufTail=0;&#xA;&#xA;BYTE GetRxBufByte(void)&#xA;{&#xA;    BYTE dat;&#xA;    dat=RxBuf[RxBufHead];&#xA;    RxBufHead++;&#xA;    RxBufHead%=MAXRXBUFLEN;&#xA;    return dat;&#xA;}&#xA;void DiscardRxBufBytes(BYTE count)&#xA;{&#xA;    RxBufHead+=count;&#xA;    RxBufHead%=MAXRXBUFLEN;&#xA;}&#xA;BYTE PeekRxBufByte(BYTE idx)&#xA;{&#xA;    BYTE tmpHead=RxBufHead;&#xA;    tmpHead+=idx;&#xA;    tmpHead%=MAXRXBUFLEN;&#xA;    return RxBuf[tmpHead];&#xA;}&#xA;void PutRxBufByte(BYTE dat)&#xA;{&#xA;    RxBuf[RxBufTail]=dat;&#xA;    RxBufTail++;&#xA;    RxBufTail%=MAXRXBUFLEN;&#xA;}&#xA;&#xA;//////////////////////////////////////////////////////////////////&#xA;//////////////// 队列处理 ///////////////////////////////////&#xA;//#define MAXRXBUFLEN (1024*20)&#xA;#define GetPrtclBufLen()  ((PrtclBufTail+MAXRXBUFLEN-PrtclBufHead) % MAXRXBUFLEN)&#xA;#define IsPrtclBufEmpty() (PrtclBufHead==PrtclBufTail)&#xA;#define IsPrtclBufFull()  ((PrtclBufTail+1)%MAXRXBUFLEN==PrtclBufHead)&#xA;#define ClearPrtclBuf()   PrtclBufHead=PrtclBufTail=0&#xA;&#xA;BYTE PrtclBuf[MAXRXBUFLEN];&#xA;BYTE PrtclBufHead=0;&#xA;BYTE PrtclBufTail=0;&#xA;&#xA;BYTE GetPrtclBufByte(void)&#xA;{&#xA;    BYTE dat;&#xA;    dat=PrtclBuf[PrtclBufHead];&#xA;    PrtclBufHead++;&#xA;    PrtclBufHead%=MAXRXBUFLEN;&#xA;    return dat;&#xA;}&#xA;void DiscardPrtclBufBytes(BYTE count)&#xA;{&#xA;    PrtclBufHead+=count;&#xA;    PrtclBufHead%=MAXRXBUFLEN;&#xA;}&#xA;BYTE PeekPrtclBufByte(BYTE idx)&#xA;{&#xA;    BYTE tmpHead=PrtclBufHead;&#xA;    tmpHead+=idx;&#xA;    tmpHead%=MAXRXBUFLEN;&#xA;    return PrtclBuf[tmpHead];&#xA;}&#xA;void PutPrtclBufByte(BYTE dat)&#xA;{&#xA;    PrtclBuf[PrtclBufTail]=dat;&#xA;    PrtclBufTail++;&#xA;    PrtclBufTail%=MAXRXBUFLEN;&#xA;}&#xA;&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;&#xA;&#xA;&#xA;#define MAXCMDLEN 200&#xA;BYTE cmdData[MAXCMDLEN];&#xA;BYTE cmdLen;&#xA;&#xA;void ProcessRecvCmd(int node,int cmd,unsigned char *dat,int len)&#xA;{&#xA;    unsigned char s[100];&#xA;    if(cmd==0x00)&#xA;    {&#xA;        dat[len]=0;&#xA;        sprintf(s,&quot;%s&quot;,dat);&#xA;        AddPrtclDetailNode(node,s,0,0);&#xA;    }&#xA;&#xA;}&#xA;&#xA;void EncodePrtclData(void)//包裹解码&#xA;{&#xA;    int i,len;&#xA;    int cmd;&#xA;    int node;&#xA;    unsigned char s[100];&#xA;    BYTE cs;&#xA;&#xA;    AddPrtclDetailNode(NULL,&quot;起始字头&quot;,PrtclBufHead,2);&#xA;    GetPrtclBufByte();//丢弃一个字节; 55&#xA;    GetPrtclBufByte();//丢弃一个字节; 7a&#xA;    AddPrtclDetailNode(NULL,&quot;命令字&quot;,PrtclBufHead,1);&#xA;&#xA;    cmd=GetPrtclBufByte();//丢弃一个字节; len&#xA;    int node=AddPrtclDetailNode(NULL,&quot;长度&quot;,PrtclBufHead,2);&#xA;    len=GetPrtclBufByte();&#xA;    len=len*256+GetPrtclBufByte();&#xA;    sprintf(s,&quot;长度为:%d&quot;,len);&#xA;    AddPrtclDetailNode(node,s,0,0);&#xA;&#xA;    AddPrtclDetailNode(NULL,&quot;保留&quot;,PrtclBufHead,1);&#xA;    GetPrtclBufByte();//丢弃一个字节;&#xA;&#xA;    node=AddPrtclDetailNode(NULL,&quot;数据块&quot;,PrtclBufHead,len);&#xA;&#xA;    for(i=0; i&lt;len; i++)&#xA;        cmdData[i]=GetPrtclBufByte();&#xA;&#xA;    AddPrtclDetailNode(NULL,&quot;校验&quot;,PrtclBufHead,1);&#xA;    GetPrtclBufByte(); //cs&#xA;&#xA;    cmdLen=len;&#xA;    printf(&quot;Recv a command!&quot;);&#xA;    ProcessRecvCmd(node,cmd,cmdData,cmdLen);&#xA;&#xA;}&#xA;&#xA;&#xA;//通讯处理&#xA;void ProcessRxComm(void)&#xA;{&#xA;    BYTE len;&#xA;    unsigned char cs;&#xA;    int i;&#xA;    while(GetRxBufLen()&gt;=7)&#xA;    {&#xA;        if(PeekRxBufByte(0)!=0x55)&#xA;        {&#xA;            DiscardRxBufBytes(1);&#xA;        }&#xA;        else if(PeekRxBufByte(1)!=0x7a)&#xA;        {&#xA;            DiscardRxBufBytes(2);&#xA;        }&#xA;        else&#xA;        {&#xA;            len=PeekRxBufByte(3)*256+PeekRxBufByte(4);&#xA;            if(GetRxBufLen()&gt;=len+7)&#xA;            {&#xA;                cs=0;&#xA;                for(i=0; i&lt;len+7-1; i++)&#xA;                    cs=cs^PeekRxBufByte(i);&#xA;                if(cs!=PeekRxBufByte(len+6))&#xA;                {&#xA;                    printf(&quot;校验出错!&quot;);&#xA;                    DiscardRxBufBytes(2);&#xA;                }&#xA;                else&#xA;                {&#xA;                    if(PeekRxBufByte(2)==0x00)&#xA;                    {&#xA;                        printf(&quot;采集执行标准版本号&quot;);&#xA;                        AddPrtclDataNode(NULL,&quot;采集执行标准版本号&quot;,&amp;RxBuf[RxBufHead],len+7,0);&#xA;                    }&#xA;                    else if(PeekRxBufByte(2)==0x01)&#xA;                    {&#xA;                        printf(&quot;采集当前驾驶人信息&quot;);&#xA;                        AddPrtclDataNode(NULL,&quot;采集当前驾驶人信息&quot;,&amp;RxBuf[RxBufHead],len+7,0);&#xA;                    }&#xA;                    else if(PeekRxBufByte(2)==0x02)&#xA;                    {&#xA;                        printf(&quot;采集实时时钟&quot;);&#xA;                        AddPrtclDataNode(NULL,&quot;采集实时时钟&quot;,&amp;RxBuf[RxBufHead],len+7,0);&#xA;                    }&#xA;                    //else if(...)  //继续扩充&#xA;                    //{ ...  }&#xA;&#xA;                    DiscardRxBufBytes(len+7);&#xA;                }&#xA;            }&#xA;            else&#xA;            {&#xA;                break;&#xA;            }&#xA;        }&#xA;    }	//while&#xA;}&#xA;&#xA;void ProcessPrtclData(void)&#xA;{&#xA;    EncodePrtclData();&#xA;}&#xA;&#xA;&#xA;//////////////////////////////////////////////////////////////////////&#xA;&#xA;void RecvSerialData(char *buf,int count)&#xA;{&#xA;    int i;&#xA;    for(i=0; i&lt;count; i++)&#xA;    {&#xA;        PutRxBufByte(buf[i]);&#xA;    }&#xA;    printf(&quot;RecvSerialData,len(%d)&quot;,count);&#xA;    ProcessRxComm();&#xA;&#xA;}&#xA;void AnaProtocolData(char *buf,int count)&#xA;{&#xA;    int node;&#xA;    int i;&#xA;    printf(&quot;AnaProtocolData,len(%d) &quot;,count );&#xA;    ClearPrtclBuf();&#xA;    for(i=0; i&lt;count; i++)&#xA;        PutPrtclBufByte(buf[i]);&#xA;    ProcessPrtclData();&#xA;}&#xA;&#xA;void click(int btn)&#xA;{&#xA;    unsigned char s0[]= {0x55 ,0x7A ,0x00 ,0x00 ,0x0e  ,0x00  ,0x47 ,0x42 ,0x2F ,0x54 ,0x31 ,0x39 ,0x30 ,0x35 ,0x36 ,0x2D ,0x32 ,0x30 ,0x30 ,0x39,0x42};&#xA;    //char s1[]= {0x55 ,0xAA ,0x04 ,0xFb ,0x02 ,0x02 ,0xf3 ,0xf7 ,0x03};&#xA;    RecvSerialData(s0,sizeof(s0));&#xA;    //RecvSerialData(s1,sizeof(s1));&#xA;};&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;void SendCmd(unsigned char cmd,unsigned char *data,int len)&#xA;{&#xA;    int i;&#xA;    unsigned char buf[1024];&#xA;    unsigned char s[1024];&#xA;    unsigned char tmp[10];&#xA;    unsigned char cs=0;&#xA;    buf[0]=0xAA;&#xA;    buf[1]=0x75;&#xA;    buf[2]=cmd;&#xA;    buf[3]=(len&gt;&gt;8)&amp;0xff;&#xA;    buf[4]=len&amp;0xff;&#xA;    buf[5]=0;&#xA;    for(i=0; i&lt;len; i++)&#xA;        buf[6+i]=data[i];&#xA;    for(i=0; i&lt;7+len; i++)&#xA;        cs=cs^buf[i];&#xA;    buf[6+len]=cs;&#xA;    SendBuffer(buf,7+len);&#xA;    s[0]=0;&#xA;    for(i=0; i&lt;7+len; i++)&#xA;    {&#xA;        sprintf(tmp,&quot;%02X,&quot;,buf[i]);&#xA;        strcat(s,tmp);&#xA;    }&#xA;    printf(&quot;send cmd: %s&quot;,s);&#xA;}&#xA;void TreeNodeDbClick(int node)&#xA;{&#xA;    char buf[80];&#xA;    unsigned char data[100];&#xA;    int DatCount=0;&#xA;    GetTreeNodeCaption(node,buf+2,80);&#xA;    if(GetNodeParent(node)!=0) return;&#xA;    buf[0]='0';&#xA;    buf[1]='x';&#xA;    buf[4]=0;&#xA;    int cmd=StrToInt(buf);&#xA;    int nd=GetFirstChild(node);&#xA;    while(nd!=0)&#xA;    {&#xA;        GetTreeNodeValue(nd,buf,80);&#xA;        //printf(&quot;data %d is:%d %d&quot;,DatCount,buf[0]&amp;0xff,buf[1]&amp;0xff);&#xA;        data[DatCount++]=StrToInt(buf);&#xA;        nd=GetNextSibing(nd);&#xA;    }&#xA;    //printf(&quot;cmd is %d&quot;,cmd);&#xA;    SendCmd(cmd,data,DatCount);&#xA;}&#xA;void main0()&#xA;{&#xA;    int i,btn,node;&#xA;    ShowProtocolWin();&#xA;    ClearVclControls();&#xA;    ShowOutputWin(700);&#xA;    ShowVclWin(140);&#xA;    int p=GetGuiWin(0);&#xA;    btn=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;模拟数据&quot;,&quot;left&quot;,10,&quot;top&quot;,30,&quot;width&quot;,85,&quot;onclick&quot;,click,NULL);//创建按钮&#xA;    ClearProtocolTree();&#xA;    click(0);&#xA;};&#xA;&#xA;void main()&#xA;{&#xA;    int node;&#xA;    ShowOutputWin(-1);&#xA;    main0();&#xA;    ClearTreeNode();&#xA;    node =AddButtonTreeNode(0,&quot;00.采集记录仪执行标准版本号&quot; ,0);&#xA;    SetTreeNodeBkColor(node,0x0000ff);&#xA;    int b=AddButtonTreeNode(0,&quot;01.采集当前驾驶人信息&quot; ,0);&#xA;&#xA;    AddButtonTreeNode(0,&quot;02.采集记录仪的实时时钟&quot; ,0);&#xA;    AddButtonTreeNode(0,&quot;03.采集累计行驶里程&quot; ,0);&#xA;    AddButtonTreeNode(0,&quot;04.采集记录仪速度脉冲系数&quot; ,0);&#xA;    AddButtonTreeNode(0,&quot;06.采集车辆信息&quot; ,0);&#xA;    AddButtonTreeNode(0,&quot;08.采集记录仪状态信号配置信息&quot; ,0);&#xA;    AddButtonTreeNode(0,&quot;16.采集记录仪唯一性编号&quot; ,0);&#xA;    node=AddButtonTreeNode(0,&quot;09.采集指定的每秒钟平均速度记录&quot; ,0);&#xA;&#xA;    AddSpinTreeNode(node,&quot;起始年&quot; ,11,0,99);&#xA;    AddSpinTreeNode(node,&quot;月&quot; ,10,1,12);&#xA;    AddSpinTreeNode(node,&quot;日&quot; ,11,1,21);&#xA;    AddSpinTreeNode(node,&quot;时&quot; ,16,0,23);&#xA;    AddSpinTreeNode(node,&quot;分&quot; ,11,0,59);&#xA;    AddSpinTreeNode(node,&quot;秒&quot; ,16,0,59);&#xA;    AddSpinTreeNode(node,&quot;结束年&quot; ,11,0,99);&#xA;    AddSpinTreeNode(node,&quot;月&quot; ,10,1,12);&#xA;    AddSpinTreeNode(node,&quot;日&quot; ,11,1,21);&#xA;    AddSpinTreeNode(node,&quot;时&quot; ,16,0,23);&#xA;    AddSpinTreeNode(node,&quot;分&quot; ,11,0,59);&#xA;    AddSpinTreeNode(node,&quot;秒&quot;,16 ,0,59);&#xA;    AddSpinTreeNode(node,&quot;最大单位数据块个数N(高字节)&quot; ,0,59,16);&#xA;    AddSpinTreeNode(node,&quot;最大单位数据块个数N(低字节)&quot; ,0,59,16);&#xA;&#xA;    AddButtonTreeNode(0,&quot;05.采集指定的每分钟平均速度记录&quot; ,0);&#xA;    AddButtonTreeNode(0,&quot;13.采集指定的位置信息记录&quot; ,0);&#xA;    AddButtonTreeNode(0,&quot;07.采集指定的事故疑点记录&quot; ,0);&#xA;    AddButtonTreeNode(0,&quot;11.采集指定的疲劳驾驶记录&quot; ,0);&#xA;    AddButtonTreeNode(0,&quot;10.采集指定的登录退出记录&quot; ,0);&#xA;    AddButtonTreeNode(0,&quot;14.采集指定的外部供电记录&quot; ,0);&#xA;    AddButtonTreeNode(0,&quot;15.采集指定的参数修改记录&quot; ,0);&#xA;&#xA;&#xA;    node=AddButtonTreeNode(0,&quot;82.设置车辆信息&quot; ,0);&#xA;    SetTreeNodeBkColor(node,0x0000ff);&#xA;    AddButtonTreeNode(0,&quot;83.设置记录仪初次安装日期&quot; ,0);&#xA;    AddButtonTreeNode(0,&quot;84.设置状态量信息&quot; ,0);&#xA;    AddButtonTreeNode(0,&quot;C2.设置记录仪时钟&quot; ,0);&#xA;    AddButtonTreeNode(0,&quot;C3.设置记录仪速度脉冲系数&quot; ,0);&#xA;    node=AddButtonTreeNode(0,&quot;E0.检定控制命令&quot; ,0);&#xA;    SetTreeNodeBkColor(node,0x0000ff);&#xA;    AddButtonTreeNode(0,&quot;E1.记录仪发送速度里程数据&quot; ,0);&#xA;    AddButtonTreeNode(0,&quot;E2.检定模式保持命令&quot; ,0);&#xA;&#xA;&#xA;&#xA;    ShowLeftToolPage(1);&#xA;    //ExplandAllTreeNode();&#xA;}&#xA;"/>
      <Command cmdname="创建PageControl控件" cmdType="P" cmd="[P]void main()&#xA;{&#xA;    ClearVclControls();&#xA;    ShowVclWin(150);&#xA;    ShowOutputWin(300);&#xA;    int p=GetGuiWin(0);&#xA;    int pnl=CreateComponentEx(p,&quot;panel&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,350,&quot;height&quot;,200,0);&#xA;    int pc=CreateComponentEx(p,&quot;PageControl&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,350,&quot;height&quot;,200,0);&#xA;    int AxlerPpm=CreateComponentEx(p,&quot;PopupMenu&quot;,&quot;AutoHotKeys&quot;,&quot;maManual&quot;,0);&#xA;    int mi=CreateComponentEx(AxlerPpm,&quot;MenuItem&quot;,&quot;caption&quot;,&quot;计轴器关闭&quot;,&quot;OnClick&quot;,0,0);&#xA;    AddMenuItem(AxlerPpm,mi);&#xA;    mi=CreateComponentEx(AxlerPpm,&quot;MenuItem&quot;,&quot;caption&quot;,&quot;计轴器开启&quot;,&quot;OnClick&quot;,0,0);&#xA;    AddMenuItem(AxlerPpm,mi);&#xA;    mi=CreateComponentEx(AxlerPpm,&quot;MenuItem&quot;,&quot;caption&quot;,&quot;模拟过轴&quot;,&quot;OnClick&quot;,0,0);&#xA;    // // int pnl=CreateComponentEx(p,&quot;panel&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,350,&quot;height&quot;,200,&quot;popupmenu&quot;,AxlerPpm,0);&#xA;    int ts=CreateComponentEx(p,&quot;tabsheet&quot;,&quot;caption&quot;,&quot;abc&quot;,&quot;PageControl&quot;,pc,0);&#xA;    ts=CreateComponentEx(p,&quot;tabsheet&quot;,&quot;caption&quot;,&quot;2222343243&quot;,&quot;PageControl&quot;,pc,0);&#xA;    CreateComponentEx(ts,&quot;button&quot;,&quot;caption&quot;,&quot;aaa&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,50,&quot;height&quot;,20,0);&#xA;    AutoSetVclWinSize();&#xA;}"/>
    </Command>
    <Command cmdname="嵌入C编译器特性" cmdType="S" cmd="[S]ERROR">
      <Command cmdname="#pragma：添加包含目录" cmdType="P" cmd="[P]#pragma comment(add_include_path,&quot;dat&quot;)  //添加包含目录&#xA;#pragma comment(add_library_path,&quot;dat&quot;)  //添加库目录&#xA;#include &quot;abc.h&quot;&#xA;#pragma comment(lib,&quot;glGraphLib.o&quot;);             //添加库&#xA;void main()&#xA;{&#xA;   &#xA;};"/>
    </Command>
  </Command>
  <Command cmdname="操作系统相关" cmdType="P" cmd="[P]void main()&#xA;{&#xA;   float a;&#xA;   float b;&#xA;   char s[100];&#xA;   a=1.22;&#xA;   b=3.442;&#xA;   printf(&quot;%e&quot;,a/b);    &#xA;   PrintfToCommWin(&quot;%e&quot;,a/b);&#xA;   &#xA;}">
    <Command cmdname="启动、停止Print Spooler 系统服务" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;typedef __stdcall int(*OpenSCManagerA_def)(char *lpMachineName, char *lpDatabaseName,DWORD dwDesiredAccess); //宏定义函数指针类型&#xA;typedef __stdcall int(*OpenServiceA_def)(int hSCManager,char * lpServiceName,DWORD dwDesiredAccess);&#xA;typedef __stdcall int(*StartService_def)(int hService, DWORD dwNumServiceArgs,char *lpServiceArgVectors);&#xA;typedef __stdcall int(*CloseServiceHandle_def)(int hService);&#xA;typedef __stdcall int(*ControlService_def)(int hService,DWORD dwControl,void *lpServiceStatus);&#xA;typedef __stdcall int(*QueryServiceStatus_def)(int hService,void *lpServiceStatus);&#xA;typedef __stdcall int(*DeleteService_def)(int hService);&#xA;typedef __stdcall int(*CreateService_def)(int hSCManager,char *lpServiceName,char *lpDisplayName,&#xA;        DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl,&#xA;        char *lpBinaryPathName, char *lpLoadOrderGroup,DWORD *lpdwTagId,char *lpDependencies,&#xA;        char *lpServiceStartName, char *lpPassword);&#xA;&#xA;#define CREATE 0&#xA;#define DELETE 1&#xA;#define START 2&#xA;#define STOP 3&#xA;#define QUERY 4&#xA;int p;&#xA;int txtStatus;&#xA;&#xA;int ServiceManage(int func,char *srvname,char *dispname,char *exefile,char *status)&#xA;{&#xA;    HINSTANCE hDll; //DLL句柄&#xA;    OpenSCManagerA_def OpenSCManager; //函数指针&#xA;    OpenServiceA_def  OpenService;&#xA;    StartService_def  StartService;&#xA;    CloseServiceHandle_def CloseServiceHandle;&#xA;    ControlService_def ControlService;&#xA;    QueryServiceStatus_def QueryServiceStatus;&#xA;    DeleteService_def DeleteService;&#xA;    CreateService_def CreateService;&#xA;&#xA;    unsigned int result,a,b;&#xA;    char *c;&#xA;    unsigned char d[64];&#xA;    hDll = LoadLibrary(&quot;advapi32.dll&quot;);&#xA;    if(hDll != NULL)&#xA;    {&#xA;        OpenSCManager = (OpenSCManagerA_def)GetProcAddress(hDll, &quot;OpenSCManagerA&quot;);&#xA;        OpenService   = (OpenServiceA_def)GetProcAddress(hDll, &quot;OpenServiceA&quot;);&#xA;        StartService  = (StartService_def)GetProcAddress(hDll, &quot;StartServiceA&quot;);&#xA;        CloseServiceHandle = (CloseServiceHandle_def)GetProcAddress(hDll, &quot;CloseServiceHandle&quot;);&#xA;        ControlService   = (ControlService_def)GetProcAddress(hDll, &quot;ControlService&quot;);&#xA;        QueryServiceStatus= (QueryServiceStatus_def)GetProcAddress(hDll, &quot;QueryServiceStatus&quot;);&#xA;        DeleteService = (DeleteService_def)GetProcAddress(hDll, &quot;DeleteService&quot;);&#xA;        CreateService = (CreateService_def)GetProcAddress(hDll, &quot;CreateServiceA&quot;);&#xA;&#xA;        if (OpenSCManager != NULL)&#xA;        {&#xA;            if(func!=CREATE)&#xA;                a=OpenSCManager(0,0,0xf003d);&#xA;            else&#xA;                a=OpenSCManager(0,0,2);&#xA;            if(a&lt;0)&#xA;                ShowMessage(&quot;OpenSCManager() 失败！&quot;);&#xA;            else&#xA;            {&#xA;                //printf(&quot;a:=%d&quot;,a);&#xA;                if(func!=CREATE)&#xA;                {&#xA;                    if(func==DELETE)&#xA;                        b=OpenService(a,srvname,0x00F0000); //&#xA;                    else&#xA;                        b=OpenService(a,srvname,0xf01ff); //&#xA;                }&#xA;&#xA;                //printf(&quot;b=%x&quot;,b);&#xA;                if(func==DELETE)&#xA;                    DeleteService(b);             //删除服务&#xA;                if(func==START)&#xA;                    StartService(b,0,c);          //启动服务&#xA;                if(func==STOP)&#xA;                    ControlService(b,0x01,d);     //停止服务&#xA;                if(func==CREATE)&#xA;                {&#xA;                    b=OpenService(a,srvname,0xf01ff);&#xA;                    DeleteService(b);             //删除服务&#xA;                    b   =   CreateService(a,srvname,&#xA;                                          dispname,&#xA;                                          0xf01ff,&#xA;                                          0x00000100|0x00000010,&#xA;                                          0x00000002,0x00000001,&#xA;                                          exefile,0,0,0,0,0);&#xA;                    if(b&lt;=0)&#xA;                    {&#xA;                        result=GetLastError();&#xA;                        printf(&quot;%x&quot;,result);&#xA;                        ShowMessage(&quot;CreateService Error!&quot;);&#xA;                    }&#xA;                    else&#xA;                        ShowMessage(&quot;CreateService OK!&quot;);&#xA;                }&#xA;&#xA;                Sleep(20);&#xA;                QueryServiceStatus(b,d);       //停止服务&#xA;                result=*((DWORD *)(&amp;d[4]));&#xA;                if(result==1)&#xA;                {&#xA;                    printf(&quot;status:停止&quot;);&#xA;                    sprintf(status,&quot;  停止&quot;);&#xA;                }&#xA;                else if(result==4)&#xA;                {&#xA;                    printf(&quot;status:启动&quot;);&#xA;                    sprintf(status,&quot;  启动&quot;);&#xA;                }&#xA;                else if(result==7)&#xA;                {&#xA;                    printf(&quot;status:暂停&quot;);&#xA;                    sprintf(status,&quot;  暂停&quot;);&#xA;                }&#xA;                else&#xA;                {&#xA;                    printf(&quot;status:等待&quot;);&#xA;                    sprintf(status,&quot;  等待&quot;);&#xA;                }&#xA;&#xA;                //printf(&quot;c:=%d&quot;,c);&#xA;                CloseServiceHandle(b);&#xA;                CloseServiceHandle(a);&#xA;            }&#xA;        }&#xA;        else&#xA;            ShowMessage(&quot;GetProcAddress Error!&quot;);&#xA;    }&#xA;    else&#xA;        ShowMessage(&quot;LoadLibrary advapi32.dll error!&quot;);&#xA;    FreeLibrary(hDll);&#xA;    return 0;&#xA;}&#xA;&#xA;int StartSpooler()&#xA;{&#xA;    char buf[20];&#xA;    ServiceManage(START,&quot;Spooler&quot;,NULL,NULL,buf);&#xA;    SetProperty(txtStatus,&quot;caption&quot;,buf);&#xA;}&#xA;int StopSpooler()&#xA;{&#xA;    char buf[20];&#xA;    ServiceManage(STOP,&quot;Spooler&quot;,NULL,NULL,buf);&#xA;    SetProperty(txtStatus,&quot;caption&quot;,buf);&#xA;}&#xA;int QuerySpooler()&#xA;{&#xA;    char buf[20];&#xA;    ServiceManage(QUERY,&quot;Spooler&quot;,NULL,NULL,buf);&#xA;    SetProperty(txtStatus,&quot;caption&quot;,buf);&#xA;}&#xA;void CloseClick(void *Sender)&#xA;{&#xA;    ClearOutputWin();   //清除输出窗口内容&#xA;    HideVclWin();&#xA;    CloseVclWin();&#xA;    CloseForm(p);&#xA;}&#xA;&#xA;void CreateGui()&#xA;{&#xA;    char buf[20];&#xA;    CloseCodeWin();&#xA;    ClearVclControls();&#xA;&#xA;    int GuiMode=2;&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;        p=GetGuiWin(GuiMode);&#xA;    else&#xA;        p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;Print Spooler 服务管理&quot;,&quot;Width&quot;,530,&quot;height&quot;,130,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;, &quot;visible&quot;,1,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;&#xA;    CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;Print Spooler 状态：&quot;,&quot;left&quot;,10,&quot;top&quot;,40-30,&quot;width&quot;,100,NULL);&#xA;    txtStatus= CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;  Wait...&quot;,&quot;left&quot;,130,&quot;top&quot;,40-30,&quot;width&quot;,60,&quot;color&quot;,0x0000ff,NULL);&#xA;    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;启动Spooler&quot; ,&quot;left&quot;,25,&quot;top&quot;,93+28-70,&quot;width&quot;,100,&quot;onclick&quot;,StartSpooler,NULL);&#xA;    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;停止Spooler&quot;,&quot;left&quot;,145,&quot;top&quot;,93+28-70,&quot;width&quot;,100,&quot;onclick&quot;,StopSpooler,NULL);&#xA;    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;查询状态&quot;,&quot;left&quot;,265,&quot;top&quot;,93+28-70,&quot;width&quot;,100,&quot;onclick&quot;,QuerySpooler,NULL);&#xA;    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;退    出&quot; ,&quot;left&quot;,385,&quot;top&quot;,93+28-70,&quot;width&quot;,100,&quot;onclick&quot;,CloseClick,NULL);&#xA;&#xA;    int ft=GetProperty(txtStatus,&quot;font&quot;,0,0);&#xA;    SetProperty(ft,&quot;color&quot;,0x00ff00,0);&#xA;&#xA;    ServiceManage(QUERY,&quot;Spooler&quot;,NULL,NULL,buf);&#xA;    SetProperty(txtStatus,&quot;caption&quot;,buf);&#xA;}&#xA;&#xA;int main()&#xA;{&#xA;    CreateGui();&#xA;    //ServiceManage(START,&quot;Spooler&quot;,NULL,NULL,buf);&#xA;    //ServiceManage(STOP,&quot;Spooler&quot;,NULL,NULL,buf);&#xA;    //ServiceManage(DELETE,&quot;Spooler&quot;,NULL,NULL,buf);&#xA;    //ServiceManage(CREATE,&quot;Spooler&quot;,&quot;Print Spooler&quot;,&quot;C:\\WINDOWS\\system32\\spoolsv.exe&quot;,buf);&#xA;&#xA;&#xA;&#xA;}&#xA;&#xA;"/>
    <Command cmdname="创建、删除Print Spooler 系统服务" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;typedef __stdcall int(*OpenSCManagerA_def)(char *lpMachineName, char *lpDatabaseName,DWORD dwDesiredAccess); //宏定义函数指针类型&#xA;typedef __stdcall int(*OpenServiceA_def)(int hSCManager,char * lpServiceName,DWORD dwDesiredAccess);&#xA;typedef __stdcall int(*StartService_def)(int hService, DWORD dwNumServiceArgs,char *lpServiceArgVectors);&#xA;typedef __stdcall int(*CloseServiceHandle_def)(int hService);&#xA;typedef __stdcall int(*ControlService_def)(int hService,DWORD dwControl,void *lpServiceStatus);&#xA;typedef __stdcall int(*QueryServiceStatus_def)(int hService,void *lpServiceStatus);&#xA;typedef __stdcall int(*DeleteService_def)(int hService);&#xA;typedef __stdcall int(*CreateService_def)(int hSCManager,char *lpServiceName,char *lpDisplayName,&#xA;        DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl,&#xA;        char *lpBinaryPathName, char *lpLoadOrderGroup,DWORD *lpdwTagId,char *lpDependencies,&#xA;        char *lpServiceStartName, char *lpPassword);&#xA;&#xA;#define CREATE 0&#xA;#define DELETE 1&#xA;#define START 2&#xA;#define STOP 3&#xA;#define QUERY 4&#xA;int p;&#xA;int txtStatus;&#xA;&#xA;int ServiceManage(int func,char *srvname,char *dispname,char *exefile,char *status)&#xA;{&#xA;    HINSTANCE hDll; //DLL句柄&#xA;    OpenSCManagerA_def OpenSCManager; //函数指针&#xA;    OpenServiceA_def  OpenService;&#xA;    StartService_def  StartService;&#xA;    CloseServiceHandle_def CloseServiceHandle;&#xA;    ControlService_def ControlService;&#xA;    QueryServiceStatus_def QueryServiceStatus;&#xA;    DeleteService_def DeleteService;&#xA;    CreateService_def CreateService;&#xA;&#xA;    unsigned int result,a,b;&#xA;    char *c;&#xA;    unsigned char d[64];&#xA;    hDll = LoadLibrary(&quot;advapi32.dll&quot;);&#xA;    if(hDll != NULL)&#xA;    {&#xA;        OpenSCManager = (OpenSCManagerA_def)GetProcAddress(hDll, &quot;OpenSCManagerA&quot;);&#xA;        OpenService   = (OpenServiceA_def)GetProcAddress(hDll, &quot;OpenServiceA&quot;);&#xA;        StartService  = (StartService_def)GetProcAddress(hDll, &quot;StartServiceA&quot;);&#xA;        CloseServiceHandle = (CloseServiceHandle_def)GetProcAddress(hDll, &quot;CloseServiceHandle&quot;);&#xA;        ControlService   = (ControlService_def)GetProcAddress(hDll, &quot;ControlService&quot;);&#xA;        QueryServiceStatus= (QueryServiceStatus_def)GetProcAddress(hDll, &quot;QueryServiceStatus&quot;);&#xA;        DeleteService = (DeleteService_def)GetProcAddress(hDll, &quot;DeleteService&quot;);&#xA;        CreateService = (CreateService_def)GetProcAddress(hDll, &quot;CreateServiceA&quot;);&#xA;&#xA;        if (OpenSCManager != NULL)&#xA;        {&#xA;            if(func!=CREATE)&#xA;                a=OpenSCManager(0,0,0xf003d);&#xA;            else&#xA;                a=OpenSCManager(0,0,2);&#xA;            if(a&lt;0)&#xA;                ShowMessage(&quot;OpenSCManager() 失败！&quot;);&#xA;            else&#xA;            {&#xA;                //printf(&quot;a:=%d&quot;,a);&#xA;                if(func!=CREATE)&#xA;                {&#xA;                    if(func==DELETE)&#xA;                        b=OpenService(a,srvname,0x00F0000); //&#xA;                    else&#xA;                        b=OpenService(a,srvname,0xf01ff); //&#xA;                }&#xA;&#xA;                //printf(&quot;b=%x&quot;,b);&#xA;                if(func==DELETE)&#xA;                    DeleteService(b);             //删除服务&#xA;                if(func==START)&#xA;                    StartService(b,0,c);          //启动服务&#xA;                if(func==STOP)&#xA;                    ControlService(b,0x01,d);     //停止服务&#xA;                if(func==CREATE)&#xA;                {&#xA;                    b=OpenService(a,srvname,0xf01ff);&#xA;                    DeleteService(b);             //删除服务&#xA;                    b   =   CreateService(a,srvname,&#xA;                                          dispname,&#xA;                                          0xf01ff,&#xA;                                          0x00000100|0x00000010,&#xA;                                          0x00000002,0x00000001,&#xA;                                          exefile,0,0,0,0,0);&#xA;                    if(b&lt;=0)&#xA;                    {&#xA;                        result=GetLastError();&#xA;                        printf(&quot;%x&quot;,result);&#xA;                        ShowMessage(&quot;CreateService Error!&quot;);&#xA;                    }&#xA;                    else&#xA;                        ShowMessage(&quot;CreateService OK!&quot;);&#xA;                }&#xA;&#xA;                Sleep(20);&#xA;                QueryServiceStatus(b,d);       //停止服务&#xA;                result=*((DWORD *)(&amp;d[4]));&#xA;                if(result==1)&#xA;                {&#xA;                    printf(&quot;status:停止&quot;);&#xA;                    sprintf(status,&quot;  停止&quot;);&#xA;                }&#xA;                else if(result==4)&#xA;                {&#xA;                    printf(&quot;status:启动&quot;);&#xA;                    sprintf(status,&quot;  启动&quot;);&#xA;                }&#xA;                else if(result==7)&#xA;                {&#xA;                    printf(&quot;status:暂停&quot;);&#xA;                    sprintf(status,&quot;  暂停&quot;);&#xA;                }&#xA;                else&#xA;                {&#xA;                    printf(&quot;status:等待&quot;);&#xA;                    sprintf(status,&quot;  等待&quot;);&#xA;                }&#xA;&#xA;                //printf(&quot;c:=%d&quot;,c);&#xA;                CloseServiceHandle(b);&#xA;                CloseServiceHandle(a);&#xA;            }&#xA;        }&#xA;        else&#xA;            ShowMessage(&quot;GetProcAddress Error!&quot;);&#xA;    }&#xA;    else&#xA;        ShowMessage(&quot;LoadLibrary advapi32.dll error!&quot;);&#xA;    FreeLibrary(hDll);&#xA;    return 0;&#xA;}&#xA;&#xA;int CreateSpooler()&#xA;{&#xA;    char buf[20];&#xA;    ServiceManage(CREATE,&quot;Spooler1&quot;,&quot;Print Spooler1&quot;,&quot;C:\\WINDOWS\\system32\\spoolsv.exe&quot;,buf);&#xA;    SetProperty(txtStatus,&quot;caption&quot;,buf);&#xA;}&#xA;int DeleteSpooler()&#xA;{&#xA;    char buf[20];&#xA;    ServiceManage(DELETE,&quot;Spooler1&quot;,NULL,NULL,buf);&#xA;    SetProperty(txtStatus,&quot;caption&quot;,buf);&#xA;}&#xA;int QuerySpooler()&#xA;{&#xA;    char buf[20];&#xA;    ServiceManage(QUERY,&quot;Spooler1&quot;,NULL,NULL,buf);&#xA;    SetProperty(txtStatus,&quot;caption&quot;,buf);&#xA;}&#xA;void CloseClick(void *Sender)&#xA;{&#xA;    ClearOutputWin();   //清除输出窗口内容&#xA;    HideVclWin();&#xA;    CloseVclWin();&#xA;    CloseForm(p);&#xA;}&#xA;&#xA;void CreateGui()&#xA;{&#xA;    char buf[20];&#xA;    CloseCodeWin();&#xA;    ClearVclControls();&#xA;&#xA;    int GuiMode=2;&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;        p=GetGuiWin(GuiMode);&#xA;    else&#xA;        p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;Print Spooler1 服务管理&quot;,&quot;Width&quot;,530,&quot;height&quot;,130,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;, &quot;visible&quot;,1,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;&#xA;    CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;Print Spooler1 状态：&quot;,&quot;left&quot;,10,&quot;top&quot;,40-30,&quot;width&quot;,100,NULL);&#xA;    txtStatus= CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;  Wait...&quot;,&quot;left&quot;,130,&quot;top&quot;,40-30,&quot;width&quot;,60,&quot;color&quot;,0x0000ff,NULL);&#xA;    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;创建Spooler1&quot; ,&quot;left&quot;,25,&quot;top&quot;,93+28-70,&quot;width&quot;,100,&quot;onclick&quot;,CreateSpooler,NULL);&#xA;    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;删除Spooler1&quot;,&quot;left&quot;,145,&quot;top&quot;,93+28-70,&quot;width&quot;,100,&quot;onclick&quot;,DeleteSpooler,NULL);&#xA;    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;查询状态&quot;,&quot;left&quot;,265,&quot;top&quot;,93+28-70,&quot;width&quot;,100,&quot;onclick&quot;,QuerySpooler,NULL);&#xA;    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;退    出&quot; ,&quot;left&quot;,385,&quot;top&quot;,93+28-70,&quot;width&quot;,100,&quot;onclick&quot;,CloseClick,NULL);&#xA;&#xA;    int ft=GetProperty(txtStatus,&quot;font&quot;,0,0);&#xA;    SetProperty(ft,&quot;color&quot;,0x00ff00,0);&#xA;&#xA;    ServiceManage(QUERY,&quot;Spooler1&quot;,NULL,NULL,buf);&#xA;    SetProperty(txtStatus,&quot;caption&quot;,buf);&#xA;}&#xA;&#xA;int main()&#xA;{&#xA;    char buf[20];&#xA;    CreateGui();&#xA;    //ServiceManage(START,&quot;Spooler&quot;,NULL,NULL,buf);&#xA;    //ServiceManage(STOP,&quot;Spooler&quot;,NULL,NULL,buf);&#xA;    //ServiceManage(DELETE,&quot;Spooler&quot;,NULL,NULL,buf);&#xA;    //ServiceManage(CREATE,&quot;Spooler&quot;,&quot;Print Spooler&quot;,&quot;C:\\WINDOWS\\system32\\spoolsv.exe&quot;,buf);&#xA;&#xA;    //ServiceManage(CREATE,&quot;bhjservice&quot;,&quot;bhj service&quot;,&quot;c:\\test\\Project1.exe&quot;,buf);&#xA;    //ServiceManage(START,&quot;bhjservice&quot;,NULL,NULL,buf);&#xA;    //ServiceManage(STOP,&quot;bhjservice&quot;,NULL,NULL,buf);&#xA;    //ServiceManage(DELETE,&quot;bhjservice&quot;,NULL,NULL,buf);&#xA;&#xA;}&#xA;&#xA;"/>
    <Command cmdname="浮点运算" cmdType="P" cmd="[P]void main()&#xA;{&#xA;   float a;&#xA;   float b;&#xA;   char s[100];&#xA;   a=1.22;&#xA;   b=3.442;&#xA;   printf(&quot;%e&quot;,a/b);    &#xA;   PrintfToCommWin(&quot;%e&quot;,a/b);&#xA;   &#xA;}"/>
    <Command cmdname="调用动态链接库DLL示例1" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;typedef __stdcall DWORD(*Msg)(HWND hWnd, unsigned char *lpText,unsigned char * Caption, unsigned int uType); //宏定义函数指针类型&#xA;int main()&#xA;{&#xA;    HINSTANCE hDll; //DLL句柄&#xA;    Msg msgFunc; //函数指针&#xA;    int result;&#xA;    hDll = LoadLibrary(&quot;user32.dll&quot;);&#xA;    if(hDll != NULL)&#xA;    {&#xA;        msgFunc = (Msg)GetProcAddress(hDll, &quot;MessageBoxA&quot;);&#xA;        if (msgFunc != NULL)&#xA;        {&#xA;            result =msgFunc(0,&quot;调用user32.dll动态链接库中的MessageBox函数成功！&quot;,&quot;调用DLL动态链接库示例&quot;,3);&#xA;            printf(&quot;%d&quot;, result);&#xA;        }&#xA;    }&#xA;    else&#xA;        printf(&quot;dll not found!&quot;);&#xA;    FreeLibrary(hDll);&#xA;    return 0;&#xA;}&#xA;"/>
    <Command cmdname="调用动态链接库DLL示例2" cmdType="P" cmd="[P]#include &lt;stdio.h&gt;&#xA;#include &lt;string.h&gt;&#xA;#include &quot;windows.h&quot;&#xA;typedef __stdcall DWORD(*ShellExec)(HWND hWnd, unsigned char *Operation,unsigned char *FileName,&#xA;                                    unsigned char *Parameters, unsigned char *Directory, int uType); //宏定义函数指针类型&#xA;int run()&#xA;{&#xA;    HINSTANCE hDll; //DLL句柄&#xA;    ShellExec msgFunc; //函数指针&#xA;    int result;&#xA;    hDll = LoadLibrary(&quot;shell32.dll&quot;);&#xA;    if(hDll != NULL)&#xA;    {&#xA;        msgFunc = (ShellExec)GetProcAddress(hDll, &quot;ShellExecuteA&quot;);&#xA;        if (msgFunc != NULL)&#xA;        {&#xA;            result =msgFunc(0,&quot;open&quot;,&quot;c:\\dd.scf&quot;,0,0,1);&#xA;        }&#xA;    }&#xA;    else&#xA;        printf(&quot;dll not found!&quot;);&#xA;    FreeLibrary(hDll);&#xA;    return 0;&#xA;}&#xA;void main()&#xA;{&#xA;    FILE *dest;&#xA;&#xA;    if( (dest=fopen( &quot;c:\\dd.scf&quot;, &quot;wb+&quot;)) == NULL )&#xA;    {&#xA;        return;&#xA;    }&#xA;    fprintf(dest,&quot;[Shell]\r\n&quot;);&#xA;    fprintf(dest,&quot;Command=2\r\n&quot;);&#xA;    fprintf(dest,&quot;IconFile=explorer.exe,3\r\n&quot;);&#xA;    fprintf(dest,&quot;[Taskbar]\r\n&quot;);&#xA;    fprintf(dest,&quot;Command=ToggleDesktop\r\n&quot;);&#xA;    fclose(dest);&#xA;    ShowMessage(&quot;下面调用Shell32.dll中的ShellExecute API函数，实现显示桌面!&quot;);&#xA;    run();&#xA;}&#xA;"/>
    <Command cmdname="IE--21ic" cmdType="P" cmd="[P]void main()&#xA;{&#xA;    ShellExecute(0,&quot;open&quot;,&quot;IEXPLORE.EXE&quot;,&quot;http://bbs.21ic.com/icview-266971-1-1.html&quot;,0,1);&#xA;}"/>
    <Command cmdname="嵌入汇编" cmdType="P" cmd="[P]void main()&#xA;{&#xA;    unsigned short val;&#xA;    unsigned int a,b;    &#xA;    __asm__(&quot;fstcw %0&quot;:&quot;m&quot;(val));&#xA;    printf(&quot;val0:%x&quot;,val);&#xA;    a=123;&#xA;    asm(&quot;mov %0,%%eax\r\n mov %%eax,%1&quot;:&quot;r&quot;(b):&quot;r&quot;(a));&#xA;    printf(&quot;val1:%d&quot;,b);    &#xA;};"/>
    <Command cmdname="显示桌面" cmdType="P" cmd="[P]#include &lt;stdio.h&gt;&#xA;unsigned char s[]=&quot;[Shell]\r\n&quot;\&#xA;     &quot;Command=2\r\n&quot;\&#xA;     &quot;IconFile=explorer.exe,3\r\n&quot;\&#xA;     &quot;[Taskbar]\r\n&quot;\&#xA;     &quot;Command=ToggleDesktop\r\n&quot;;&#xA;    &#xA;void main()&#xA;{&#xA;    FILE *dest;&#xA;    if( (dest=fopen( &quot;c:\\DispDesktop.scf&quot;, &quot;wb+&quot;)) == NULL )&#xA;        return;&#xA;    fprintf(dest,&quot;%s&quot;,s);&#xA;    fclose(dest);&#xA;    ShellExecute(0,&quot;open&quot;,&quot;c:\\DispDesktop.scf&quot;,0,0,1);&#xA;}"/>
    <Command cmdname="uc/osII" cmdType="S" cmd="[S]ERROR">
      <Command cmdname="UCOSII实验" cmdType="P" cmd="[P]#pragma comment(add_library_path,&quot;script\\ucosii&quot;)&#xA;#pragma comment(add_include_path,&quot;script\\ucosii&quot;)&#xA;#include &quot;includes.h&quot;&#xA;#pragma comment(lib,&quot;os_cpu_c.c&quot;)&#xA;#pragma comment(lib,&quot;os_dbg_r.c&quot;)&#xA;#pragma comment(lib,&quot;os_trace.c&quot;)&#xA;#pragma comment(lib,&quot;ucos_ii.c&quot;)&#xA;&#xA;#define  TASK_STK_SIZE    128&#xA;//extern INT32U              OSTerminateCtxSwW32;&#xA;OS_STK        AppStk_one[TASK_STK_SIZE];&#xA;OS_STK        AppStk_two[TASK_STK_SIZE];&#xA;OS_STK        AppStk_three[TASK_STK_SIZE];&#xA;//int stop=0;&#xA;static void App_one(void *p_arg);&#xA;static void App_two(void *p_arg);&#xA;static void App_three(void *p_arg);&#xA;static void print_task_ready_tab(void);&#xA;int btn;&#xA;void OnTerminate()&#xA;{&#xA;    OS_STOP();&#xA;    printf(&quot;terminate&quot;);      &#xA;}&#xA;&#xA;void CreateGui()&#xA;{&#xA;    int p;&#xA;    ClearVclControls();&#xA;    ShowVclWin(300);&#xA;    ShowOutputWin(-1);&#xA;    ClearOutputWin();&#xA;    p=GetGuiWin(0);&#xA;    btn=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;终止UCOS&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,80,&quot;height&quot;,20,&quot;OnClick&quot;,OnTerminate,0);&#xA;    AutoSetVclWinWidth();&#xA;}&#xA;void main(int argc, char *argv[])&#xA;{&#xA;    CreateGui();&#xA;    printf(&quot;CommBox ucos ver2.80 start...&quot;);&#xA;&#xA;    OSInit();//                              /* Initialize &quot;uC/OS-II&quot;*/&#xA;    OSTaskCreate(App_one,NULL,(OS_STK *)&amp;AppStk_one[TASK_STK_SIZE-1],(INT8U)11);&#xA;    OSTaskCreate(App_two,NULL,(OS_STK *)&amp;AppStk_two[TASK_STK_SIZE-1],(INT8U)30);&#xA;    OSTaskCreate(App_three,NULL,(OS_STK *)&amp;AppStk_three[TASK_STK_SIZE-1],(INT8U)50);&#xA;    OSStart();                             /* Start multitasking */&#xA;    &#xA;    printf(&quot;CommBox ucos end&quot;);&#xA;    SetProperty(btn,&quot;enabled&quot;,0);    &#xA;}  &#xA;&#xA;void App_one(void *p_arg)&#xA;{&#xA;    p_arg = p_arg;&#xA;    printf(&quot;current prio=%d,OSPrioHighRdy=%d\n&quot;,OSPrioCur,OSPrioHighRdy);&#xA;    while (TRUE)&#xA;    {&#xA;        printf(&quot;&quot;);&#xA;        OS_Printf(&quot;\nthis is App_one, Delay 6 second and start again\n&quot;);&#xA;        printf(&quot;current prio=%d,OSPrioHighRdy=%d\n&quot;,OSPrioCur,OSPrioHighRdy);&#xA;        //OS_Printf(&quot;Resume prio=30 task\n&quot;);&#xA;        //OSTaskResume(30);&#xA;        //print_task_ready_tab();&#xA;        OSTimeDlyHMSM(0, 0, 2, 0);        &#xA;    }  &#xA;}&#xA;&#xA;void App_two(void *p_arg)&#xA;{&#xA;    p_arg = p_arg;&#xA;    while (TRUE)&#xA;    {&#xA;        printf(&quot;&quot;);&#xA;        OS_Printf(&quot;\n\nthis is App_two,Delay 5 second and start again\n&quot;);&#xA;        printf(&quot;current prio=%d,OSPrioHighRdy=%d\n&quot;,OSPrioCur,OSPrioHighRdy);&#xA;        OS_Printf(&quot;suspend prio=30 task\n&quot;);&#xA;        OSTaskSuspend(10);&#xA;        //print_task_ready_tab();&#xA;        OSTimeDlyHMSM(0, 0, 1, 0);        &#xA;    }                                          &#xA;}&#xA;&#xA;&#xA;void App_three(void *p_arg)&#xA;{&#xA;    p_arg = p_arg;&#xA;    while (TRUE)&#xA;    {&#xA;        printf(&quot;&quot;);&#xA;        OS_Printf(&quot;\nthis is App_three, Delay 8 second and start again\n&quot;);&#xA;        printf(&quot;current prio=%d,OSPrioHighRdy=%d\n&quot;,OSPrioCur,OSPrioHighRdy);&#xA;        //print_task_ready_tab();&#xA;        //getchar();&#xA;        OSTimeDlyHMSM(0, 0, 3, 0);        &#xA;    }                                &#xA;}&#xA;&#xA;void print_task_ready_tab(void)&#xA;{&#xA;    int i;&#xA;    printf(&quot;OSRdyGrp=%u\n&quot;,OSRdyGrp);&#xA;    for(i=0; i&lt;8; i++)&#xA;        printf(&quot;OSRdyTbl[%d]=%d\n&quot;,i,OSRdyTbl[i]);&#xA;    printf(&quot;\n&quot;);&#xA;}"/>
    </Command>
    <Command cmdname="图形化数据分析(GDI、OpenGL)" cmdType="S" cmd="[S]数据发送区/C语言脚本编辑区，[F5]键发送/执行。">
      <Command cmdname="Font" cmdType="P" cmd="[P]#include &lt;windows.h&gt;		// Header File For Windows&#xA;#include &lt;stdio.h&gt;			// Header File For Standard Input/Output&#xA;#include &lt;gl\gl.h&gt;			// Header File For The OpenGL32 Library&#xA;#include &lt;gl\glu.h&gt;			// Header File For The GLu32 Library&#xA;#include &lt;gl\glaux.h&gt;		// Header File For The Glaux Library&#xA;#include&quot;libtcc1.c&quot;&#xA;#include&quot;math.h&quot;&#xA;&#xA;#define bool unsigned char&#xA;int closing=0;&#xA;// Private GDI Device Context&#xA;HGLRC		hRC=NULL;		// Permanent Rendering Context&#xA;HWND		hWnd=NULL;		// Holds Our Window Handle&#xA;HINSTANCE	hInstance;		// Holds The Instance Of The Application&#xA;&#xA;GLuint	base;				// Base Display List For The Font Set&#xA;GLfloat	cnt1;				// 1st Counter Used To Move Text &amp; For Coloring&#xA;GLfloat	cnt2;				// 2nd Counter Used To Move Text &amp; For Coloring&#xA;&#xA;bool	keys[256];			// Array Used For The Keyboard Routine&#xA;bool	active=TRUE;		// Window Active Flag Set To TRUE By Default&#xA;bool	fullscreen=TRUE;	// Fullscreen Flag Set To Fullscreen Mode By Default&#xA;&#xA;HGLRC hglrc;&#xA;HDC hdc;&#xA;int img;&#xA;int pnl;&#xA;int GuiMode=2,pfm;&#xA;void formcreate()&#xA;{&#xA;    hdc=GetDC(GetFormHandle(pfm));&#xA;    //hdc=(HANDLE)GetProperty(pnl,&quot;dc&quot;,0,0,0);&#xA;    int nPixelFormat;&#xA;    /* static PIXELFORMATDESCRIPTOR pfd=&#xA;     {&#xA;         sizeof(PIXELFORMATDESCRIPTOR),&#xA;         1,&#xA;         PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,&#xA;         PFD_TYPE_RGBA,&#xA;         24,&#xA;         0,0,0,0,0,&#xA;         0,0,&#xA;         0,0,0,0,0,&#xA;         32,&#xA;         0,&#xA;         0,&#xA;         PFD_MAIN_PLANE,&#xA;         0,&#xA;         0,0,0&#xA;     };*/&#xA;    static	PIXELFORMATDESCRIPTOR pfd=				// pfd Tells Windows How We Want Things To Be&#xA;    {&#xA;        sizeof(PIXELFORMATDESCRIPTOR),				// Size Of This Pixel Format Descriptor&#xA;        1,											// Version Number&#xA;        PFD_DRAW_TO_WINDOW |						// Format Must Support Window&#xA;        PFD_SUPPORT_OPENGL |						// Format Must Support OpenGL&#xA;        PFD_DOUBLEBUFFER,							// Must Support Double Buffering&#xA;        PFD_TYPE_RGBA,								// Request An RGBA Format&#xA;        24,										// Select Our Color Depth&#xA;        0, 0, 0, 0, 0, 0,							// Color Bits Ignored&#xA;        0,											// No Alpha Buffer&#xA;        0,											// Shift Bit Ignored&#xA;        0,											// No Accumulation Buffer&#xA;        0, 0, 0, 0,									// Accumulation Bits Ignored&#xA;        16,											// 16Bit Z-Buffer (Depth Buffer)&#xA;        0,											// No Stencil Buffer&#xA;        0,											// No Auxiliary Buffer&#xA;        PFD_MAIN_PLANE,								// Main Drawing Layer&#xA;        0,											// Reserved&#xA;        0, 0, 0										// Layer Masks Ignored&#xA;    };&#xA;&#xA;    nPixelFormat=ChoosePixelFormat(hdc,&amp;pfd);&#xA;    SetPixelFormat(hdc,nPixelFormat,&amp;pfd);&#xA;&#xA;    hglrc=wglCreateContext(hdc);&#xA;    wglMakeCurrent(hdc,hglrc);&#xA;}&#xA;//---------------------------------------------------------------------------&#xA;GLvoid KillFont(GLvoid)									// Delete The Font List&#xA;{&#xA;    glDeleteLists(base, 96);							// Delete All 96 Characters&#xA;}&#xA;void  FormDestroy()&#xA;{&#xA;    closing=1;&#xA;    Wait(1);&#xA;    wglMakeCurrent(NULL,NULL);&#xA;    wglDeleteContext(hglrc);&#xA;    DeleteObject(hdc);&#xA;&#xA;    printf(&quot;destroy&quot;);&#xA;}&#xA;&#xA;&#xA;void OnClose()&#xA;{&#xA;    closing=1;&#xA;    Wait(1);&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;    {&#xA;        ClearVclControls();&#xA;        HideVclWin(200);&#xA;    }&#xA;    else&#xA;    {&#xA;        CloseForm(pfm);&#xA;    }&#xA;}&#xA;GLvoid BuildFont(GLvoid)								// Build Our Bitmap Font&#xA;{&#xA;    HFONT	font;										// Windows Font ID&#xA;    HFONT	oldfont;									// Used For Good House Keeping&#xA;&#xA;    base = glGenLists(96);								// Storage For 96 Characters&#xA;&#xA;    font = CreateFont(	-24,							// Height Of Font&#xA;                        0,								// Width Of Font&#xA;                        0,								// Angle Of Escapement&#xA;                        0,								// Orientation Angle&#xA;                        FW_BOLD,						// Font Weight&#xA;                        FALSE,							// Italic&#xA;                        FALSE,							// Underline&#xA;                        FALSE,							// Strikeout&#xA;                        ANSI_CHARSET,					// Character Set Identifier&#xA;                        OUT_TT_PRECIS,					// Output Precision&#xA;                        CLIP_DEFAULT_PRECIS,			// Clipping Precision&#xA;                        ANTIALIASED_QUALITY,			// Output Quality&#xA;                        FF_DONTCARE|DEFAULT_PITCH,		// Family And Pitch&#xA;                        &quot;Courier New&quot;);					// Font Name&#xA;&#xA;    printf(&quot;font:%x&quot;,font);&#xA;    oldfont = (HFONT)SelectObject(hdc, font);           // Selects The Font We Want&#xA;    wglUseFontBitmaps(hdc, 32, 96, base);				// Builds 96 Characters Starting At Character 32&#xA;    SelectObject(hdc, oldfont);							// Selects The Font We Want&#xA;    DeleteObject(font);									// Delete The Font&#xA;}&#xA;&#xA;GLvoid KillFont(GLvoid)									// Delete The Font List&#xA;{&#xA;    glDeleteLists(base, 96);							// Delete All 96 Characters&#xA;}&#xA;&#xA;GLvoid glPrint(const char *fmt, ...)					// Custom GL &quot;Print&quot; Routine&#xA;{&#xA;    char		text[256];								// Holds Our String&#xA;    va_list		ap;										// Pointer To List Of Arguments&#xA;&#xA;    if (fmt == NULL)									// If There's No Text&#xA;        return;											// Do Nothing&#xA;&#xA;    va_start(ap, fmt);									// Parses The String For Variables&#xA;    vsprintf(text, fmt, ap);						// And Converts Symbols To Actual Numbers&#xA;    va_end(ap);											// Results Are Stored In Text&#xA;    //printf(text);&#xA;    glPushAttrib(GL_LIST_BIT);							// Pushes The Display List Bits&#xA;    glListBase(base - 32);								// Sets The Base Character to 32&#xA;    glCallLists(strlen(text), GL_UNSIGNED_BYTE, text);	// Draws The Display List Text&#xA;    glPopAttrib();										// Pops The Display List Bits&#xA;}&#xA;&#xA;GLvoid ReSizeGLScene(GLsizei width, GLsizei height)		// Resize And Initialize The GL Window&#xA;{&#xA;    if (height==0)										// Prevent A Divide By Zero By&#xA;    {&#xA;        height=1;										// Making Height Equal One&#xA;    }&#xA;&#xA;    glViewport(0,0,width,height);						// Reset The Current Viewport&#xA;&#xA;    glMatrixMode(GL_PROJECTION);						// Select The Projection Matrix&#xA;    glLoadIdentity();									// Reset The Projection Matrix&#xA;&#xA;    // Calculate The Aspect Ratio Of The Window&#xA;    gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f);&#xA;&#xA;    glMatrixMode(GL_MODELVIEW);							// Select The Modelview Matrix&#xA;    glLoadIdentity();									// Reset The Modelview Matrix&#xA;}&#xA;&#xA;int InitGL(GLvoid)										// All Setup For OpenGL Goes Here&#xA;{&#xA;    glShadeModel(GL_SMOOTH);							// Enable Smooth Shading&#xA;    glClearColor(0.0f, 0.0f, 0.0f, 0.5f);				// Black Background&#xA;    glClearDepth(1.0f);									// Depth Buffer Setup&#xA;    glEnable(GL_DEPTH_TEST);							// Enables Depth Testing&#xA;    glDepthFunc(GL_LEQUAL);								// The Type Of Depth Testing To Do&#xA;    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);	// Really Nice Perspective Calculations&#xA;&#xA;    BuildFont();										// Build The Font&#xA;&#xA;    return TRUE;										// Initialization Went OK&#xA;}&#xA;&#xA;int DrawGLScene(GLvoid)									// Here's Where We Do All The Drawing&#xA;{&#xA;    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear Screen And Depth Buffer&#xA;    glLoadIdentity();									// Reset The Current Modelview Matrix&#xA;    glTranslatef(0.0f,0.0f,-6.0f);						// Move One Unit Into The Screen&#xA;    // Pulsing Colors Based On Text Position&#xA;    glColor3f(1.0f ,1.0f ,1.0f );&#xA;    // Position The Text On The Screen&#xA;    glRasterPos2f(0, 0);&#xA;    glPrint(&quot;Active OpenGL Text With NeHe - &quot;);	// Print GL Text To The Screen&#xA;    cnt1+=0.051f;										// Increase The First Counter&#xA;    cnt2+=0.005f;&#xA;    SwapBuffers(hdc);										// Increase The First Counter&#xA;    return TRUE;										// Everything Went OK&#xA;}&#xA;&#xA;&#xA;void OnTimer()&#xA;{&#xA;    DrawGLScene();&#xA;}&#xA;&#xA;void OnTest()&#xA;{&#xA;    DrawGLScene();&#xA;}&#xA;void OnResize()&#xA;{&#xA;    int x,y;&#xA;    x=GetProperty(pfm,&quot;width&quot;,0,0);&#xA;    y=GetProperty(pfm,&quot;height&quot;,0,0);&#xA;    ReSizeGLScene(x,y);&#xA;}&#xA;&#xA;void main()&#xA;{&#xA;&#xA;    int i,j;&#xA;    int mi,mi1;&#xA;    //HideLeftTools();&#xA;    ClearVclControls();&#xA;    //ShowVclWin(-1);&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;        pfm=GetGuiWin(GuiMode);&#xA;    else&#xA;        pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;调幅-正弦波&quot;,&quot;Width&quot;,600,&quot;height&quot;,300,&quot;BorderIcons&quot;,&quot;[biSystemMenu,biMaximize]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnClose&quot;,FormDestroy,&quot;OnResize&quot;,OnResize,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;    int btn=CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);&#xA;    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;test&quot;,&quot;left&quot;,80,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnTest,0);&#xA;    //img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,200,&quot;height&quot;,200,0);&#xA;    SetProperty(pfm,&quot;visible&quot;,1);////&#xA;    formcreate();&#xA;    OnResize();&#xA;    InitGL();&#xA;    DrawGLScene();&#xA;&#xA;    int count=0;&#xA;    while(!closing)&#xA;    {&#xA;        DrawGLScene();&#xA;        count++;&#xA;        if(count%5==4)&#xA;        {&#xA;            Wait(1);&#xA;        }&#xA;&#xA;    }&#xA;    printf(&quot;exit&quot;);&#xA;&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;"/>
      <Command cmdname="粒子运动" cmdType="P" cmd="[P]#include &lt;windows.h&gt;		// Header File For Windows&#xA;#include &lt;stdio.h&gt;			// Header File For Standard Input/Output&#xA;#include &lt;gl\gl.h&gt;			// Header File For The OpenGL32 Library&#xA;#include &lt;gl\glu.h&gt;			// Header File For The GLu32 Library&#xA;#include &lt;gl\glaux.h&gt;		// Header File For The Glaux Library&#xA;#define bool unsigned char&#xA;HDC			hDC=NULL;		// Private GDI Device Context&#xA;HGLRC		hRC=NULL;		// Permanent Rendering Context&#xA;HWND		hWnd=NULL;		// Holds Our Window Handle&#xA;HINSTANCE	hInstance;		// Holds The Instance Of The Application&#xA;&#xA;bool	keys[256];			// Array Used For The Keyboard Routine&#xA;bool	active=TRUE;		// Window Active Flag Set To TRUE By Default&#xA;bool	fullscreen=TRUE;	// Fullscreen Flag Set To Fullscreen Mode By Default&#xA;&#xA;bool	twinkle;			// Twinkling Stars&#xA;bool	tp;					// 'T' Key Pressed?&#xA;bool closing=0;&#xA;#define	num 80 				// Number Of Stars To Draw&#xA;&#xA;typedef struct aaaa			// Create A Structure For Star&#xA;{&#xA;    int r, g, b;			// Stars Color&#xA;    GLfloat dist,			// Stars Distance From Center&#xA;            angle;			// Stars Current Angle&#xA;} stars;&#xA;stars star[num];			// Need To Keep Track Of 'num' Stars&#xA;&#xA;GLfloat	zoom=-15.0f;		// Distance Away From Stars&#xA;GLfloat tilt=90.0f;			// Tilt The View&#xA;GLfloat	spin;				// Spin Stars&#xA;&#xA;GLuint	loop;				// General Loop Variable&#xA;GLuint	texture[1];			// Storage For One textures&#xA;&#xA;LRESULT	CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);	// Declaration For WndProc&#xA;&#xA;HGLRC hglrc;&#xA;HDC hdc;&#xA;int img;&#xA;int pnl;&#xA;int GuiMode=2,pfm;&#xA;void formcreate()&#xA;{&#xA;    hdc=GetDC(GetFormHandle(pfm));&#xA;    //hdc=(HANDLE)GetProperty(pnl,&quot;dc&quot;,0,0,0);&#xA;    int nPixelFormat;&#xA;    static PIXELFORMATDESCRIPTOR pfd=&#xA;    {&#xA;        sizeof(PIXELFORMATDESCRIPTOR),&#xA;        1,&#xA;        PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,&#xA;        PFD_TYPE_RGBA,&#xA;        24,&#xA;        0,0,0,0,0,&#xA;        0,0,&#xA;        0,0,0,0,0,&#xA;        32,&#xA;        0,&#xA;        0,&#xA;        PFD_MAIN_PLANE,&#xA;        0,&#xA;        0,0,0&#xA;    };&#xA;    nPixelFormat=ChoosePixelFormat(hdc,&amp;pfd);&#xA;    SetPixelFormat(hdc,nPixelFormat,&amp;pfd);&#xA;&#xA;    hglrc=wglCreateContext(hdc);&#xA;    wglMakeCurrent(hdc,hglrc);&#xA;}&#xA;//---------------------------------------------------------------------------&#xA;&#xA;void  FormDestroy()&#xA;{&#xA;    closing=1;&#xA;    Wait(1);&#xA;    wglMakeCurrent(NULL,NULL);&#xA;    wglDeleteContext(hglrc);&#xA;    DeleteObject(hdc);&#xA;    printf(&quot;destroy&quot;);&#xA;}&#xA;&#xA;&#xA;void OnClose()&#xA;{&#xA;    closing=1;&#xA;    Wait(1);&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;    {&#xA;        ClearVclControls();&#xA;        HideVclWin(200);&#xA;    }&#xA;    else&#xA;    {&#xA;        CloseForm(pfm);&#xA;    }&#xA;}&#xA;&#xA;AUX_RGBImageRec *LoadBMP(char *Filename)                // Loads A Bitmap Image&#xA;{&#xA;    FILE *File=NULL;                                // File Handle&#xA;&#xA;    if (!Filename)                                  // Make Sure A Filename Was Given&#xA;    {&#xA;        return NULL;                            // If Not Return NULL&#xA;    }&#xA;&#xA;    File=fopen(Filename,&quot;r&quot;);                       // Check To See If The File Exists&#xA;&#xA;    if (File)                                       // Does The File Exist?&#xA;    {&#xA;        fclose(File);                           // Close The Handle&#xA;        return auxDIBImageLoad(Filename);       // Load The Bitmap And Return A Pointer&#xA;    }&#xA;    return NULL;                                    // If Load Failed Return NULL&#xA;}&#xA;&#xA;int LoadGLTextures()                                    // Load Bitmaps And Convert To Textures&#xA;{&#xA;    int Status=FALSE;                               // Status Indicator&#xA;&#xA;    AUX_RGBImageRec *TextureImage[1];               // Create Storage Space For The Texture&#xA;&#xA;    memset(TextureImage,0,sizeof(void *)*1);        // Set The Pointer To NULL&#xA;&#xA;    // Load The Bitmap, Check For Errors, If Bitmap's Not Found Quit&#xA;    if (TextureImage[0]=LoadBMP(&quot;dat/star.bmp&quot;))&#xA;    {&#xA;        Status=TRUE;                            // Set The Status To TRUE&#xA;&#xA;        glGenTextures(1, &amp;texture[0]);          // Create One Texture&#xA;&#xA;        // Create Linear Filtered Texture&#xA;        glBindTexture(GL_TEXTURE_2D, texture[0]);&#xA;        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);&#xA;        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);&#xA;        glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]-&gt;sizeX, TextureImage[0]-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]-&gt;data);&#xA;    }&#xA;    if (TextureImage[0])                            // If Texture Exists&#xA;    {&#xA;        if (TextureImage[0]-&gt;data)              // If Texture Image Exists&#xA;        {&#xA;            free(TextureImage[0]-&gt;data);    // Free The Texture Image Memory&#xA;        }&#xA;&#xA;        free(TextureImage[0]);                  // Free The Image Structure&#xA;    }&#xA;&#xA;    return Status;                                  // Return The Status&#xA;}&#xA;&#xA;GLvoid ReSizeGLScene(GLsizei width, GLsizei height)		// Resize And Initialize The GL Window&#xA;{&#xA;    if (height==0)										// Prevent A Divide By Zero By&#xA;    {&#xA;        height=1;										// Making Height Equal One&#xA;    }&#xA;&#xA;    glViewport(0,0,width,height);						// Reset The Current Viewport&#xA;&#xA;    glMatrixMode(GL_PROJECTION);						// Select The Projection Matrix&#xA;    glLoadIdentity();									// Reset The Projection Matrix&#xA;&#xA;    // Calculate The Aspect Ratio Of The Window&#xA;    gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f);&#xA;&#xA;    glMatrixMode(GL_MODELVIEW);							// Select The Modelview Matrix&#xA;    glLoadIdentity();									// Reset The Modelview Matrix&#xA;}&#xA;&#xA;int InitGL(GLvoid)										// All Setup For OpenGL Goes Here&#xA;{&#xA;    if (!LoadGLTextures())								// Jump To Texture Loading Routine&#xA;    {&#xA;        printf(&quot;LoadGLTextures error!&quot;);&#xA;        return FALSE;									// If Texture Didn't Load Return FALSE&#xA;    }&#xA;&#xA;    glEnable(GL_TEXTURE_2D);							// Enable Texture Mapping&#xA;    glShadeModel(GL_SMOOTH);							// Enable Smooth Shading&#xA;    glClearColor(0.0f, 0.0f, 0.0f, 0.5f);				// Black Background&#xA;    glClearDepth(1.0f);									// Depth Buffer Setup&#xA;    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);	// Really Nice Perspective Calculations&#xA;    glBlendFunc(GL_SRC_ALPHA,GL_ONE);					// Set The Blending Function For Translucency&#xA;    glEnable(GL_BLEND);&#xA;&#xA;    for (loop=0; loop&lt;num; loop++)&#xA;    {&#xA;        star[loop].angle=0.0f;&#xA;        star[loop].dist=( (loop*1.0)/num)*5.0f;&#xA;        star[loop].r=rand()%256;&#xA;        star[loop].g=rand()%256;&#xA;        star[loop].b=rand()%256;&#xA;    }&#xA;    return TRUE;										// Initialization Went OK&#xA;}&#xA;&#xA;int DrawGLScene(GLvoid)									// Here's Where We Do All The Drawing&#xA;{&#xA;    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear The Screen And The Depth Buffer&#xA;    glBindTexture(GL_TEXTURE_2D, texture[0]);			// Select Our Texture&#xA;&#xA;    for (loop=0; loop&lt;num; loop++)						// Loop Through All The Stars&#xA;    {&#xA;        glLoadIdentity();								// Reset The View Before We Draw Each Star&#xA;        glTranslatef(0.0f,0.0f,zoom);					// Zoom Into The Screen (Using The Value In 'zoom')&#xA;        glRotatef(tilt,1.0f,0.0f,0.0f);					// Tilt The View (Using The Value In 'tilt')&#xA;        glRotatef(star[loop].angle,0.0f,1.0f,0.0f);		// Rotate To The Current Stars Angle&#xA;        glTranslatef(star[loop].dist,0.0f,0.0f);		// Move Forward On The X Plane&#xA;        glRotatef(-star[loop].angle,0.0f,1.0f,0.0f);	// Cancel The Current Stars Angle&#xA;        glRotatef(-tilt,1.0f,0.0f,0.0f);				// Cancel The Screen Tilt&#xA;&#xA;        if (twinkle)&#xA;        {&#xA;            glColor4ub(star[(num-loop)-1].r,star[(num-loop)-1].g,star[(num-loop)-1].b,255);&#xA;            glBegin(GL_QUADS);&#xA;            glTexCoord2f(0.0f, 0.0f);&#xA;            glVertex3f(-1.0f,-1.0f, 0.0f);&#xA;            glTexCoord2f(1.0f, 0.0f);&#xA;            glVertex3f( 1.0f,-1.0f, 0.0f);&#xA;            glTexCoord2f(1.0f, 1.0f);&#xA;            glVertex3f( 1.0f, 1.0f, 0.0f);&#xA;            glTexCoord2f(0.0f, 1.0f);&#xA;            glVertex3f(-1.0f, 1.0f, 0.0f);&#xA;            glEnd();&#xA;        }&#xA;&#xA;        glRotatef(spin,0.0f,0.0f,1.0f);&#xA;        glColor4ub(star[loop].r,star[loop].g,star[loop].b,255);&#xA;        glBegin(GL_QUADS);&#xA;        glTexCoord2f(0.0f, 0.0f);&#xA;        glVertex3f(-1.0f,-1.0f, 0.0f);&#xA;        glTexCoord2f(1.0f, 0.0f);&#xA;        glVertex3f( 1.0f,-1.0f, 0.0f);&#xA;        glTexCoord2f(1.0f, 1.0f);&#xA;        glVertex3f( 1.0f, 1.0f, 0.0f);&#xA;        glTexCoord2f(0.0f, 1.0f);&#xA;        glVertex3f(-1.0f, 1.0f, 0.0f);&#xA;        glEnd();&#xA;&#xA;        spin+=0.01f;&#xA;        star[loop].angle+= (loop*1.0)/num;&#xA;        star[loop].dist-=0.01f;&#xA;        if (star[loop].dist&lt;0.0f)&#xA;        {&#xA;            star[loop].dist+=5.0f;&#xA;            star[loop].r=rand()%256;&#xA;            star[loop].g=rand()%256;&#xA;            star[loop].b=rand()%256;&#xA;        }&#xA;    }&#xA;    SwapBuffers(hdc);&#xA;    return TRUE;										// Everything Went OK&#xA;}&#xA;&#xA;void OnTimer()&#xA;{&#xA;    DrawGLScene();&#xA;}&#xA;&#xA;void OnTest()&#xA;{&#xA;    DrawGLScene();&#xA;}&#xA;&#xA;&#xA;void main()&#xA;{&#xA;&#xA;    int i,j;&#xA;    int mi,mi1;&#xA;    //HideLeftTools();&#xA;    ClearVclControls();&#xA;    ShowVclWin(-1);&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;    {&#xA;        pfm=GetGuiWin(GuiMode);&#xA;    }&#xA;    else&#xA;        pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;粒子运动&quot;,&quot;Width&quot;,660,&quot;height&quot;,370,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnDestroy&quot;,FormDestroy,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;    //CreateComponentEx(pfm,&quot;timer&quot;,&quot;interval&quot;,100,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮&#xA;    ////pnl=CreateComponentEx(pfm,&quot;panel&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,200,&quot;height&quot;,200,&quot;OnPaint&quot;,FormPaint,0);&#xA;    int btn=CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);&#xA;    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;test&quot;,&quot;left&quot;,80,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnTest,0);&#xA;    //img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,200,&quot;height&quot;,200,0);&#xA;    SetProperty(pfm,&quot;visible&quot;,1);////&#xA;    formcreate();&#xA;    ReSizeGLScene(660,370);&#xA;    InitGL();&#xA;    DrawGLScene();&#xA;&#xA;    int count=0;&#xA;    while(!closing)&#xA;    {&#xA;        DrawGLScene();&#xA;&#xA;        count++;&#xA;&#xA;        if(count%5==4)&#xA;        {&#xA;            //Invalidate(btn);&#xA;            Wait(1);&#xA;        }&#xA;&#xA;    }&#xA;&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;"/>
      <Command cmdname="正方体" cmdType="P" cmd="[P]#include &lt;windows.h&gt;		// Header File For Windows&#xA;#include &lt;stdio.h&gt;			// Header File For Standard Input/Output&#xA;#include &lt;gl\gl.h&gt;			// Header File For The OpenGL32 Library&#xA;#include &lt;gl\glu.h&gt;			// Header File For The GLu32 Library&#xA;#include &lt;gl\glaux.h&gt;		// Header File For The Glaux Library&#xA;#include&quot;libtcc1.c&quot;&#xA;#include&quot;math.h&quot;&#xA;&#xA;#define bool unsigned char&#xA;HDC			hDC=NULL;		// Private GDI Device Context&#xA;HGLRC		hRC=NULL;		// Permanent Rendering Context&#xA;HWND		hWnd=NULL;		// Holds Our Window Handle&#xA;HINSTANCE	hInstance;		// Holds The Instance Of The Application&#xA;&#xA;bool	keys[256];			// Array Used For The Keyboard Routine&#xA;bool	active=TRUE;		// Window Active Flag Set To TRUE By Default&#xA;bool	fullscreen=TRUE;	// Fullscreen Flag Set To Fullscreen Mode By Default&#xA;GLuint	base;&#xA;bool	twinkle;			// Twinkling Stars&#xA;bool	tp;					// 'T' Key Pressed?&#xA;bool closing=0;&#xA;#define	num 360 				// Number Of Stars To Draw&#xA;GLfloat	cnt1=0.0f;				// 1st Counter Used To Move Text &amp; For Coloring&#xA;GLfloat	cnt2=0.0f;				// 2nd Counter Used To Move Text &amp; For Coloring&#xA;GLfloat	xrot;				// X Rotation ( NEW )&#xA;GLfloat	yrot;				// Y Rotation ( NEW )&#xA;GLfloat	zrot;				// Z Rotation ( NEW )&#xA;typedef struct aaaa			// Create A Structure For Star&#xA;{&#xA;    int r, g, b;			// Stars Color&#xA;    GLfloat dist,			// Stars Distance From Center&#xA;            angle;			// Stars Current Angle&#xA;} stars;&#xA;stars star[num];			// Need To Keep Track Of 'num' Stars&#xA;&#xA;GLfloat	zoom=-15.0f;		// Distance Away From Stars&#xA;GLfloat tilt=90.0f;			// Tilt The View&#xA;GLfloat	spin;				// Spin Stars&#xA;&#xA;GLuint	loop;				// General Loop Variable&#xA;GLuint	texture[1];			// Storage For One textures&#xA;&#xA;LRESULT	CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);	// Declaration For WndProc&#xA;&#xA;HGLRC hglrc;&#xA;HDC hdc;&#xA;int img;&#xA;int pnl;&#xA;int GuiMode=2,pfm;&#xA;void formcreate()&#xA;{&#xA;    hdc=GetDC(GetFormHandle(pfm));&#xA;    //hdc=(HANDLE)GetProperty(pnl,&quot;dc&quot;,0,0,0);&#xA;    int nPixelFormat;&#xA;    static PIXELFORMATDESCRIPTOR pfd=&#xA;    {&#xA;        sizeof(PIXELFORMATDESCRIPTOR),&#xA;        1,&#xA;        PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,&#xA;        PFD_TYPE_RGBA,&#xA;        24,&#xA;        0,0,0,0,0,&#xA;        0,0,&#xA;        0,0,0,0,0,&#xA;        32,&#xA;        0,&#xA;        0,&#xA;        PFD_MAIN_PLANE,&#xA;        0,&#xA;        0,0,0&#xA;    };&#xA;    nPixelFormat=ChoosePixelFormat(hdc,&amp;pfd);&#xA;    SetPixelFormat(hdc,nPixelFormat,&amp;pfd);&#xA;&#xA;    hglrc=wglCreateContext(hdc);&#xA;    wglMakeCurrent(hdc,hglrc);&#xA;}&#xA;//---------------------------------------------------------------------------&#xA;GLvoid KillFont(GLvoid)									// Delete The Font List&#xA;{&#xA;    glDeleteLists(base, 96);							// Delete All 96 Characters&#xA;}&#xA;void  FormDestroy()&#xA;{&#xA;    closing=1;&#xA;    Wait(1);&#xA;    wglMakeCurrent(NULL,NULL);&#xA;    wglDeleteContext(hglrc);&#xA;    DeleteObject(hdc);&#xA;&#xA;    printf(&quot;destroy&quot;);&#xA;}&#xA;&#xA;&#xA;void OnClose()&#xA;{&#xA;    closing=1;&#xA;    Wait(1);&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;    {&#xA;        ClearVclControls();&#xA;        HideVclWin(200);&#xA;    }&#xA;    else&#xA;    {&#xA;        CloseForm(pfm);&#xA;    }&#xA;}&#xA;GLvoid BuildFont(GLvoid)								// Build Our Bitmap Font&#xA;{&#xA;    HFONT	font;										// Windows Font ID&#xA;    HFONT	oldfont;									// Used For Good House Keeping&#xA;&#xA;    base = glGenLists(96);								// Storage For 96 Characters&#xA;&#xA;    font = CreateFont(	-24,							// Height Of Font&#xA;                        0,								// Width Of Font&#xA;                        0,								// Angle Of Escapement&#xA;                        0,								// Orientation Angle&#xA;                        FW_BOLD,						// Font Weight&#xA;                        FALSE,							// Italic&#xA;                        FALSE,							// Underline&#xA;                        FALSE,							// Strikeout&#xA;                        ANSI_CHARSET,					// Character Set Identifier&#xA;                        OUT_TT_PRECIS,					// Output Precision&#xA;                        CLIP_DEFAULT_PRECIS,			// Clipping Precision&#xA;                        ANTIALIASED_QUALITY,			// Output Quality&#xA;                        FF_DONTCARE|DEFAULT_PITCH,		// Family And Pitch&#xA;                        &quot;Courier New&quot;);					// Font Name&#xA;&#xA;    oldfont = (HFONT)SelectObject(hDC, font);           // Selects The Font We Want&#xA;    wglUseFontBitmaps(hDC, 32, 96, base);				// Builds 96 Characters Starting At Character 32&#xA;    SelectObject(hDC, oldfont);							// Selects The Font We Want&#xA;    DeleteObject(font);									// Delete The Font&#xA;}&#xA;&#xA;&#xA;&#xA;GLvoid glPrint(const char *fmt, ...)					// Custom GL &quot;Print&quot; Routine&#xA;{&#xA;    char		text[256];								// Holds Our String&#xA;    va_list		ap;										// Pointer To List Of Arguments&#xA;&#xA;    if (fmt == NULL)									// If There's No Text&#xA;        return;											// Do Nothing&#xA;&#xA;    va_start(ap, fmt);									// Parses The String For Variables&#xA;    vsprintf(text, fmt, ap);						// And Converts Symbols To Actual Numbers&#xA;    va_end(ap);											// Results Are Stored In Text&#xA;&#xA;    glPushAttrib(GL_LIST_BIT);							// Pushes The Display List Bits&#xA;    glListBase(base - 32);								// Sets The Base Character to 32&#xA;    glCallLists(strlen(text), GL_UNSIGNED_BYTE, text);	// Draws The Display List Text&#xA;    glPopAttrib();										// Pops The Display List Bits&#xA;}&#xA;&#xA;AUX_RGBImageRec *LoadBMP(char *Filename)                // Loads A Bitmap Image&#xA;{&#xA;    FILE *File=NULL;                                // File Handle&#xA;&#xA;    if (!Filename)                                  // Make Sure A Filename Was Given&#xA;    {&#xA;        return NULL;                            // If Not Return NULL&#xA;    }&#xA;&#xA;    File=fopen(Filename,&quot;r&quot;);                       // Check To See If The File Exists&#xA;&#xA;    if (File)                                       // Does The File Exist?&#xA;    {&#xA;        fclose(File);                           // Close The Handle&#xA;        return auxDIBImageLoad(Filename);       // Load The Bitmap And Return A Pointer&#xA;    }&#xA;    return NULL;                                    // If Load Failed Return NULL&#xA;}&#xA;&#xA;int LoadGLTextures1()                                    // Load Bitmaps And Convert To Textures&#xA;{&#xA;    int Status=FALSE;                               // Status Indicator&#xA;&#xA;    AUX_RGBImageRec *TextureImage[1];               // Create Storage Space For The Texture&#xA;&#xA;    memset(TextureImage,0,sizeof(void *)*1);        // Set The Pointer To NULL&#xA;&#xA;    // Load The Bitmap, Check For Errors, If Bitmap's Not Found Quit&#xA;    if (TextureImage[0]=LoadBMP(&quot;dat\\mf.BMP&quot;))&#xA;    {&#xA;        Status=TRUE;                            // Set The Status To TRUE&#xA;&#xA;        glGenTextures(1, &amp;texture[0]);          // Create One Texture&#xA;&#xA;        // Create Linear Filtered Texture&#xA;        glBindTexture(GL_TEXTURE_2D, texture[0]);&#xA;        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);&#xA;        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);&#xA;        glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]-&gt;sizeX, TextureImage[0]-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]-&gt;data);&#xA;    }&#xA;    if (TextureImage[0])                            // If Texture Exists&#xA;    {&#xA;        if (TextureImage[0]-&gt;data)              // If Texture Image Exists&#xA;        {&#xA;            free(TextureImage[0]-&gt;data);    // Free The Texture Image Memory&#xA;        }&#xA;&#xA;        free(TextureImage[0]);                  // Free The Image Structure&#xA;    }&#xA;&#xA;    return Status;                                  // Return The Status&#xA;}&#xA;int LoadGLTextures()									// Load Bitmaps And Convert To Textures&#xA;{&#xA;    int Status=FALSE;									// Status Indicator&#xA;&#xA;    AUX_RGBImageRec *TextureImage[1];					// Create Storage Space For The Texture&#xA;&#xA;    memset(TextureImage,0,sizeof(void *)*1);           	// Set The Pointer To NULL&#xA;&#xA;    // Load The Bitmap, Check For Errors, If Bitmap's Not Found Quit&#xA;    if (TextureImage[0]=LoadBMP(&quot;dat\\mf.BMP&quot;))&#xA;    {&#xA;        Status=TRUE;									// Set The Status To TRUE&#xA;&#xA;        glGenTextures(1, &amp;texture[0]);					// Create The Texture&#xA;&#xA;        // Typical Texture Generation Using Data From The Bitmap&#xA;        glBindTexture(GL_TEXTURE_2D, texture[0]);&#xA;        glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]-&gt;sizeX, TextureImage[0]-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]-&gt;data);&#xA;        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);&#xA;        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);&#xA;    }&#xA;    else&#xA;        printf(&quot;load bmp error&quot;);&#xA;&#xA;    if (TextureImage[0])									// If Texture Exists&#xA;    {&#xA;        if (TextureImage[0]-&gt;data)							// If Texture Image Exists&#xA;        {&#xA;            free(TextureImage[0]-&gt;data);					// Free The Texture Image Memory&#xA;        }&#xA;&#xA;        free(TextureImage[0]);								// Free The Image Structure&#xA;    }&#xA;&#xA;    return Status;										// Return The Status&#xA;}&#xA;&#xA;&#xA;GLvoid ReSizeGLScene(GLsizei width, GLsizei height)		// Resize And Initialize The GL Window&#xA;{&#xA;    if (height==0)										// Prevent A Divide By Zero By&#xA;    {&#xA;        height=1;										// Making Height Equal One&#xA;    }&#xA;&#xA;    glViewport(0,0,width,height);						// Reset The Current Viewport&#xA;&#xA;    glMatrixMode(GL_PROJECTION);						// Select The Projection Matrix&#xA;    glLoadIdentity();									// Reset The Projection Matrix&#xA;&#xA;    // Calculate The Aspect Ratio Of The Window&#xA;    gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f);&#xA;&#xA;    glMatrixMode(GL_MODELVIEW);							// Select The Modelview Matrix&#xA;    glLoadIdentity();									// Reset The Modelview Matrix&#xA;}&#xA;int InitGL(GLvoid)										// All Setup For OpenGL Goes Here&#xA;{&#xA;    if (!LoadGLTextures())								// Jump To Texture Loading Routine ( NEW )&#xA;    {&#xA;        return FALSE;									// If Texture Didn't Load Return FALSE&#xA;    }&#xA;&#xA;    glEnable(GL_TEXTURE_2D);							// Enable Texture Mapping ( NEW )&#xA;    glShadeModel(GL_SMOOTH);							// Enable Smooth Shading&#xA;    glClearColor(0.0f, 0.0f, 0.0f, 0.5f);				// Black Background&#xA;    glClearDepth(1.0f);									// Depth Buffer Setup&#xA;    glEnable(GL_DEPTH_TEST);							// Enables Depth Testing&#xA;    glDepthFunc(GL_LEQUAL);								// The Type Of Depth Testing To Do&#xA;    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);	// Really Nice Perspective Calculations&#xA;    return TRUE;										// Initialization Went OK&#xA;}&#xA;&#xA;unsigned int Start=0;&#xA;int DrawGLScene1(GLvoid)									// Here's Where We Do All The Drawing&#xA;{&#xA;    int i;&#xA;    if(closing) return 0;&#xA;    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear The Screen And The Depth Buffer&#xA;    glBindTexture(GL_TEXTURE_2D, texture[0]);			// Select Our Texture&#xA;    Start+=1;&#xA;    Start%=720;&#xA;&#xA;    glEnable(GL_LINE_SMOOTH);&#xA;    glDisable(GL_TEXTURE_2D);&#xA;&#xA;    for(i=1; i&lt;5; i++)&#xA;    {&#xA;        glLoadIdentity();	//&#xA;        glTranslatef(-12.5f,3.0f,-22.0f );&#xA;        glLineWidth(1.2f*(5-i));							// 设置线宽为2.0f&#xA;        glColor4f(0.0f,1.0f,0.0f,0.10f*i);&#xA;        glBegin(GL_LINE_STRIP );				// 绘制当前的线段&#xA;        for (loop=0; loop&lt;num; loop++)						// Loop Through All The Stars&#xA;        {&#xA;            // glVertex3f((loop+0)*0.3-22,5.0*sin(3.14*4.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))*sin(3.14f*4*loop/num)+6,zoom*2);&#xA;            glVertex3f((loop+0)*0.2-22,5.0*sin(3.14*3.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))*sin(3.14*3.0*Start/360.0+3.14f*3*loop/num)+6,zoom*2);&#xA;        }&#xA;        glEnd();&#xA;        glBegin(GL_LINE_STRIP );				// 绘制当前的线段&#xA;        for (loop=0; loop&lt;num; loop+=1)						// Loop Through All The Stars&#xA;        {&#xA;            glVertex3f((loop+0)*0.2-22,5.0*sin(3.14*3.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))-6,zoom*2);&#xA;        }&#xA;        glEnd();&#xA;        glColor4f(1.0f,0.0f,1.0f,0.10f*i);&#xA;        glBegin(GL_LINE_STRIP );				// 绘制当前的线段&#xA;        for (loop=0; loop&lt;num; loop+=4)						// Loop Through All The Stars&#xA;        {&#xA;            glVertex3f((loop+0)*0.2-22,2.0*sin(3.14f*6*loop/num)-18,zoom*2);&#xA;        }&#xA;        glEnd();&#xA;&#xA;    }&#xA;&#xA;&#xA;&#xA;    glEnable(GL_TEXTURE_2D);&#xA;&#xA;    glLoadIdentity();	//							// Reset The View Before We Draw Each Star&#xA;    glTranslatef(-1.5f,0.0f,-6.0f);&#xA;    glColor4ub(0,150,0,255);&#xA;    for(i=0; i&lt;5; i++)&#xA;    {&#xA;        glBegin(GL_QUADS);&#xA;        glTexCoord2f(0.0f, 0.0f);&#xA;        glVertex3f(-20.0f,-0.0f+i*1.0-2, 0.0f);&#xA;        glTexCoord2f(1.0f, 0.0f);&#xA;        glVertex3f( 25.0f,-0.0f+i*1.0-2, 0.0f);&#xA;        glTexCoord2f(1.0f, 1.0f);&#xA;        glVertex3f( 25.0f, 0.1f+i*1.0-2, 0.0f);&#xA;        glTexCoord2f(0.0f, 1.0f);&#xA;        glVertex3f(-20.0f, 0.1f+i*1.0-2, 0.0f);&#xA;        glEnd();&#xA;    }&#xA;&#xA;    glLoadIdentity();	//							// Reset The View Before We Draw Each Star&#xA;    glTranslatef(-2.5f,0.0f,-6.0f);&#xA;    glColor4ub(0,150,0,255);&#xA;    for(i=0; i&lt;10; i++)&#xA;    {&#xA;        glBegin(GL_QUADS);&#xA;        glTexCoord2f(0.0f, 0.0f);&#xA;        glVertex3f(-1.5f+i*1.0,-10.0f, 0.0f);&#xA;        glTexCoord2f(1.0f, 0.0f);&#xA;        glVertex3f( -1.6f+i*1.0,-10.0f, 0.0f);&#xA;        glTexCoord2f(1.0f, 1.0f);&#xA;        glVertex3f( -1.6f+i*1.0, 10.1f, 0.0f);&#xA;        glTexCoord2f(0.0f, 1.0f);&#xA;        glVertex3f(-1.5f+i*1.0, 10.1f, 0.0f);&#xA;        glEnd();&#xA;    }&#xA;&#xA;    SwapBuffers(hdc);&#xA;    return TRUE;										// Everything Went OK&#xA;}&#xA;int DrawGLScene(GLvoid)									// Here's Where We Do All The Drawing&#xA;{&#xA;    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear The Screen And The Depth Buffer&#xA;    glLoadIdentity();									// Reset The View&#xA;    glTranslatef(0.0f,-0.2f,-5.0f);&#xA;&#xA;    glRotatef(xrot,1.0f,0.0f,0.0f);&#xA;    glRotatef(yrot,0.0f,1.0f,0.0f);&#xA;    glRotatef(zrot,0.0f,0.0f,1.0f);&#xA;&#xA;    glBindTexture(GL_TEXTURE_2D, texture[0]);&#xA;&#xA;    glBegin(GL_QUADS);&#xA;    // Front Face&#xA;    glTexCoord2f(0.0f, 0.0f);&#xA;    glVertex3f(-1.0f, -1.0f,  1.0f);&#xA;    glTexCoord2f(1.0f, 0.0f);&#xA;    glVertex3f( 1.0f, -1.0f,  1.0f);&#xA;    glTexCoord2f(1.0f, 1.0f);&#xA;    glVertex3f( 1.0f,  1.0f,  1.0f);&#xA;    glTexCoord2f(0.0f, 1.0f);&#xA;    glVertex3f(-1.0f,  1.0f,  1.0f);&#xA;    // Back Face&#xA;    glTexCoord2f(1.0f, 0.0f);&#xA;    glVertex3f(-1.0f, -1.0f, -1.0f);&#xA;    glTexCoord2f(1.0f, 1.0f);&#xA;    glVertex3f(-1.0f,  1.0f, -1.0f);&#xA;    glTexCoord2f(0.0f, 1.0f);&#xA;    glVertex3f( 1.0f,  1.0f, -1.0f);&#xA;    glTexCoord2f(0.0f, 0.0f);&#xA;    glVertex3f( 1.0f, -1.0f, -1.0f);&#xA;    // Top Face&#xA;    glTexCoord2f(0.0f, 1.0f);&#xA;    glVertex3f(-1.0f,  1.0f, -1.0f);&#xA;    glTexCoord2f(0.0f, 0.0f);&#xA;    glVertex3f(-1.0f,  1.0f,  1.0f);&#xA;    glTexCoord2f(1.0f, 0.0f);&#xA;    glVertex3f( 1.0f,  1.0f,  1.0f);&#xA;    glTexCoord2f(1.0f, 1.0f);&#xA;    glVertex3f( 1.0f,  1.0f, -1.0f);&#xA;    // Bottom Face&#xA;    glTexCoord2f(1.0f, 1.0f);&#xA;    glVertex3f(-1.0f, -1.0f, -1.0f);&#xA;    glTexCoord2f(0.0f, 1.0f);&#xA;    glVertex3f( 1.0f, -1.0f, -1.0f);&#xA;    glTexCoord2f(0.0f, 0.0f);&#xA;    glVertex3f( 1.0f, -1.0f,  1.0f);&#xA;    glTexCoord2f(1.0f, 0.0f);&#xA;    glVertex3f(-1.0f, -1.0f,  1.0f);&#xA;    // Right face&#xA;    glTexCoord2f(1.0f, 0.0f);&#xA;    glVertex3f( 1.0f, -1.0f, -1.0f);&#xA;    glTexCoord2f(1.0f, 1.0f);&#xA;    glVertex3f( 1.0f,  1.0f, -1.0f);&#xA;    glTexCoord2f(0.0f, 1.0f);&#xA;    glVertex3f( 1.0f,  1.0f,  1.0f);&#xA;    glTexCoord2f(0.0f, 0.0f);&#xA;    glVertex3f( 1.0f, -1.0f,  1.0f);&#xA;    // Left Face&#xA;    glTexCoord2f(0.0f, 0.0f);&#xA;    glVertex3f(-1.0f, -1.0f, -1.0f);&#xA;    glTexCoord2f(1.0f, 0.0f);&#xA;    glVertex3f(-1.0f, -1.0f,  1.0f);&#xA;    glTexCoord2f(1.0f, 1.0f);&#xA;    glVertex3f(-1.0f,  1.0f,  1.0f);&#xA;    glTexCoord2f(0.0f, 1.0f);&#xA;    glVertex3f(-1.0f,  1.0f, -1.0f);&#xA;    glEnd();&#xA;&#xA;    xrot+=0.3f;&#xA;    yrot+=0.2f;&#xA;    zrot+=0.4f;&#xA;    SwapBuffers(hdc);&#xA;    return TRUE;										// Keep Going&#xA;}&#xA;&#xA;&#xA;void OnTimer()&#xA;{&#xA;    DrawGLScene();&#xA;}&#xA;&#xA;void OnTest()&#xA;{&#xA;    DrawGLScene();&#xA;}&#xA;void OnResize()&#xA;{&#xA;    int x,y;&#xA;    x=GetProperty(pfm,&quot;width&quot;,0,0);&#xA;    y=GetProperty(pfm,&quot;height&quot;,0,0);&#xA;    ReSizeGLScene(x,y);&#xA;}&#xA;&#xA;void main()&#xA;{&#xA;&#xA;    int i,j;&#xA;    int mi,mi1;&#xA;    //HideLeftTools();&#xA;    ClearVclControls();&#xA;    HideVclWin(-1);&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;        pfm=GetGuiWin(GuiMode);&#xA;    else&#xA;        pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;正方体&quot;,&quot;Width&quot;,300,&quot;height&quot;,340,&quot;BorderIcons&quot;,&quot;[biSystemMenu,biMaximize]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnClose&quot;,FormDestroy,&quot;OnResize&quot;,OnResize,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;    int btn=CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);&#xA;    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;test&quot;,&quot;left&quot;,80,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnTest,0);&#xA;    //img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,200,&quot;height&quot;,200,0);&#xA;    SetProperty(pfm,&quot;visible&quot;,1);////&#xA;    formcreate();&#xA;    OnResize();&#xA;    InitGL();&#xA;    DrawGLScene();&#xA;&#xA;    int count=0;&#xA;    while(!closing)&#xA;    {&#xA;        DrawGLScene();&#xA;        count++;&#xA;        if(count%2==1)&#xA;        {&#xA;            Wait(5);&#xA;        }&#xA;&#xA;    }&#xA;    printf(&quot;exit&quot;);&#xA;&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;"/>
      <Command cmdname="OpenGL例子1" cmdType="P" cmd="[P]#include &lt;windows.h&gt;		// Header File For Windows&#xA;#include &lt;stdio.h&gt;			// Header File For Standard Input/Output&#xA;#include &lt;gl\gl.h&gt;			// Header File For The OpenGL32 Library&#xA;#include &lt;gl\glu.h&gt;			// Header File For The GLu32 Library&#xA;#include &lt;gl\glaux.h&gt;		// Header File For The Glaux Library&#xA;//#include&quot;libtcc1.c&quot;&#xA;#include&quot;math.h&quot;&#xA;&#xA;#define bool unsigned char&#xA;int closing=0;&#xA;// Private GDI Device Context&#xA;HGLRC		hRC=NULL;		// Permanent Rendering Context&#xA;HWND		hWnd=NULL;		// Holds Our Window Handle&#xA;HINSTANCE	hInstance;		// Holds The Instance Of The Application&#xA;&#xA;GLuint	base;				// Base Display List For The Font Set&#xA;GLfloat	cnt1;				// 1st Counter Used To Move Text &amp; For Coloring&#xA;GLfloat	cnt2;				// 2nd Counter Used To Move Text &amp; For Coloring&#xA;&#xA;bool	keys[256];			// Array Used For The Keyboard Routine&#xA;bool	active=TRUE;		// Window Active Flag Set To TRUE By Default&#xA;bool	fullscreen=TRUE;	// Fullscreen Flag Set To Fullscreen Mode By Default&#xA;int   ElapsedTime, AppStart, LastTime  ;  // Timing variables&#xA;HGLRC hglrc;&#xA;HDC hdc;&#xA;int img;&#xA;int pnl;&#xA;int GuiMode=2,pfm;&#xA;int *ft;&#xA;void formcreate()&#xA;{&#xA;    hdc=GetDC(GetFormHandle(pfm));&#xA;    //hdc=(HANDLE)GetProperty(pnl,&quot;dc&quot;,0,0,0);&#xA;    int nPixelFormat;&#xA;    /* static PIXELFORMATDESCRIPTOR pfd=&#xA;     {&#xA;         sizeof(PIXELFORMATDESCRIPTOR),&#xA;         1,&#xA;         PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,&#xA;         PFD_TYPE_RGBA,&#xA;         24,&#xA;         0,0,0,0,0,&#xA;         0,0,&#xA;         0,0,0,0,0,&#xA;         32,&#xA;         0,&#xA;         0,&#xA;         PFD_MAIN_PLANE,&#xA;         0,&#xA;         0,0,0&#xA;     };*/&#xA;    static	PIXELFORMATDESCRIPTOR pfd=				// pfd Tells Windows How We Want Things To Be&#xA;    {&#xA;        sizeof(PIXELFORMATDESCRIPTOR),				// Size Of This Pixel Format Descriptor&#xA;        1,											// Version Number&#xA;        PFD_DRAW_TO_WINDOW |						// Format Must Support Window&#xA;        PFD_SUPPORT_OPENGL |						// Format Must Support OpenGL&#xA;        PFD_DOUBLEBUFFER,							// Must Support Double Buffering&#xA;        PFD_TYPE_RGBA,								// Request An RGBA Format&#xA;        24,										// Select Our Color Depth&#xA;        0, 0, 0, 0, 0, 0,							// Color Bits Ignored&#xA;        0,											// No Alpha Buffer&#xA;        0,											// Shift Bit Ignored&#xA;        0,											// No Accumulation Buffer&#xA;        0, 0, 0, 0,									// Accumulation Bits Ignored&#xA;        16,											// 16Bit Z-Buffer (Depth Buffer)&#xA;        0,											// No Stencil Buffer&#xA;        0,											// No Auxiliary Buffer&#xA;        PFD_MAIN_PLANE,								// Main Drawing Layer&#xA;        0,											// Reserved&#xA;        0, 0, 0										// Layer Masks Ignored&#xA;    };&#xA;&#xA;    nPixelFormat=ChoosePixelFormat(hdc,&amp;pfd);&#xA;    SetPixelFormat(hdc,nPixelFormat,&amp;pfd);&#xA;&#xA;    hglrc=wglCreateContext(hdc);&#xA;    wglMakeCurrent(hdc,hglrc);&#xA;}&#xA;//---------------------------------------------------------------------------&#xA;GLvoid KillFont(GLvoid)									// Delete The Font List&#xA;{&#xA;    glDeleteLists(base, 96);							// Delete All 96 Characters&#xA;}&#xA;void  FormDestroy()&#xA;{&#xA;    closing=1;&#xA;    Wait(1);&#xA;    wglMakeCurrent(NULL,NULL);&#xA;    wglDeleteContext(hglrc);&#xA;    DeleteObject(hdc);&#xA;&#xA;    printf(&quot;destroy&quot;);&#xA;}&#xA;&#xA;&#xA;void OnClose()&#xA;{&#xA;    closing=1;&#xA;    Wait(1);&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;    {&#xA;        ClearVclControls();&#xA;        HideVclWin(200);&#xA;    }&#xA;    else&#xA;    {&#xA;        CloseForm(pfm);&#xA;    }&#xA;}&#xA;GLvoid BuildFont(GLvoid)								// Build Our Bitmap Font&#xA;{&#xA;    HFONT	font;										// Windows Font ID&#xA;    HFONT	oldfont;									// Used For Good House Keeping&#xA;&#xA;    base = glGenLists(96);								// Storage For 96 Characters&#xA;&#xA;    font = CreateFont(	-24,							// Height Of Font&#xA;                        0,								// Width Of Font&#xA;                        0,								// Angle Of Escapement&#xA;                        0,								// Orientation Angle&#xA;                        FW_BOLD,						// Font Weight&#xA;                        FALSE,							// Italic&#xA;                        FALSE,							// Underline&#xA;                        FALSE,							// Strikeout&#xA;                        ANSI_CHARSET,					// Character Set Identifier&#xA;                        OUT_TT_PRECIS,					// Output Precision&#xA;                        CLIP_DEFAULT_PRECIS,			// Clipping Precision&#xA;                        ANTIALIASED_QUALITY,			// Output Quality&#xA;                        FF_DONTCARE|DEFAULT_PITCH,		// Family And Pitch&#xA;                        &quot;Courier New&quot;);					// Font Name&#xA;&#xA;    printf(&quot;font:%x&quot;,font);&#xA;    oldfont = (HFONT)SelectObject(hdc, font);           // Selects The Font We Want&#xA;    wglUseFontBitmaps(hdc, 32, 96, base);				// Builds 96 Characters Starting At Character 32&#xA;    SelectObject(hdc, oldfont);							// Selects The Font We Want&#xA;    DeleteObject(font);									// Delete The Font&#xA;}&#xA;&#xA;GLvoid KillFont(GLvoid)									// Delete The Font List&#xA;{&#xA;    glDeleteLists(base, 96);							// Delete All 96 Characters&#xA;}&#xA;void DrawLine(double x0,double y0,double x1,double y1)&#xA;{&#xA;    glBegin(GL_LINES);&#xA;    glVertex3f(x0,y0, 0.0f);&#xA;    glVertex3f(x1,y1, 0.0f);&#xA;    glEnd();&#xA;}&#xA;&#xA;GLvoid glPrint(const char *fmt, ...)					// Custom GL &quot;Print&quot; Routine&#xA;{&#xA;    char		text[256];								// Holds Our String&#xA;    va_list		ap;										// Pointer To List Of Arguments&#xA;&#xA;    if (fmt == NULL)									// If There's No Text&#xA;        return;											// Do Nothing&#xA;&#xA;    va_start(ap, fmt);									// Parses The String For Variables&#xA;    vsprintf(text, fmt, ap);						// And Converts Symbols To Actual Numbers&#xA;    va_end(ap);											// Results Are Stored In Text&#xA;    //printf(text);&#xA;    glPushAttrib(GL_LIST_BIT);							// Pushes The Display List Bits&#xA;    glListBase(base - 32);								// Sets The Base Character to 32&#xA;    glCallLists(strlen(text), GL_UNSIGNED_BYTE, text);	// Draws The Display List Text&#xA;    glPopAttrib();										// Pops The Display List Bits&#xA;}&#xA;&#xA;GLvoid ReSizeGLScene(GLsizei width, GLsizei height)		// Resize And Initialize The GL Window&#xA;{&#xA;    if (height==0)										// Prevent A Divide By Zero By&#xA;    {&#xA;        height=1;										// Making Height Equal One&#xA;    }&#xA;&#xA;    glViewport(0,0,width,height);						// Reset The Current Viewport&#xA;&#xA;    glMatrixMode(GL_PROJECTION);						// Select The Projection Matrix&#xA;    glLoadIdentity();									// Reset The Projection Matrix&#xA;&#xA;    // Calculate The Aspect Ratio Of The Window&#xA;    gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f);&#xA;&#xA;    glMatrixMode(GL_MODELVIEW);							// Select The Modelview Matrix&#xA;    glLoadIdentity();									// Reset The Modelview Matrix&#xA;}&#xA;#define FT_ENC_TAG( value, a, b, c, d )         \&#xA;          unsigned int value = ( ( (int)(a) &lt;&lt; 24 ) |  \&#xA;                    ( (int)(b) &lt;&lt; 16 ) |  \&#xA;                    ( (int)(c) &lt;&lt;  8 ) |  \&#xA;                      (int)(d)         )&#xA;&#xA;&#xA;FT_ENC_TAG( FT_ENCODING_UNICODE,   'u', 'n', 'i', 'c' );&#xA;&#xA;int InitGL(GLvoid)										// All Setup For OpenGL Goes Here&#xA;{&#xA;    int r;&#xA;    glShadeModel(GL_SMOOTH);							// Enable Smooth Shading&#xA;    glClearColor(0.0f, 0.0f, 0.0f, 0.5f);				// Black Background&#xA;    glClearDepth(1.0f);									// Depth Buffer Setup&#xA;    glEnable(GL_DEPTH_TEST);							// Enables Depth Testing&#xA;    glDepthFunc(GL_LEQUAL);								// The Type Of Depth Testing To Do&#xA;    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);	// Really Nice Perspective Calculations&#xA;&#xA;    BuildFont();										// Build The Font&#xA;&#xA;&#xA;    return TRUE;										// Initialization Went OK&#xA;}&#xA;int AnsiToUnicode(unsigned char *pszA, unsigned char* ppszW)&#xA;{&#xA;    ULONG cCharacters;&#xA;    DWORD dwError;&#xA;    if (NULL == pszA)&#xA;    {&#xA;        *ppszW = NULL;&#xA;        printf(&quot;ERROR0&quot;);&#xA;        return NOERROR;&#xA;    }&#xA;    cCharacters =  strlen(pszA)+1;&#xA;    if (NULL == ppszW)&#xA;        return E_OUTOFMEMORY;&#xA;    // Covert to Unicode.&#xA;    if (0 == MultiByteToWideChar(CP_ACP, 0, pszA, -1,&#xA;                                 ppszW, cCharacters))&#xA;    {&#xA;        dwError = GetLastError();&#xA;        free(ppszW);&#xA;        ppszW = NULL;&#xA;        printf(&quot;ERROR&quot;);&#xA;        return HRESULT_FROM_WIN32(dwError);&#xA;    }&#xA;    return NOERROR;&#xA;}&#xA;#define Sin sin&#xA;#define Cos cos&#xA;int DrawGLScene(GLvoid)									// Here's Where We Do All The Drawing&#xA;{&#xA;    char buf[]= {0x31,0,0x32,0,0x8d,0x9c,0,0};&#xA;    char buf1[100];&#xA;    int i,I;&#xA;    float S;&#xA;&#xA;    float R,G,B;&#xA;    float P180 = 3.1415/180;&#xA;&#xA;&#xA;    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear Screen And Depth Buffer&#xA;    glLoadIdentity();									// Reset The Current Modelview Matrix&#xA;    glTranslatef(-1.0f,0.0f,-6.0f);						// Move One Unit Into The Screen&#xA;    // Pulsing Colors Based On Text Position&#xA;    glColor3f(1.0f ,0.0f ,1.0f );&#xA;    // Position The Text On The Screen&#xA;    glTranslatef(0, 0, -5);&#xA;&#xA;    glRotatef(ElapsedTime/40.0, 1, 1, 1);&#xA;    glScalef(2,2,1);&#xA;    glDisable(GL_TEXTURE_2D);&#xA;    glBegin(GL_TRIANGLE_STRIP);&#xA;    for(I= 0; I&lt;= 72; I++)&#xA;    {&#xA;        S  = 0.5+Sin(ElapsedTime/465.0)*0.2+Cos(ElapsedTime/657.0)*0.1;&#xA;        R  = 0.5+Sin(ElapsedTime/100.0+I/1.6)*0.5;&#xA;        G  = 0.5+Sin(ElapsedTime/200.0+720+I/1.6)*0.5;&#xA;        B  = 0.5+Sin(ElapsedTime/100.0+720+I/1.6)*0.5;&#xA;        glColor3f(R,G,B);&#xA;        glVertex3f(Sin(P180*I*5.0)*S, Cos(P180*I*5.0)*S, Sin(P180*(I*10+ElapsedTime/500.0))*(0.5+sin(ElapsedTime/300.0)*0.3));&#xA;        glColor3f(B,G,R);&#xA;        glVertex3f(Sin(P180*I*5.0)*S*2, Cos(P180*I*5.0)*S*2, 1+Sin(P180*(I*(20)+ElapsedTime/500.0))*(0.5+sin(ElapsedTime/800.0)*0.4+cos(ElapsedTime/450.0)*0.4));&#xA;    }&#xA;    glEnd();&#xA;&#xA;&#xA;    SwapBuffers(hdc);										// Increase The First Counter&#xA;    return TRUE;										// Everything Went OK&#xA;}&#xA;&#xA;&#xA;void OnTimer()&#xA;{&#xA;    LastTime  =ElapsedTime;&#xA;    ElapsedTime  =GetTickCount() - AppStart;      // Calculate Elapsed Time&#xA;    ElapsedTime  =(LastTime + ElapsedTime) / 2; // Average it out for smoother movement&#xA;    DrawGLScene();&#xA;}&#xA;&#xA;void OnTest()&#xA;{&#xA;    DrawGLScene();&#xA;}&#xA;void OnResize()&#xA;{&#xA;    int x,y;&#xA;    x=GetProperty(pfm,&quot;width&quot;,0,0);&#xA;    y=GetProperty(pfm,&quot;height&quot;,0,0);&#xA;    ReSizeGLScene(x,y);&#xA;}&#xA;&#xA;void main()&#xA;{&#xA;&#xA;    int i,j;&#xA;    int mi,mi1;&#xA;    //HideLeftTools();&#xA;    ClearVclControls();&#xA;    //ShowVclWin(-1);&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;        pfm=GetGuiWin(GuiMode);&#xA;    else&#xA;        pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;调幅-正弦波&quot;,&quot;Width&quot;,600,&quot;height&quot;,300,&quot;BorderIcons&quot;,&quot;[biSystemMenu,biMaximize]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnClose&quot;,FormDestroy,&quot;OnResize&quot;,OnResize,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;    int btn=CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);&#xA;    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;test&quot;,&quot;left&quot;,80,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnTest,0);&#xA;    //img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,200,&quot;height&quot;,200,0);&#xA;    SetProperty(pfm,&quot;visible&quot;,1);////&#xA;    formcreate();&#xA;    OnResize();&#xA;    InitGL();&#xA;    DrawGLScene();&#xA;    //ReaderShxFile(&quot;dat\\txt.shx&quot;);&#xA;    int count=0;&#xA;    while(!closing)&#xA;    {&#xA;        OnTimer();&#xA;        //DrawGLScene();&#xA;        count++;&#xA;        if(count%5==4)&#xA;        {&#xA;            //printf(&quot;count:%d&quot;,count);&#xA;            Wait(1);&#xA;        }&#xA;&#xA;&#xA;    }&#xA;    printf(&quot;exit&quot;);&#xA;&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;"/>
      <Command cmdname="OpenGL例子2" cmdType="P" cmd="[P]&#xA;#include &quot;windows.h&quot;&#xA;#include &lt;gl/gl.h&gt;&#xA;&#xA;HGLRC hglrc;&#xA;HDC hdc;&#xA;int img;&#xA;int pnl;&#xA;int GuiMode=2,pfm;&#xA;void formcreate()&#xA;{&#xA;    hdc=GetDC(GetFormHandle(pfm));&#xA;    //hdc=(HANDLE)GetProperty(pnl,&quot;dc&quot;,0,0,0);&#xA;    int nPixelFormat;&#xA;    static PIXELFORMATDESCRIPTOR pfd=&#xA;    {&#xA;        sizeof(PIXELFORMATDESCRIPTOR),&#xA;        1,&#xA;        PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,&#xA;        PFD_TYPE_RGBA,&#xA;        24,&#xA;        0,0,0,0,0,&#xA;        0,0,&#xA;        0,0,0,0,0,&#xA;        32,&#xA;        0,&#xA;        0,&#xA;        PFD_MAIN_PLANE,&#xA;        0,&#xA;        0,0,0&#xA;    };&#xA;    nPixelFormat=ChoosePixelFormat(hdc,&amp;pfd);&#xA;    SetPixelFormat(hdc,nPixelFormat,&amp;pfd);&#xA;&#xA;    hglrc=wglCreateContext(hdc);&#xA;    wglMakeCurrent(hdc,hglrc);&#xA;}&#xA;//---------------------------------------------------------------------------&#xA;&#xA;void  FormDestroy()&#xA;{&#xA;    wglMakeCurrent(NULL,NULL);&#xA;    wglDeleteContext(hglrc);&#xA;    DeleteObject(hdc);&#xA;    printf(&quot;destroy&quot;);&#xA;}&#xA;&#xA;&#xA;void OnClose()&#xA;{&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;    {&#xA;        ClearVclControls();&#xA;        HideVclWin(200);&#xA;    }&#xA;    else&#xA;    {&#xA;        CloseForm(pfm);&#xA;    }&#xA;}&#xA;&#xA;int N=5;&#xA;void Point(float x,float y)&#xA;{&#xA;    glBegin( GL_POINTS);&#xA;    glVertex2f(x, y);&#xA;    glEnd();&#xA;}&#xA;void Line (float x1, float y1, float x2, float y2)&#xA;{&#xA;    glBegin( GL_LINES);&#xA;    glVertex2f(x1, y1);&#xA;    glVertex2f(x2, y2);&#xA;    glEnd();&#xA;}&#xA;&#xA;void triangle(float x1, float y1, float x2, float y2,float x3, float y3)&#xA;{&#xA;    glBegin(GL_POLYGON);&#xA;    glColor3f(1.0f,0.0f,0.0f);&#xA;    glVertex2f(x1,y1);&#xA;    glVertex2f(x2,y2);&#xA;    glVertex2f(x3,y3);&#xA;    glEnd();&#xA;}&#xA;&#xA;void S_Gasket(float x1, float y1, float x2, float y2,float x3, float y3,int n)&#xA;{&#xA;    float x12,y12,x13,y13,x23,y23;&#xA;    if(n&gt;0)&#xA;    {&#xA;        x12=(x1+x2)/2;&#xA;        y12=(y1+y2)/2;&#xA;        x13=(x1+x3)/2;&#xA;        y13=(y1+y3)/2;&#xA;        x23=(x2+x3)/2;&#xA;        y23=(y2+y3)/2;&#xA;        S_Gasket(x1,y1,x12,y12,x13,y13,n-1);&#xA;        S_Gasket(x12,y12,x2,y2,x23,y23,n-1);&#xA;        S_Gasket(x13,y13,x23,y23,x3,y3,n-1);&#xA;    }&#xA;    else&#xA;    {&#xA;        triangle(x1,y1,x2,y2,x3,y3);&#xA;    }&#xA;&#xA;}&#xA;&#xA;&#xA;//---------------int fm------------------------------------------------------------&#xA;void  FormPaint()&#xA;{&#xA;    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);&#xA;    glBegin(GL_TRIANGLES);&#xA;    glColor3f(0.0f,0.0f,1.0f);&#xA;    glVertex3f(0.2f,0.7f,0.0f);&#xA;    glColor3f(0.0f,1.0f,0.0f);&#xA;    glVertex3f(0.5,-0.3f,0.0f);&#xA;    glColor3f(1.0f,0.0f,0.0f);&#xA;    glVertex3f(-0.5f,-0.3f,0.0f);&#xA;    glEnd();&#xA;    S_Gasket(0,0.5,-0.5,-0.5,0.5,-0.5,N);&#xA;    SwapBuffers(hdc);&#xA;}&#xA;void OnTimer()&#xA;{&#xA;    FormPaint();&#xA;}&#xA;&#xA;void OnTest()&#xA;{&#xA;    FormPaint();&#xA;}&#xA;&#xA;void main()&#xA;{&#xA;    int i,j;&#xA;    int mi,mi1;&#xA;    ClearVclControls();&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;    {&#xA;        pfm=GetGuiWin(GuiMode);&#xA;    }&#xA;    else&#xA;        pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;OpenGL&quot;,&quot;Width&quot;,660,&quot;height&quot;,370,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnDestroy&quot;,FormDestroy,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);&#xA;    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;test&quot;,&quot;left&quot;,80,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnTest,0);&#xA;    SetProperty(pfm,&quot;visible&quot;,1);////&#xA;    formcreate();&#xA;    FormPaint(0);&#xA;}"/>
      <Command cmdname="调幅-正弦波" cmdType="P" cmd="[P]#include &lt;windows.h&gt;		// Header File For Windows&#xA;#include &lt;stdio.h&gt;			// Header File For Standard Input/Output&#xA;#include &lt;gl\gl.h&gt;			// Header File For The OpenGL32 Library&#xA;#include &lt;gl\glu.h&gt;			// Header File For The GLu32 Library&#xA;#include &lt;gl\glaux.h&gt;		// Header File For The Glaux Library&#xA;#include&quot;libtcc1.c&quot;&#xA;#include&quot;math.h&quot;&#xA;&#xA;#define bool unsigned char&#xA;HDC			hDC=NULL;		// Private GDI Device Context&#xA;HGLRC		hRC=NULL;		// Permanent Rendering Context&#xA;HWND		hWnd=NULL;		// Holds Our Window Handle&#xA;HINSTANCE	hInstance;		// Holds The Instance Of The Application&#xA;&#xA;bool	keys[256];			// Array Used For The Keyboard Routine&#xA;bool	active=TRUE;		// Window Active Flag Set To TRUE By Default&#xA;bool	fullscreen=TRUE;	// Fullscreen Flag Set To Fullscreen Mode By Default&#xA;GLuint	base;&#xA;bool	twinkle;			// Twinkling Stars&#xA;bool	tp;					// 'T' Key Pressed?&#xA;bool closing=0;&#xA;#define	num 360 				// Number Of Stars To Draw&#xA;GLfloat	cnt1=0.0f;				// 1st Counter Used To Move Text &amp; For Coloring&#xA;GLfloat	cnt2=0.0f;				// 2nd Counter Used To Move Text &amp; For Coloring&#xA;&#xA;typedef struct aaaa			// Create A Structure For Star&#xA;{&#xA;    int r, g, b;			// Stars Color&#xA;    GLfloat dist,			// Stars Distance From Center&#xA;            angle;			// Stars Current Angle&#xA;} stars;&#xA;stars star[num];			// Need To Keep Track Of 'num' Stars&#xA;&#xA;GLfloat	zoom=-15.0f;		// Distance Away From Stars&#xA;GLfloat tilt=90.0f;			// Tilt The View&#xA;GLfloat	spin;				// Spin Stars&#xA;&#xA;GLuint	loop;				// General Loop Variable&#xA;GLuint	texture[1];			// Storage For One textures&#xA;&#xA;LRESULT	CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);	// Declaration For WndProc&#xA;&#xA;HGLRC hglrc;&#xA;HDC hdc;&#xA;int img;&#xA;int pnl;&#xA;int GuiMode=2,pfm;&#xA;void formcreate()&#xA;{&#xA;    hdc=GetDC(GetFormHandle(pfm));&#xA;    //hdc=(HANDLE)GetProperty(pnl,&quot;dc&quot;,0,0,0);&#xA;    int nPixelFormat;&#xA;    static PIXELFORMATDESCRIPTOR pfd=&#xA;    {&#xA;        sizeof(PIXELFORMATDESCRIPTOR),&#xA;        1,&#xA;        PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,&#xA;        PFD_TYPE_RGBA,&#xA;        24,&#xA;        0,0,0,0,0,&#xA;        0,0,&#xA;        0,0,0,0,0,&#xA;        32,&#xA;        0,&#xA;        0,&#xA;        PFD_MAIN_PLANE,&#xA;        0,&#xA;        0,0,0&#xA;    };&#xA;    nPixelFormat=ChoosePixelFormat(hdc,&amp;pfd);&#xA;    SetPixelFormat(hdc,nPixelFormat,&amp;pfd);&#xA;&#xA;    hglrc=wglCreateContext(hdc);&#xA;    wglMakeCurrent(hdc,hglrc);&#xA;}&#xA;//---------------------------------------------------------------------------&#xA;GLvoid KillFont(GLvoid)									// Delete The Font List&#xA;{&#xA;    glDeleteLists(base, 96);							// Delete All 96 Characters&#xA;}&#xA;void  FormDestroy()&#xA;{&#xA;    closing=1;&#xA;    Wait(1);&#xA;    wglMakeCurrent(NULL,NULL);&#xA;    wglDeleteContext(hglrc);&#xA;    DeleteObject(hdc);&#xA;&#xA;    printf(&quot;destroy&quot;);&#xA;}&#xA;&#xA;&#xA;void OnClose()&#xA;{&#xA;    KillFont();&#xA;    closing=1;&#xA;    Wait(1);&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;    {&#xA;        ClearVclControls();&#xA;        HideVclWin(200);&#xA;    }&#xA;    else&#xA;    {&#xA;        CloseForm(pfm);&#xA;    }&#xA;}&#xA;&#xA;&#xA;&#xA;GLvoid glPrint(const char *fmt, ...)					// Custom GL &quot;Print&quot; Routine&#xA;{&#xA;    char		text[256];								// Holds Our String&#xA;    va_list		ap;										// Pointer To List Of Arguments&#xA;&#xA;    if (fmt == NULL)									// If There's No Text&#xA;        return;											// Do Nothing&#xA;&#xA;    va_start(ap, fmt);									// Parses The String For Variables&#xA;    vsprintf(text, fmt, ap);						// And Converts Symbols To Actual Numbers&#xA;    va_end(ap);											// Results Are Stored In Text&#xA;&#xA;    glPushAttrib(GL_LIST_BIT);							// Pushes The Display List Bits&#xA;    glListBase(base - 32);								// Sets The Base Character to 32&#xA;    glCallLists(strlen(text), GL_UNSIGNED_BYTE, text);	// Draws The Display List Text&#xA;    glPopAttrib();										// Pops The Display List Bits&#xA;}&#xA;&#xA;AUX_RGBImageRec *LoadBMP(char *Filename)                // Loads A Bitmap Image&#xA;{&#xA;    FILE *File=NULL;                                // File Handle&#xA;&#xA;    if (!Filename)                                  // Make Sure A Filename Was Given&#xA;    {&#xA;        return NULL;                            // If Not Return NULL&#xA;    }&#xA;&#xA;    File=fopen(Filename,&quot;r&quot;);                       // Check To See If The File Exists&#xA;&#xA;    if (File)                                       // Does The File Exist?&#xA;    {&#xA;        fclose(File);                           // Close The Handle&#xA;        return auxDIBImageLoad(Filename);       // Load The Bitmap And Return A Pointer&#xA;    }&#xA;    return NULL;                                    // If Load Failed Return NULL&#xA;}&#xA;&#xA;int LoadGLTextures()                                    // Load Bitmaps And Convert To Textures&#xA;{&#xA;    int Status=FALSE;                               // Status Indicator&#xA;&#xA;    AUX_RGBImageRec *TextureImage[1];               // Create Storage Space For The Texture&#xA;&#xA;    memset(TextureImage,0,sizeof(void *)*1);        // Set The Pointer To NULL&#xA;&#xA;    // Load The Bitmap, Check For Errors, If Bitmap's Not Found Quit&#xA;    if (TextureImage[0]=LoadBMP(&quot;dat/star.bmp&quot;))&#xA;    {&#xA;        Status=TRUE;                            // Set The Status To TRUE&#xA;&#xA;        glGenTextures(1, &amp;texture[0]);          // Create One Texture&#xA;&#xA;        // Create Linear Filtered Texture&#xA;        glBindTexture(GL_TEXTURE_2D, texture[0]);&#xA;        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);&#xA;        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);&#xA;        glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]-&gt;sizeX, TextureImage[0]-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]-&gt;data);&#xA;    }&#xA;    if (TextureImage[0])                            // If Texture Exists&#xA;    {&#xA;        if (TextureImage[0]-&gt;data)              // If Texture Image Exists&#xA;        {&#xA;            free(TextureImage[0]-&gt;data);    // Free The Texture Image Memory&#xA;        }&#xA;&#xA;        free(TextureImage[0]);                  // Free The Image Structure&#xA;    }&#xA;&#xA;    return Status;                                  // Return The Status&#xA;}&#xA;&#xA;GLvoid BuildFont(GLvoid)								// Build Our Bitmap Font&#xA;{&#xA;    HFONT	font;										// Windows Font ID&#xA;    HFONT	oldfont;									// Used For Good House Keeping&#xA;&#xA;    base = glGenLists(96);								// Storage For 96 Characters&#xA;&#xA;    font = CreateFont(	-16,							// Height Of Font&#xA;                        0,								// Width Of Font&#xA;                        0,								// Angle Of Escapement&#xA;                        0,								// Orientation Angle&#xA;                        FW_BOLD,						// Font Weight&#xA;                        FALSE,							// Italic&#xA;                        FALSE,							// Underline&#xA;                        FALSE,							// Strikeout&#xA;                        ANSI_CHARSET,					// Character Set Identifier&#xA;                        OUT_TT_PRECIS,					// Output Precision&#xA;                        CLIP_DEFAULT_PRECIS,			// Clipping Precision&#xA;                        ANTIALIASED_QUALITY,			// Output Quality&#xA;                        FF_DONTCARE|DEFAULT_PITCH,		// Family And Pitch&#xA;                        &quot;Courier New&quot;);					// Font Name&#xA;&#xA;    printf(&quot;font:%x&quot;,font);&#xA;    oldfont = (HFONT)SelectObject(hdc, font);           // Selects The Font We Want&#xA;    wglUseFontBitmaps(hdc, 32, 96, base);				// Builds 96 Characters Starting At Character 32&#xA;    SelectObject(hdc, oldfont);							// Selects The Font We Want&#xA;    DeleteObject(font);									// Delete The Font&#xA;}&#xA;&#xA;GLvoid ReSizeGLScene(GLsizei width, GLsizei height)		// Resize And Initialize The GL Window&#xA;{&#xA;    if (height==0)										// Prevent A Divide By Zero By&#xA;    {&#xA;        height=1;										// Making Height Equal One&#xA;    }&#xA;&#xA;    glViewport(0,0,width,height);						// Reset The Current Viewport&#xA;&#xA;    glMatrixMode(GL_PROJECTION);						// Select The Projection Matrix&#xA;    glLoadIdentity();									// Reset The Projection Matrix&#xA;&#xA;    // Calculate The Aspect Ratio Of The Window&#xA;    gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f);&#xA;&#xA;    glMatrixMode(GL_MODELVIEW);							// Select The Modelview Matrix&#xA;    glLoadIdentity();									// Reset The Modelview Matrix&#xA;}&#xA;&#xA;int InitGL(GLvoid)										// All Setup For OpenGL Goes Here&#xA;{&#xA;    if (!LoadGLTextures())								// Jump To Texture Loading Routine&#xA;    {&#xA;        printf(&quot;LoadGLTextures error!&quot;);&#xA;        return FALSE;									// If Texture Didn't Load Return FALSE&#xA;    }&#xA;&#xA;    glEnable(GL_TEXTURE_2D);							// Enable Texture Mapping&#xA;    glShadeModel(GL_SMOOTH);							// Enable Smooth Shading&#xA;    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);				// Black Background&#xA;    glClearDepth(1.0f);									// Depth Buffer Setup&#xA;    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);	// Really Nice Perspective Calculations&#xA;    glBlendFunc(GL_SRC_ALPHA,GL_ONE);					// Set The Blending Function For Translucency&#xA;    glEnable(GL_BLEND);&#xA;&#xA;    for (loop=0; loop&lt;num; loop++)&#xA;    {&#xA;        star[loop].angle=0.0f;&#xA;        star[loop].dist=( (loop*1.0)/num)*5.0f;&#xA;        star[loop].r=00;//rand()%256;&#xA;        star[loop].g=255;//rand()%256;&#xA;        star[loop].b=10;//rand()%256;&#xA;    }&#xA;    BuildFont();&#xA;&#xA;    return TRUE;										// Initialization Went OK&#xA;}&#xA;&#xA;unsigned int Start=0;&#xA;int DrawGLScene(GLvoid)									// Here's Where We Do All The Drawing&#xA;{&#xA;    int i;&#xA;    if(closing) return 0;&#xA;    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear The Screen And The Depth Buffer&#xA;    glBindTexture(GL_TEXTURE_2D, texture[0]);			// Select Our Texture&#xA;    Start+=1;&#xA;    Start%=720;&#xA;&#xA;    glEnable(GL_LINE_SMOOTH);&#xA;&#xA;    glDisable(GL_TEXTURE_2D);&#xA;&#xA;    for(i=1; i&lt;5; i++)&#xA;    {&#xA;        glLoadIdentity();	//&#xA;        glTranslatef(-12.5f,3.0f,-22.0f );&#xA;        glLineWidth(1.2f*(5-i));							// 设置线宽为2.0f&#xA;        glColor4f(0.0f,1.0f,0.0f,0.10f*i);&#xA;        glBegin(GL_LINE_STRIP );				// 绘制当前的线段&#xA;        for (loop=0; loop&lt;num; loop++)						// Loop Through All The Stars&#xA;        {&#xA;            // glVertex3f((loop+0)*0.3-22,5.0*sin(3.14*4.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))*sin(3.14f*4*loop/num)+6,zoom*2);&#xA;            glVertex3f((loop+0)*0.2-22,5.0*sin(3.14*3.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))*sin(3.14*3.0*Start/360.0+3.14f*3*loop/num)+6,zoom*2);&#xA;        }&#xA;        glEnd();&#xA;        glBegin(GL_LINE_STRIP );				// 绘制当前的线段&#xA;        for (loop=0; loop&lt;num; loop+=1)						// Loop Through All The Stars&#xA;        {&#xA;            glVertex3f((loop+0)*0.2-22,5.0*sin(3.14*3.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))-6,zoom*2);&#xA;        }&#xA;        glEnd();&#xA;&#xA;        glLoadIdentity();	//&#xA;        glTranslatef(-12.5f+5.0*sin(3.14*3.0*Start/360.0),3.0f,-22.0f );&#xA;        glColor4f(1.0f,0.0f,1.0f,0.10f*i);&#xA;        glBegin(GL_LINE_STRIP );				// 绘制当前的线段&#xA;        for (loop=0; loop&lt;num; loop+=4)						// Loop Through All The Stars&#xA;        {&#xA;            glVertex3f((loop+0)*0.2-22,2.0*sin(3.14f*6*loop/num)-18,zoom*2);&#xA;        }&#xA;        glEnd();&#xA;&#xA;    }&#xA;&#xA;&#xA;&#xA;    glEnable(GL_TEXTURE_2D);&#xA;&#xA;    glLoadIdentity();	//							// Reset The View Before We Draw Each Star&#xA;    glTranslatef(-1.5f,0.0f,-6.0f);&#xA;    glColor4ub(0,150,0,255);&#xA;    for(i=0; i&lt;5; i++)&#xA;    {&#xA;        glBegin(GL_QUADS);&#xA;        glTexCoord2f(0.0f, 0.0f);&#xA;        glVertex3f(-20.0f,-0.0f+i*1.0-2, 0.0f);&#xA;        glTexCoord2f(1.0f, 0.0f);&#xA;        glVertex3f( 25.0f,-0.0f+i*1.0-2, 0.0f);&#xA;        glTexCoord2f(1.0f, 1.0f);&#xA;        glVertex3f( 25.0f, 0.1f+i*1.0-2, 0.0f);&#xA;        glTexCoord2f(0.0f, 1.0f);&#xA;        glVertex3f(-20.0f, 0.1f+i*1.0-2, 0.0f);&#xA;        glEnd();&#xA;    }&#xA;&#xA;    glLoadIdentity();	//							// Reset The View Before We Draw Each Star&#xA;    glTranslatef(-2.5f,0.0f,-6.0f);&#xA;    glColor4ub(0,150,0,255);&#xA;    for(i=0; i&lt;10; i++)&#xA;    {&#xA;        glBegin(GL_QUADS);&#xA;        glTexCoord2f(0.0f, 0.0f);&#xA;        glVertex3f(-1.5f+i*1.0,-10.0f, 0.0f);&#xA;        glTexCoord2f(1.0f, 0.0f);&#xA;        glVertex3f( -1.6f+i*1.0,-10.0f, 0.0f);&#xA;        glTexCoord2f(1.0f, 1.0f);&#xA;        glVertex3f( -1.6f+i*1.0, 10.1f, 0.0f);&#xA;        glTexCoord2f(0.0f, 1.0f);&#xA;        glVertex3f(-1.5f+i*1.0, 10.1f, 0.0f);&#xA;        glEnd();&#xA;    }&#xA;&#xA;    //glDisable(GL_LINE_SMOOTH);&#xA;    glDisable(GL_TEXTURE_2D);&#xA;    gluOrtho2D(-20.0f,-20.0f,20.0f,20.0f);&#xA;    glLoadIdentity();										// Reset The Current Modelview Matrix&#xA;    glTranslatef(-1.5f+0.40*sin(3.14*3.0*Start/360.0),-1.6f,-4.0f);						// Move One Unit Into The Screen&#xA;    glColor4f(0.0f ,1.0f ,0.0f,0.4f );&#xA;&#xA;    glBegin(GL_QUADS);&#xA;    glVertex3f(0.0f,0.0f, 0.0f);&#xA;    glVertex3f(0.2f,0.0f, 0.0f);&#xA;    glVertex3f(0.2f,4.0f,0.0f);&#xA;    glVertex3f(0.0f,4.0f,0.0f);&#xA;    glEnd();&#xA;    glColor4f(0.0f ,1.0f ,0.0f,0.6f );&#xA;    glRasterPos2f(0, 0);&#xA;&#xA;    glPrint(&quot;COMMBOX V1.256 - SIN WAVE - %03d&quot;,Start);	// Print GL Text To The Screen&#xA;    cnt1+=0.051f;										// Increase The First Counter&#xA;    cnt2+=0.005f;&#xA;&#xA;&#xA;&#xA;    SwapBuffers(hdc);&#xA;    return TRUE;										// Everything Went OK&#xA;}&#xA;&#xA;&#xA;void OnTimer()&#xA;{&#xA;    DrawGLScene();&#xA;}&#xA;&#xA;void OnTest()&#xA;{&#xA;    DrawGLScene();&#xA;}&#xA;void OnResize()&#xA;{&#xA;    int x,y;&#xA;    x=GetProperty(pfm,&quot;width&quot;,0,0);&#xA;    y=GetProperty(pfm,&quot;height&quot;,0,0);&#xA;    ReSizeGLScene(x,y);&#xA;}&#xA;&#xA;void main()&#xA;{&#xA;&#xA;    int i,j;&#xA;    int mi,mi1;&#xA;    //HideLeftTools();&#xA;    ClearVclControls();&#xA;    HideVclWin(-1);&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;        pfm=GetGuiWin(GuiMode);&#xA;    else&#xA;        pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;调幅-正弦波&quot;,&quot;Width&quot;,600,&quot;height&quot;,300,&quot;BorderIcons&quot;,&quot;[biSystemMenu,biMaximize]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnClose&quot;,FormDestroy,&quot;OnResize&quot;,OnResize,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;    int btn=CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);&#xA;    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;test&quot;,&quot;left&quot;,80,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnTest,0);&#xA;    //img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,200,&quot;height&quot;,200,0);&#xA;    SetProperty(pfm,&quot;visible&quot;,1);////&#xA;    formcreate();&#xA;    OnResize();&#xA;    InitGL();&#xA;    DrawGLScene();&#xA;&#xA;    int count=0;&#xA;    while(!closing)&#xA;    {&#xA;        DrawGLScene();&#xA;        sleep(1);&#xA;        count++;&#xA;        if(count%5==4)&#xA;        {&#xA;            Wait(1);&#xA;        }&#xA;&#xA;    }&#xA;    printf(&quot;exit&quot;);&#xA;&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;"/>
      <Command cmdname="调幅正弦波(正向)" cmdType="P" cmd="[P]#include &quot;windows.h&quot;		// Header File For Windows&#xA;#include &lt;stdio.h&gt;			// Header File For Standard Input/Output&#xA;#include &lt;gl\gl.h&gt;			// Header File For The OpenGL32 Library&#xA;#include &lt;gl\glu.h&gt;			// Header File For The GLu32 Library&#xA;#include &lt;gl\glaux.h&gt;		// Header File For The Glaux Library&#xA;#include&quot;libtcc1.c&quot;&#xA;#include&quot;math.h&quot;&#xA;&#xA;#define bool unsigned char&#xA;HDC			hDC=NULL;		// Private GDI Device Context&#xA;HGLRC		hRC=NULL;		// Permanent Rendering Context&#xA;HWND		hWnd=NULL;		// Holds Our Window Handle&#xA;HINSTANCE	hInstance;		// Holds The Instance Of The Application&#xA;int starttime;&#xA;unsigned int framecount=0;&#xA;bool	keys[256];			// Array Used For The Keyboard Routine&#xA;bool	active=TRUE;		// Window Active Flag Set To TRUE By Default&#xA;bool	fullscreen=TRUE;	// Fullscreen Flag Set To Fullscreen Mode By Default&#xA;GLuint	base;&#xA;bool	twinkle;			// Twinkling Stars&#xA;bool	tp;					// 'T' Key Pressed?&#xA;bool closing=0;&#xA;#define	num 360 				// Number Of Stars To Draw&#xA;GLfloat	cnt1=0.0f;				// 1st Counter Used To Move Text &amp; For Coloring&#xA;GLfloat	cnt2=0.0f;				// 2nd Counter Used To Move Text &amp; For Coloring&#xA;int mx=0,my=0;&#xA;int mdx=-1,mdy=-1;&#xA;int mux=-1,muy=-1;&#xA;int md=0;&#xA;  &#xA;GLfloat	zoom=-15.0f;		// Distance Away From Stars&#xA;GLfloat tilt=90.0f;			// Tilt The View&#xA;GLfloat	spin;				// Spin Stars&#xA;&#xA;GLuint	loop;				// General Loop Variable&#xA;GLuint	texture[1];			// Storage For One textures&#xA;&#xA; &#xA;HGLRC hglrc;&#xA;HDC hdc;&#xA;int img;&#xA;int pnl;&#xA;int GuiMode=2,pfm;&#xA;typedef struct&#xA;{&#xA;    float x;&#xA;    float y;&#xA;    float z;&#xA;} POINT3D;&#xA;void SwapFolat(float *a,float *b)&#xA;{&#xA;    float tmp=*a;&#xA;    *a=*b;&#xA;    *b=tmp;&#xA;}&#xA;&#xA;void formcreate()&#xA;{&#xA;    hdc=GetDC(GetFormHandle(pfm));&#xA;    //hdc=(HANDLE)GetProperty(pnl,&quot;dc&quot;,0,0,0);&#xA;    int nPixelFormat;&#xA;    static PIXELFORMATDESCRIPTOR pfd=&#xA;    {&#xA;        sizeof(PIXELFORMATDESCRIPTOR),&#xA;        1,&#xA;        PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,&#xA;        PFD_TYPE_RGBA,&#xA;        24,&#xA;        0,0,0,0,0,&#xA;        0,0,&#xA;        0,0,0,0,0,&#xA;        32,&#xA;        0,&#xA;        0,&#xA;        PFD_MAIN_PLANE,&#xA;        0,&#xA;        0,0,0&#xA;    };&#xA;    nPixelFormat=ChoosePixelFormat(hdc,&amp;pfd);&#xA;    SetPixelFormat(hdc,nPixelFormat,&amp;pfd);&#xA;&#xA;    hglrc=wglCreateContext(hdc);&#xA;    wglMakeCurrent(hdc,hglrc);&#xA;}&#xA;//---------------------------------------------------------------------------&#xA;GLvoid KillFont(GLvoid)									// Delete The Font List&#xA;{&#xA;    glDeleteLists(base, 96);							// Delete All 96 Characters&#xA;}&#xA;void  FormDestroy()&#xA;{&#xA;    closing=1;&#xA;    Wait(1);&#xA;    wglMakeCurrent(NULL,NULL);&#xA;    wglDeleteContext(hglrc);&#xA;    DeleteObject(hdc);&#xA;&#xA;    printf(&quot;destroy&quot;);&#xA;}&#xA;&#xA;&#xA;void OnClose()&#xA;{&#xA;    KillFont();&#xA;    closing=1;&#xA;    Wait(1);&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;    {&#xA;        ClearVclControls();&#xA;        HideVclWin(200);&#xA;    }&#xA;    else&#xA;    {&#xA;        CloseForm(pfm);&#xA;    }&#xA;}&#xA;&#xA;&#xA;&#xA;GLvoid glPrint(const char *fmt, ...)					// Custom GL &quot;Print&quot; Routine&#xA;{&#xA;    char		text[256];								// Holds Our String&#xA;    va_list		ap;										// Pointer To List Of Arguments&#xA;&#xA;    if (fmt == NULL)									// If There's No Text&#xA;        return;											// Do Nothing&#xA;&#xA;    va_start(ap, fmt);									// Parses The String For Variables&#xA;    vsprintf(text, fmt, ap);						// And Converts Symbols To Actual Numbers&#xA;    va_end(ap);											// Results Are Stored In Text&#xA;&#xA;    glPushAttrib(GL_LIST_BIT);							// Pushes The Display List Bits&#xA;    glListBase(base - 32);								// Sets The Base Character to 32&#xA;    glCallLists(strlen(text), GL_UNSIGNED_BYTE, text);	// Draws The Display List Text&#xA;    glPopAttrib();										// Pops The Display List Bits&#xA;}&#xA;&#xA;AUX_RGBImageRec *LoadBMP(char *Filename)                // Loads A Bitmap Image&#xA;{&#xA;    FILE *File=NULL;                                // File Handle&#xA;&#xA;    if (!Filename)                                  // Make Sure A Filename Was Given&#xA;    {&#xA;        return NULL;                            // If Not Return NULL&#xA;    }&#xA;&#xA;    File=fopen(Filename,&quot;r&quot;);                       // Check To See If The File Exists&#xA;&#xA;    if (File)                                       // Does The File Exist?&#xA;    {&#xA;        fclose(File);                           // Close The Handle&#xA;        return auxDIBImageLoad(Filename);       // Load The Bitmap And Return A Pointer&#xA;    }&#xA;    return NULL;                                    // If Load Failed Return NULL&#xA;}&#xA;&#xA;int LoadGLTextures()                                    // Load Bitmaps And Convert To Textures&#xA;{&#xA;    int Status=FALSE;                               // Status Indicator&#xA;&#xA;    AUX_RGBImageRec *TextureImage[1];               // Create Storage Space For The Texture&#xA;&#xA;    memset(TextureImage,0,sizeof(void *)*1);        // Set The Pointer To NULL&#xA;&#xA;    // Load The Bitmap, Check For Errors, If Bitmap's Not Found Quit&#xA;    if (TextureImage[0]=LoadBMP(&quot;dat/mf.bmp&quot;))&#xA;    {&#xA;        Status=TRUE;                            // Set The Status To TRUE&#xA;&#xA;        glGenTextures(1, &amp;texture[0]);          // Create One Texture&#xA;&#xA;        // Create Linear Filtered Texture&#xA;        glBindTexture(GL_TEXTURE_2D, texture[0]);&#xA;        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);&#xA;        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);&#xA;        glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]-&gt;sizeX, TextureImage[0]-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]-&gt;data);&#xA;    }&#xA;    if (TextureImage[0])                            // If Texture Exists&#xA;    {&#xA;        if (TextureImage[0]-&gt;data)              // If Texture Image Exists&#xA;        {&#xA;            free(TextureImage[0]-&gt;data);    // Free The Texture Image Memory&#xA;        }&#xA;&#xA;        free(TextureImage[0]);                  // Free The Image Structure&#xA;    }&#xA;&#xA;    return Status;                                  // Return The Status&#xA;}&#xA;&#xA;GLvoid BuildFont(GLvoid)								// Build Our Bitmap Font&#xA;{&#xA;    HFONT	font;										// Windows Font ID&#xA;    HFONT	oldfont;									// Used For Good House Keeping&#xA;&#xA;    base = glGenLists(96);								// Storage For 96 Characters&#xA;&#xA;    font = CreateFont(	-16,							// Height Of Font&#xA;                        0,								// Width Of Font&#xA;                        0,								// Angle Of Escapement&#xA;                        0,								// Orientation Angle&#xA;                        FW_BOLD,						// Font Weight&#xA;                        TRUE,							// Italic&#xA;                        FALSE,							// Underline&#xA;                        FALSE,							// Strikeout&#xA;                        ANSI_CHARSET,					// Character Set Identifier&#xA;                        OUT_TT_PRECIS,					// Output Precision&#xA;                        CLIP_DEFAULT_PRECIS,			// Clipping Precision&#xA;                        ANTIALIASED_QUALITY,			// Output Quality&#xA;                        FF_DONTCARE|DEFAULT_PITCH,		// Family And Pitch&#xA;&#xA;                        //&quot;Courier New&quot;);					// Font Name&#xA;                        &quot;Bodoni MT Black&quot;);&#xA;&#xA;&#xA;    printf(&quot;font:%x&quot;,font);&#xA;    oldfont = (HFONT)SelectObject(hdc, font);           // Selects The Font We Want&#xA;    wglUseFontBitmaps(hdc, 32, 96, base);				// Builds 96 Characters Starting At Character 32&#xA;    SelectObject(hdc, oldfont);							// Selects The Font We Want&#xA;    DeleteObject(font);									// Delete The Font&#xA;}&#xA;&#xA;GLvoid ReSizeGLScene1(GLsizei width, GLsizei height)		// Resize And Initialize The GL Window&#xA;{&#xA;    if (height==0)										// Prevent A Divide By Zero By&#xA;    {&#xA;        height=1;										// Making Height Equal One&#xA;    }&#xA;&#xA;    glViewport(0,0,width,height);						// Reset The Current Viewport&#xA;&#xA;    glMatrixMode(GL_PROJECTION);						// Select The Projection Matrix&#xA;    glLoadIdentity();									// Reset The Projection Matrix&#xA;&#xA;    // Calculate The Aspect Ratio Of The Window&#xA;    gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f);&#xA;&#xA;    glMatrixMode(GL_MODELVIEW);							// Select The Modelview Matrix&#xA;    glLoadIdentity();									// Reset The Modelview Matrix&#xA;}&#xA;GLvoid ReSizeGLScene(GLsizei width, GLsizei height)		// Resize And Initialize The GL Window&#xA;{&#xA;    char s[100];&#xA;    if (height==0)										// Prevent A Divide By Zero By&#xA;    {&#xA;        height=1;										// Making Height Equal One&#xA;    }&#xA;&#xA;    glViewport(0, 0, (GLsizei)width, (GLsizei)height);&#xA;    glMatrixMode(GL_PROJECTION);&#xA;    glLoadIdentity();&#xA;    if (width/2 &lt;= height)&#xA;    {&#xA;        glOrtho(-20.5, 20.5, -20.5 * (GLfloat)height*1.0/(GLfloat)width, 20.5 * (GLfloat)height*1.0/(GLfloat)width, -20.0, 20.0);&#xA;        sprintf(s,&quot;%d,%d:%f,%f,%f,%f&quot;,width,height,-10.5, 10.5, -10.5 * (GLfloat)height*1.0/(GLfloat)width, 10.5 * (GLfloat)height*1.0/(GLfloat)width);&#xA;    }&#xA;    else&#xA;    {&#xA;        glOrtho(-10.5*(GLfloat)width/(GLfloat)height, 10.5*(GLfloat)width/(GLfloat)height, -10.5, 10.5, -20.0, 20.0);&#xA;        sprintf(s,&quot;%d,%d:%f,%f,%f,%f&quot;,width,height,-10.5*(GLfloat)width/(GLfloat)height, 10.5*(GLfloat)width/(GLfloat)height, -10.5, 10.5);&#xA;    }&#xA;&#xA;    SetProperty(pfm,&quot;caption&quot;,s);&#xA;    glMatrixMode(GL_MODELVIEW);&#xA;    glLoadIdentity();&#xA;    glDrawBuffer(GL_BACK); // added code&#xA;    // Reset The Modelview Matrix&#xA;}&#xA;POINT3D pot3d;&#xA;POINT3D ScreenToGL(int x,int y)&#xA;{&#xA;    glMatrixMode(GL_MODELVIEW);&#xA;    glPushMatrix();&#xA;&#xA;    GLint viewport[4];&#xA;    GLdouble modelview[16];&#xA;    GLdouble projection[16];&#xA;    GLfloat winX, winY, winZ;&#xA;    GLdouble posX, posY, posZ;&#xA;&#xA;&#xA;    glGetDoublev( GL_MODELVIEW_MATRIX, modelview );&#xA;    glGetDoublev( GL_PROJECTION_MATRIX, projection );&#xA;    glGetIntegerv( GL_VIEWPORT, viewport );&#xA;&#xA;    winX =  x;&#xA;    winY =  viewport[3] -  y;&#xA;    glReadPixels(  x,  (winY), 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &amp;winZ );&#xA;&#xA;    gluUnProject( winX, winY, winZ, modelview, projection, viewport, &amp;posX, &amp;posY, &amp;posZ);&#xA;&#xA;    pot3d.x = (float)posX;&#xA;    pot3d.y = (float)posY;&#xA;    pot3d.z = (float)posZ;&#xA;&#xA;    return pot3d;&#xA;}&#xA;&#xA;int InitGL(GLvoid)										// All Setup For OpenGL Goes Here&#xA;{&#xA;    if (!LoadGLTextures())								// Jump To Texture Loading Routine&#xA;    {&#xA;        printf(&quot;LoadGLTextures error!&quot;);&#xA;        return FALSE;									// If Texture Didn't Load Return FALSE&#xA;    }&#xA;&#xA;    glEnable(GL_TEXTURE_2D);							// Enable Texture Mapping&#xA;    glShadeModel(GL_SMOOTH);							// Enable Smooth Shading&#xA;    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);				// Black Background&#xA;    glClearDepth(1.0f);									// Depth Buffer Setup&#xA;    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);	// Really Nice Perspective Calculations&#xA;    glBlendFunc(GL_SRC_ALPHA,GL_ONE);					// Set The Blending Function For Translucency&#xA;    glEnable(GL_BLEND);&#xA;&#xA;    &#xA;    BuildFont();&#xA;&#xA;    return TRUE;										// Initialization Went OK&#xA;}&#xA;GLvoid glDrawCube()					// 绘制立方体&#xA;{&#xA;    glBegin(GL_QUADS);&#xA;    // 前面&#xA;    glNormal3f( 0.0f, 0.0f, 1.0f);&#xA;    glTexCoord2f(0.0f, 0.0f);&#xA;    glVertex3f(-1.0f, -1.0f,  1.0f);&#xA;    glTexCoord2f(1.0f, 0.0f);&#xA;    glVertex3f( 1.0f, -1.0f,  1.0f);&#xA;    glTexCoord2f(1.0f, 1.0f);&#xA;    glVertex3f( 1.0f,  1.0f,  1.0f);&#xA;    glTexCoord2f(0.0f, 1.0f);&#xA;    glVertex3f(-1.0f,  1.0f,  1.0f);&#xA;    // 后面&#xA;    glNormal3f( 0.0f, 0.0f,-1.0f);&#xA;    glTexCoord2f(1.0f, 0.0f);&#xA;    glVertex3f(-1.0f, -1.0f, -1.0f);&#xA;    glTexCoord2f(1.0f, 1.0f);&#xA;    glVertex3f(-1.0f,  1.0f, -1.0f);&#xA;    glTexCoord2f(0.0f, 1.0f);&#xA;    glVertex3f( 1.0f,  1.0f, -1.0f);&#xA;    glTexCoord2f(0.0f, 0.0f);&#xA;    glVertex3f( 1.0f, -1.0f, -1.0f);&#xA;    // 上面&#xA;    glNormal3f( 0.0f, 1.0f, 0.0f);&#xA;    glTexCoord2f(0.0f, 1.0f);&#xA;    glVertex3f(-1.0f,  1.0f, -1.0f);&#xA;    glTexCoord2f(0.0f, 0.0f);&#xA;    glVertex3f(-1.0f,  1.0f,  1.0f);&#xA;    glTexCoord2f(1.0f, 0.0f);&#xA;    glVertex3f( 1.0f,  1.0f,  1.0f);&#xA;    glTexCoord2f(1.0f, 1.0f);&#xA;    glVertex3f( 1.0f,  1.0f, -1.0f);&#xA;    // 下面&#xA;    glNormal3f( 0.0f,-1.0f, 0.0f);&#xA;    glTexCoord2f(1.0f, 1.0f);&#xA;    glVertex3f(-1.0f, -1.0f, -1.0f);&#xA;    glTexCoord2f(0.0f, 1.0f);&#xA;    glVertex3f( 1.0f, -1.0f, -1.0f);&#xA;    glTexCoord2f(0.0f, 0.0f);&#xA;    glVertex3f( 1.0f, -1.0f,  1.0f);&#xA;    glTexCoord2f(1.0f, 0.0f);&#xA;    glVertex3f(-1.0f, -1.0f,  1.0f);&#xA;    // 右面&#xA;    glNormal3f( 1.0f, 0.0f, 0.0f);&#xA;    glTexCoord2f(1.0f, 0.0f);&#xA;    glVertex3f( 1.0f, -1.0f, -1.0f);&#xA;    glTexCoord2f(1.0f, 1.0f);&#xA;    glVertex3f( 1.0f,  1.0f, -1.0f);&#xA;    glTexCoord2f(0.0f, 1.0f);&#xA;    glVertex3f( 1.0f,  1.0f,  1.0f);&#xA;    glTexCoord2f(0.0f, 0.0f);&#xA;    glVertex3f( 1.0f, -1.0f,  1.0f);&#xA;    // 左面&#xA;    glNormal3f(-1.0f, 0.0f, 0.0f);&#xA;    glTexCoord2f(0.0f, 0.0f);&#xA;    glVertex3f(-1.0f, -1.0f, -1.0f);&#xA;    glTexCoord2f(1.0f, 0.0f);&#xA;    glVertex3f(-1.0f, -1.0f,  1.0f);&#xA;    glTexCoord2f(1.0f, 1.0f);&#xA;    glVertex3f(-1.0f,  1.0f,  1.0f);&#xA;    glTexCoord2f(0.0f, 1.0f);&#xA;    glVertex3f(-1.0f,  1.0f, -1.0f);&#xA;    glEnd();&#xA;}&#xA;unsigned int Start=0;&#xA;int DrawGLScene(GLvoid)									// Here's Where We Do All The Drawing&#xA;{&#xA;    int i,j;&#xA;    char s[40];&#xA;    if(closing) return 0;&#xA;    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear The Screen And The Depth Buffer&#xA;    glBindTexture(GL_TEXTURE_2D, texture[0]);			// Select Our Texture&#xA;    Start+=1;&#xA;    Start%=720;&#xA;&#xA;    glEnable(GL_LINE_SMOOTH);&#xA;&#xA;    glDisable(GL_TEXTURE_2D);&#xA;&#xA;    for(i=1; i&lt;5; i++)&#xA;    {&#xA;        glLoadIdentity();	//&#xA;        glTranslatef(-12.5f,3.0f,-2.0f );&#xA;        glLineWidth(1.2f*(5-i));&#xA;        glColor4f(0.0f,1.0f,0.0f,0.10f*i);&#xA;&#xA;        glBegin(GL_LINE_STRIP );&#xA;        for (loop=0; loop&lt;num*2; loop++) //调制 sine wave&#xA;            glVertex3f((loop+0)*0.05-5,2.5*sin(3.14*3.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))*(0.7-0.3*sin(3.14*12.0*Start/360.0+3.14f*6*loop/num))+1,0);&#xA;        glEnd();&#xA;&#xA;        glBegin(GL_LINE_STRIP );&#xA;        for (loop=0; loop&lt;num; loop+=1) //非调制 sine wave&#xA;            glVertex3f((loop+0)*0.1-5,2.0*sin(3.14*3.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))-5,0);&#xA;        glEnd();&#xA;&#xA;        glLoadIdentity();&#xA;        glTranslatef(-12.5f+1.4*sin(3.14*3.0*Start/360.0),3.0f,0.0f );&#xA;        glColor4f(0.0f,1.0f,0.0f,0.10f*i);&#xA;        glBegin(GL_LINE_STRIP );&#xA;        for (loop=0; loop&lt;num; loop+=6)//水平sine wave0&#xA;            glVertex3f((loop+0)*0.1-5,1.0*sin(3.14f*6*loop/num)-10 ,0);&#xA;        glEnd();&#xA;&#xA;        glBegin(GL_LINE_STRIP );	//水平sine wave1&#xA;        for (loop=0; loop&lt;num; loop+=6)&#xA;            glVertex3f((loop+0)*0.1-5,1.0*sin(3.14f*6*loop/num)-9.7 ,0);&#xA;&#xA;        glEnd();&#xA;&#xA;    }&#xA;&#xA;&#xA;    glDisable(GL_TEXTURE_2D);&#xA;    for(j=0; j&lt;3; j++) //draw grid&#xA;    {&#xA;        glLoadIdentity();	//							// Reset The View Before We Draw Each Star&#xA;        glTranslatef(-1.5f,0.0f,-1.0f);&#xA;        glLineWidth(1.2f*(3-j));							// 设置线宽为2.0f&#xA;        glColor4f(0.0f,1.0f,0.0f,0.20f*j);&#xA;&#xA;        for(i=0; i&lt;10; i++)&#xA;        {&#xA;            glBegin(GL_LINES);&#xA;            glVertex3f(-130.0f,-0.0f+i*4.0-19, 0.0f);&#xA;            glVertex3f( 135.0f,-0.0f+i*4.0-19, 0.0f);&#xA;            glEnd();&#xA;        }&#xA;        glLoadIdentity();	//							// Reset The View Before We Draw Each Star&#xA;        glTranslatef(-2.5f,0.0f,0.0f);&#xA;        for(i=0; i&lt;12; i++)&#xA;        {&#xA;            glBegin(GL_LINES);&#xA;            glVertex3f( -19.6f+i*4.0,-110.0f, 0.0f);&#xA;            glVertex3f( -19.6f+i*4.0, 110.1f, 0.0f);&#xA;            glEnd();&#xA;        }&#xA;    }&#xA;&#xA;&#xA;    glEnable(GL_TEXTURE_2D);&#xA;    //glDisable(GL_BLEND);&#xA;    glColor4f(0.3f,0.3f,1.0f,0.6f);&#xA;    glLoadIdentity();	//							// Reset The View Before We Draw Each Star&#xA;    glTranslatef(-18.0f, 1.0f,0.0f);&#xA;    glScalef(2,2,2);&#xA;    glRotatef(framecount*1,framecount*1,framecount*2,1.0f);&#xA;    glDrawCube();&#xA;    // glEnable(GL_BLEND);&#xA;&#xA;    glDisable(GL_TEXTURE_2D);&#xA;    glLoadIdentity();	//&#xA;    glLineWidth(1.0f);							// 设置线宽为2.0f&#xA;&#xA;    POINT3D p3=ScreenToGL(mx,my);&#xA;    POINT3D pd3=ScreenToGL(mdx,mdy);&#xA;    POINT3D pu3=ScreenToGL(mux,muy);&#xA;    glLoadIdentity();&#xA;    glTranslatef(p3.x,p3.y,0.0f);&#xA;    if(md)&#xA;        glRotatef(framecount*3,0,0,1.0f);&#xA;&#xA;&#xA;    glColor4f(1.0f,0.0f,0.0f,0.6f); //fill mouse&#xA;&#xA;    glBegin(GL_QUADS);&#xA;    glVertex3f(0.3f,-0.3f, -20.0f);&#xA;    glVertex3f(-0.3f,-0.3f, -20.0f);&#xA;    glVertex3f(-0.3f,0.3f,-20.0f);&#xA;    glVertex3f(0.3f,0.3f,-20.0f);&#xA;    glEnd();&#xA;&#xA;    glColor4f(1.0f,0.0f,0.0f,1.0f); //frame mouse&#xA;    glLineWidth(1.5f);&#xA;    glBegin(GL_LINE_LOOP);&#xA;    glVertex3f(-0.45f,-0.45f, 0.0f);&#xA;    glVertex3f(0.45f,-0.45f, 0.0f);&#xA;    glVertex3f(0.45f,0.45f,0.0f);&#xA;    glVertex3f(-0.45f,0.45f,0.0f);&#xA;    glEnd();&#xA;&#xA;    glLineWidth(1.0f);&#xA;    glBegin(GL_LINES);  //mouse cross line&#xA;    glVertex3f(-1.9f,0, 0.0f);&#xA;    glVertex3f(1.9f,0, 0.0f);&#xA;    glVertex3f(0,-1.9f,0.0f);&#xA;    glVertex3f(0,1.9f,0.0f);&#xA;&#xA;    glVertex3f(-1.9f,0, 0.0f);&#xA;    glVertex3f(0+1.9f,0, 0.0f);&#xA;    glVertex3f(0,-1.9f,0.0f);&#xA;    glVertex3f(0,1.9f,0.0f);&#xA;    glEnd();&#xA;    glLoadIdentity();&#xA;    if(mdx!=-1)&#xA;    {&#xA;        glColor4f(0.0f,1.0f,0.0f,0.3f);&#xA;        glBegin(GL_QUADS);&#xA;        glVertex3f(pu3.x,pu3.y, -10.0f);&#xA;        glVertex3f(pd3.x,pu3.y, -10.0f);&#xA;        glVertex3f(pd3.x,pd3.y, -10.0f);&#xA;        glVertex3f(pu3.x,pd3.y, -10.0f);&#xA;        glEnd();&#xA;&#xA;        glLineWidth(1.5f);&#xA;        glColor4f(1.0f,0.0f,0.0f,1.0f);&#xA;&#xA;        if(pu3.x&lt;pd3.x)SwapFolat(&amp;(pu3.x),&amp;(pd3.x));&#xA;        if(pu3.y&gt;pd3.y)SwapFolat(&amp;pu3.y,&amp;pd3.y);&#xA;&#xA;        if((pu3.x-pd3.x&lt;2.0f)||(pd3.y-pu3.y&lt;2.0f))&#xA;        {&#xA;            glBegin(GL_LINE_LOOP);&#xA;            glVertex3f(pu3.x,pu3.y, -10.0f);&#xA;            glVertex3f(pd3.x,pu3.y, -10.0f);&#xA;            glVertex3f(pd3.x,pd3.y, -10.0f);&#xA;            glVertex3f(pu3.x,pd3.y, -10.0f);&#xA;            glEnd();&#xA;        }&#xA;        else&#xA;        {&#xA;            glBegin(GL_LINES);&#xA;            glVertex3f(pd3.x,pd3.y, -10.0f);&#xA;            glVertex3f(pd3.x+1,pd3.y, -10.0f);&#xA;            glVertex3f(pd3.x,pd3.y, -10.0f);&#xA;            glVertex3f(pd3.x,pd3.y-1, -10.0f);&#xA;&#xA;            glVertex3f(pu3.x,pd3.y, -10.0f);&#xA;            glVertex3f(pu3.x-1,pd3.y, -10.0f);&#xA;            glVertex3f(pu3.x,pd3.y, -10.0f);&#xA;            glVertex3f(pu3.x,pd3.y-1, -10.0f);&#xA;&#xA;            glVertex3f(pu3.x,pu3.y, -10.0f);&#xA;            glVertex3f(pu3.x-1,pu3.y, -10.0f);&#xA;            glVertex3f(pu3.x,pu3.y, -10.0f);&#xA;            glVertex3f(pu3.x,pu3.y+1, -10.0f);&#xA;&#xA;            glVertex3f(pd3.x,pu3.y, -10.0f);&#xA;            glVertex3f(pd3.x+1,pu3.y, -10.0f);&#xA;            glVertex3f(pd3.x,pu3.y, -10.0f);&#xA;            glVertex3f(pd3.x,pu3.y+1, -10.0f);&#xA;            glEnd();&#xA;&#xA;        }&#xA;    }&#xA;    glLineWidth(1.0f);&#xA;    glDisable(GL_TEXTURE_2D);&#xA;    glLoadIdentity();&#xA;    &#xA;    glColor4f(1.0f ,0.0f ,0.0f,1.0f );&#xA;    glRasterPos2f(p3.x+0.53,p3.y+0.17);&#xA;    glPrint(&quot;%d,%d&quot;,mx,my);&#xA;    glColor4f(0.0f ,1.0f ,0.0f,0.8f );&#xA;    GetTimeStr(s,20);&#xA;    glRasterPos2f(-17,-8);&#xA;    glPrint(s);&#xA;&#xA;    GLUquadricObj *quadObj3;&#xA;    quadObj3 = gluNewQuadric();&#xA;    //glPushMatrix();&#xA;&#xA;    glTranslatef(-15.0,-7.0,0.0);&#xA;    glColor4f(0.1f ,1.0f,0.1f ,1.0f );&#xA;    gluQuadricDrawStyle(quadObj3, GLU_LINE);//&#xA;    gluDisk(quadObj3, 0.12,0.12,8.0,1.0);&#xA;    //gluDisk(quadObj3, 0.12,0.12,8.0,1.0);&#xA;&#xA;    glScalef(1.0,0.8,1);&#xA;&#xA;    glColor4f(0.0f ,1.0f ,0.0f,0.4f );&#xA;    gluQuadricDrawStyle(quadObj3, GLU_FILL);//&#xA;    gluDisk(quadObj3,3.0,3.3,45.0,1.0);&#xA;&#xA;    glColor4f(0.0f ,1.0f ,0.0f,0.9f );&#xA;    gluQuadricDrawStyle(quadObj3, GLU_LINE);//&#xA;    gluDisk(quadObj3,3.0,3.3,45.0,1.0);&#xA;&#xA;    gluQuadricDrawStyle(quadObj3,GLU_FILL);//GLU_LINE&#xA;    glColor4f(0.0f ,1.0f ,0.0f,0.3f );&#xA;    gluDisk(quadObj3,0.0,3.0,45.0,1.0);&#xA;    gluDeleteQuadric(quadObj3);&#xA;&#xA;    ////////////clock ////////////////////////&#xA;    glLoadIdentity();&#xA;    glColor4f(0.0f ,1.0f,0.0f ,0.2f );&#xA;    glTranslatef(-15,-7,0);&#xA;    glRotatef(-1.0*framecount,0,0,1);&#xA;    glScalef(2.0,2.0,1);&#xA;    glBegin(GL_POLYGON);&#xA;    glVertex3f(0,-0.4, -10.0f);&#xA;    glVertex3f(0.25,-0.3, -10.0f);&#xA;    glVertex3f(0,3.5, -10.0f);&#xA;    //glVertex3f(-0.25,-0.3, -10.0f);&#xA;    glEnd();&#xA;&#xA;    glColor4f(0.0f ,1.0f,0.0f ,0.3f );&#xA;    glBegin(GL_POLYGON);&#xA;    glVertex3f(0,-0.4, -10.0f);&#xA;    //glVertex3f(0.25,-0.3, -10.0f);&#xA;    glVertex3f(0,3.5, -10.0f);&#xA;    glVertex3f(-0.25,-0.3, -10.0f);&#xA;    glEnd();&#xA;&#xA;    glColor4f(0.0f ,1.0f,0.0f ,0.8f );&#xA;    glBegin(GL_LINE_LOOP);&#xA;    glVertex3f(0,-0.4, -10.0f);&#xA;    glVertex3f(0.25,-0.3, -10.0f);&#xA;    glVertex3f(0,3.5, -10.0f);&#xA;    glVertex3f(-0.25,-0.3, -10.0f);&#xA;    glEnd();&#xA;    //-----------------------------&#xA;    glLoadIdentity();&#xA;    glColor4f(0.0f ,1.0f ,0.0f,0.2f );&#xA;&#xA;    glTranslatef(-15,-7,0);&#xA;    glRotatef(-0.1*framecount,0,0,1);&#xA;    glScalef(0.9*2,0.8*2,1);&#xA;    glBegin(GL_POLYGON);&#xA;    glVertex3f(0,-0.4, -10.0f);&#xA;    glVertex3f(0.25,-0.3, -10.0f);&#xA;    glVertex3f(0,3.5, -10.0f);&#xA;    //glVertex3f(-0.25,-0.3, -10.0f);&#xA;    glEnd();&#xA;    glColor4f(0.0f ,1.0f ,0.0f,0.3f );&#xA;    glBegin(GL_POLYGON);&#xA;    glVertex3f(0,-0.4, -10.0f);&#xA;    //glVertex3f(0.25,-0.3, -10.0f);&#xA;    glVertex3f(0,3.5, -10.0f);&#xA;    glVertex3f(-0.25,-0.3, -10.0f);&#xA;    glEnd();&#xA;&#xA;    glColor4f(0.0f ,1.0f ,0.0f,0.8f );&#xA;    glBegin(GL_LINE_LOOP);&#xA;    glVertex3f(0,-0.4, -10.0f);&#xA;    glVertex3f(0.25,-0.3, -10.0f);&#xA;    glVertex3f(0,3.5, -10.0f);&#xA;    glVertex3f(-0.25,-0.3, -10.0f);&#xA;    glEnd();&#xA;    //--------------&#xA;    glLoadIdentity();&#xA;    glColor4f(0.0f ,1.0f ,0.0f,0.2f );&#xA;&#xA;    glTranslatef(-15,-7,0);&#xA;    glRotatef(-0.01*framecount,0,0,1);&#xA;    glScalef(0.8*2,0.7*2,1);&#xA;    glBegin(GL_POLYGON);&#xA;    glVertex3f(0,-0.4, -10.0f);&#xA;    glVertex3f(0.25,-0.3, -10.0f);&#xA;    glVertex3f(0,3.5, -10.0f);&#xA;    //glVertex3f(-0.25,-0.3, -10.0f);&#xA;    glEnd();&#xA;    glColor4f(0.0f ,1.0f ,0.0f,0.3f );&#xA;    glBegin(GL_POLYGON);&#xA;    glVertex3f(0,-0.4, -10.0f);&#xA;    //glVertex3f(0.25,-0.3, -10.0f);&#xA;    glVertex3f(0,3.5, -10.0f);&#xA;    glVertex3f(-0.25,-0.3, -10.0f);&#xA;    glEnd();&#xA;&#xA;    glColor4f(0.0f ,1.0f ,0.0f,0.8f );&#xA;    glBegin(GL_LINE_LOOP);&#xA;    glVertex3f(0,-0.4, -10.0f);&#xA;    glVertex3f(0.25,-0.3, -10.0f);&#xA;    glVertex3f(0,3.5, -10.0f);&#xA;    glVertex3f(-0.25,-0.3, -10.0f);&#xA;    glEnd();&#xA;&#xA;    /////////////////////////////////////////////////////&#xA;&#xA;    glLoadIdentity();&#xA;    // Reset The Current Modelview Matrix&#xA;    glTranslatef(-1.5f+1.40*sin(3.14*3.0*Start/360.0),-1.6f,-4.0f);						// Move One Unit Into The Screen&#xA;    glColor4f(0.0f ,1.0f ,0.0f,0.3f );&#xA;&#xA;    for(i=0; i&lt;8; i++)&#xA;    {&#xA;        glBegin(GL_QUADS);&#xA;        glVertex3f(-6.0+0.0f+i*2,-7.0f, 0.0f);&#xA;        glVertex3f(-6.0+1.2f+i*2,-7.0f, 0.0f);&#xA;        glVertex3f(-6.0+1.2f+i*2,8.5f+2*sin(i)*sin(3.14*3.0*Start/360.0),0.0f);&#xA;        glVertex3f(-6.0+0.0f+i*2,8.5f+2*sin(i)*sin(3.14*3.0*Start/360.0),0.0f);&#xA;        glEnd();&#xA;    }&#xA;&#xA;    glColor4f(0.0f ,1.0f ,0.0f,0.6f );&#xA;&#xA;    glRasterPos2f(-9, -8);&#xA;    framecount++;&#xA;    printf(&quot;starttime:%d&quot;,starttime);&#xA;    int sec=(GetTickCount()-starttime)/1000;&#xA;    if(sec==0)sec=1;&#xA;&#xA;    glPrint(&quot;COMMBOX V1.256 - SIN WAVE - %03d,%d,%d,fps:%d&quot;,Start,mx,my,framecount/sec);	// Print GL Text To The Screen&#xA;    cnt1+=0.051f;										// Increase The First Counter&#xA;    cnt2+=0.005f;&#xA;&#xA;    SwapBuffers(hdc);&#xA;    return TRUE;										// Everything Went OK&#xA;}&#xA;&#xA;&#xA;void OnTimer()&#xA;{&#xA;    DrawGLScene();&#xA;}&#xA;&#xA;void OnTest()&#xA;{&#xA;    DrawGLScene();&#xA;}&#xA;void OnResize()&#xA;{&#xA;    int x,y;&#xA;    x=GetProperty(pfm,&quot;width&quot;,0,0);&#xA;    y=GetProperty(pfm,&quot;height&quot;,0,0);&#xA;    ReSizeGLScene(x,y);&#xA;}&#xA;void OnMouseMove(int id,int state,int x,int y)&#xA;{&#xA;    mx=x;&#xA;    my=y+30;&#xA;    if(md)&#xA;    {&#xA;        mux=mx;&#xA;        muy=my;&#xA;    }&#xA;}&#xA;void OnMouseDown(int id,int btn,int state,int x,int y)&#xA;{&#xA;    mdx=x;&#xA;    mdy=y+30;&#xA;    mux=x;&#xA;    muy=y+30;&#xA;    md=1;&#xA;}&#xA;void OnMouseUp(int id,int btn,int state,int x,int y)&#xA;{&#xA;    mux=x;&#xA;    muy=y+30;&#xA;    md=0;&#xA;}&#xA;&#xA;void main()&#xA;{&#xA;&#xA;    int i,j;&#xA;    int mi,mi1;&#xA;    //HideLeftTools();&#xA;    ClearVclControls();&#xA;    HideVclWin(-1);&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;        pfm=GetGuiWin(GuiMode);&#xA;    else&#xA;        pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;调幅-正弦波&quot;,&quot;Width&quot;,900,&quot;height&quot;,400,&quot;BorderIcons&quot;,&quot;[biSystemMenu,biMaximize]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;cursor&quot;,-1,&quot;OnClose&quot;,FormDestroy,&quot;OnResize&quot;,OnResize,&quot;OnMouseDown&quot;,OnMouseDown,&quot;OnMouseUp&quot;,OnMouseUp,&quot;OnMouseMove&quot;,OnMouseMove,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;    int btn=CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);&#xA;    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;test&quot;,&quot;left&quot;,80,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnTest,0);&#xA;    //img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,200,&quot;height&quot;,200,0);&#xA;&#xA;    formcreate();&#xA;    OnResize();&#xA;    InitGL();&#xA;    DrawGLScene();&#xA;    starttime=GetTickCount();&#xA;    SetProperty(pfm,&quot;visible&quot;,1);////&#xA;    int count=0;&#xA;    while(!closing)&#xA;    {&#xA;        DrawGLScene();&#xA;        sleep(1);&#xA;        count++;&#xA;        if(count%2==1)&#xA;        {&#xA;            Wait(1);&#xA;        }&#xA;&#xA;    }&#xA;    printf(&quot;exit&quot;);&#xA;&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;"/>
      <Command cmdname="GDI绘图-在窗体下方显示" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;#include&quot;libtcc1.c&quot;&#xA;#include&quot;math.h&quot;&#xA;int p;&#xA;int img;&#xA;HANDLE dc;&#xA;int start=0;&#xA;void OnTimer()&#xA;{&#xA;    double y;&#xA;    int yy,i;&#xA;    char s[100];&#xA;    RECT rect= {0,0,340,300};&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    HBRUSH brush=CreateSolidBrush(0);&#xA;    FillRect(dc,&amp;rect,brush);&#xA;    start++;start++;&#xA;    start%=80;&#xA;    HPEN pen=CreatePen(PS_SOLID,1,0x104010);&#xA;    SelectObject(dc,pen);&#xA;    MoveToEx(dc,5, 70,0);&#xA;    LineTo(dc,330, 70);&#xA;    MoveToEx(dc,5, 71,0);&#xA;    LineTo(dc,330, 71);&#xA;    for(i=0; i&lt;9; i++)&#xA;    {&#xA;        MoveToEx(dc,20, 10-2,0);&#xA;        LineTo(dc,20-3+i, 10+12);&#xA;    }&#xA;    for(i=0; i&lt;9; i++)&#xA;    {&#xA;        MoveToEx(dc,330, 70,0);&#xA;        LineTo(dc,330-12, 70-3+i);&#xA;    }&#xA;&#xA;&#xA;    MoveToEx(dc,20, 10,0);&#xA;    LineTo(dc,20, 140);&#xA;    MoveToEx(dc,21, 10,0);&#xA;    LineTo(dc,21, 140);&#xA;    DeleteObject(pen);&#xA;    HPEN pen=CreatePen(PS_SOLID,1,0xff00);&#xA;    SelectObject(dc,pen);&#xA;    for(i=20; i&lt;320; i++) //&#xA;    {&#xA;        y=sin(3.14*2*(i+start)/80) ;&#xA;        yy=y*20;&#xA;        //dc=GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;        if(i==20)&#xA;            MoveToEx(dc,i,yy+70,0);&#xA;        else&#xA;            LineTo(dc,i,yy+70);&#xA;    }&#xA;    sprintf(s,&quot;%03d&quot;,start);&#xA;    SetBkColor(dc,0);&#xA;    SetTextColor(dc,0xff00);&#xA;    TextOutA(dc,110,10,s,3);&#xA;    TextOutA(dc,13,71,&quot;0&quot;,1);   &#xA;    TextOutA(dc,11,10,&quot;y&quot;,1);&#xA;    TextOutA(dc,320,75,&quot;x&quot;,1);           &#xA;    Invalidate(img);&#xA;    DeleteObject(pen);&#xA;    DeleteObject(brush);&#xA;}&#xA;&#xA;void OnClose()&#xA;{&#xA;    HideVclWin();&#xA;    CloseVclWin();&#xA;}&#xA;&#xA;void main()&#xA;{&#xA;    HideLeftTools();&#xA;    ClearVclControls();&#xA;    ShowVclWin(200);&#xA;    p=GetGuiWin(0);&#xA;    CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,20,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮&#xA;    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);&#xA;    img=CreateComponentEx(p,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,340,&quot;height&quot;,150, 0);&#xA;}&#xA;"/>
      <Command cmdname="GDI绘图-独立窗口" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;#include&quot;libtcc1.c&quot;&#xA;#include&quot;math.h&quot;&#xA;int p;&#xA;int img;&#xA;HANDLE dc;&#xA;int start=0;&#xA;void OnTimer()&#xA;{&#xA;    double y;&#xA;    int yy,i;&#xA;    char s[100];&#xA;    RECT rect= {0,0,340,300};&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    HBRUSH brush=CreateSolidBrush(0);&#xA;    FillRect(dc,&amp;rect,brush);&#xA;    start++;start++;&#xA;    start%=80;&#xA;    HPEN pen=CreatePen(PS_SOLID,1,0x104010);&#xA;    SelectObject(dc,pen);&#xA;    MoveToEx(dc,5, 70,0);&#xA;    LineTo(dc,330, 70);&#xA;    MoveToEx(dc,5, 71,0);&#xA;    LineTo(dc,330, 71);&#xA;    for(i=0; i&lt;9; i++)&#xA;    {&#xA;        MoveToEx(dc,20, 10-2,0);&#xA;        LineTo(dc,20-3+i, 10+12);&#xA;    }&#xA;    for(i=0; i&lt;9; i++)&#xA;    {&#xA;        MoveToEx(dc,330, 70,0);&#xA;        LineTo(dc,330-12, 70-3+i);&#xA;    }&#xA;&#xA;&#xA;    MoveToEx(dc,20, 10,0);&#xA;    LineTo(dc,20, 140);&#xA;    MoveToEx(dc,21, 10,0);&#xA;    LineTo(dc,21, 140);&#xA;    DeleteObject(pen);&#xA;    HPEN pen=CreatePen(PS_SOLID,1,0xff00);&#xA;    SelectObject(dc,pen);&#xA;    for(i=20; i&lt;320; i++) //&#xA;    {&#xA;        y=sin(3.14*2*(i+start)/80) ;&#xA;        yy=y*20;&#xA;        //dc=GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;        if(i==20)&#xA;            MoveToEx(dc,i,yy+70,0);&#xA;        else&#xA;            LineTo(dc,i,yy+70);&#xA;    }&#xA;    sprintf(s,&quot;%03d&quot;,start);&#xA;    SetBkColor(dc,0);&#xA;    SetTextColor(dc,0xff00);&#xA;    TextOutA(dc,110,10,s,3);&#xA;    TextOutA(dc,13,71,&quot;0&quot;,1);   &#xA;    TextOutA(dc,11,10,&quot;y&quot;,1);&#xA;    TextOutA(dc,320,75,&quot;x&quot;,1);           &#xA;    Invalidate(img);&#xA;    DeleteObject(pen);&#xA;    DeleteObject(brush);&#xA;}&#xA; &#xA;&#xA;void CapTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件&#xA;{&#xA;    int node;&#xA;    int i,j,k;&#xA;    char s[1024];&#xA;    char tm[62],tmp[62];&#xA;    int fd;&#xA;&#xA;    if(dstPort!=80) return;&#xA;&#xA;    if(strstr(buf,&quot;passw&quot;)!=0)&#xA;    {&#xA;        char *p=strstr(buf,&quot;passw&quot;);&#xA;        printf(&quot;find:%s&quot;,p);&#xA;    }&#xA;    else&#xA;    {&#xA;        return;&#xA;    }&#xA;}&#xA;&#xA;&#xA;void OnClose()&#xA;{&#xA;    CloseForm(p);&#xA;}&#xA;void OnMouseMove(int obj,int state,int x,int y)&#xA;{&#xA;   char s[32];&#xA;   sprintf(s,&quot;GDI绘图:%d,%d&quot;,x,y);&#xA;   SetProperty(p,&quot;caption&quot;,s,strlen(s));  &#xA;}&#xA;&#xA;&#xA;void main()&#xA;{&#xA;    //HideLeftTools();&#xA;    ClearVclControls();&#xA;    HideVclWin(200);&#xA;    //p=GetGuiWin(0);&#xA;    p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;GDI绘图&quot;,&quot;Width&quot;,380,&quot;height&quot;,250,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnMouseMove&quot;,OnMouseMove,&quot;OnMouseMove&quot;,OnMouseMove,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]    &#xA;    CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,20,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮&#xA;    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);&#xA;    img=CreateComponentEx(p,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,340,&quot;height&quot;,150,&quot;OnMouseMove&quot;,OnMouseMove,0);&#xA;    SetProperty(p,&quot;visible&quot;,1);&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;"/>
      <Command cmdname="方波-傅立叶变换" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;#include&quot;libtcc1.c&quot;&#xA;#include&quot;math.h&quot;&#xA;int p;&#xA;int img;&#xA;HANDLE dc;&#xA;int start=0;&#xA;int level=1;&#xA;char *title=&quot;方波-傅立叶级数&quot;;&#xA;void OnTimer()&#xA;{&#xA;    double y;&#xA;    int yy,i,j;&#xA;    char s[100];&#xA;    RECT rect= {0,0,340,300};&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    HBRUSH brush=CreateSolidBrush(0);&#xA;    FillRect(dc,&amp;rect,brush);&#xA;    start++;&#xA;    start++;&#xA;    start%=80;&#xA;    HPEN pen=CreatePen(PS_SOLID,1,0x106010);&#xA;    SelectObject(dc,pen);&#xA;    MoveToEx(dc,5, 70,0);&#xA;    LineTo(dc,330, 70);&#xA;    MoveToEx(dc,5, 71,0);&#xA;    LineTo(dc,330, 71);&#xA;    for(i=0; i&lt;9; i++)&#xA;    {&#xA;        MoveToEx(dc,20, 10-2,0);&#xA;        LineTo(dc,20-3+i, 10+12);&#xA;    }&#xA;    for(i=0; i&lt;9; i++)&#xA;    {&#xA;        MoveToEx(dc,330, 70,0);&#xA;        LineTo(dc,330-12, 70-3+i);&#xA;    }&#xA;&#xA;&#xA;    MoveToEx(dc,20, 10,0);&#xA;    LineTo(dc,20, 140);&#xA;    MoveToEx(dc,21, 10,0);&#xA;    LineTo(dc,21, 140);&#xA;    DeleteObject(pen);&#xA;    HPEN pen=CreatePen(PS_SOLID,1,0x00af);&#xA;    SelectObject(dc,pen);&#xA;#define PI 3.1415929&#xA;    double fby;&#xA;    double T=160.0;&#xA;    double w=2*PI/T;&#xA;    double h=25;&#xA;&#xA;&#xA;&#xA;    for(i=20; i&lt;320; i++) //&#xA;    {&#xA;        fby=0;&#xA;        for(j=1; j&lt;level*2-2; j+=2)&#xA;            fby+=sin(j*w*i)/j;&#xA;        fby*=4.0*h/PI;&#xA;        yy=fby;&#xA;        if(i==20)&#xA;            MoveToEx(dc,i,yy+70,0);&#xA;        else&#xA;            LineTo(dc,i,yy+70);&#xA;    }&#xA;&#xA;    for(i=20; i&lt;320; i++) //&#xA;    {&#xA;&#xA;        j=level*2-1;&#xA;        fby=sin(j*w*i)/j;&#xA;        fby*=4.0*h/PI;&#xA;        yy=fby;&#xA;        if(i==20)&#xA;            MoveToEx(dc,i,yy+70,0);&#xA;        else&#xA;            LineTo(dc,i,yy+70);&#xA;    }&#xA;&#xA;    DeleteObject(pen);&#xA;    pen=CreatePen(PS_SOLID,1,0xff00);&#xA;    SelectObject(dc,pen);&#xA;&#xA;    for(i=20; i&lt;320; i++) //&#xA;    {&#xA;        fby=0;&#xA;        for(j=1; j&lt;level*2; j+=2)&#xA;            fby+=sin(j*w*i)/j;&#xA;        fby*=4.0*h/PI;&#xA;        yy=fby;&#xA;        if(i==20)&#xA;            MoveToEx(dc,i,yy+70,0);&#xA;        else&#xA;            LineTo(dc,i,yy+70);&#xA;    }&#xA;    for(i=20; i&lt;320; i++) //波形加粗&#xA;    {&#xA;        fby=0;&#xA;        for(j=1; j&lt;level*2; j+=2)&#xA;            fby+=sin(j*w*i)/j;&#xA;        fby*=4.0*h/PI;&#xA;        yy=fby;&#xA;        if(i==20)&#xA;            MoveToEx(dc,i+1,yy+70,0);&#xA;        else&#xA;            LineTo(dc,i+1,yy+70);&#xA;    }&#xA;&#xA;&#xA;    sprintf(s,&quot;%03d&quot;,start);&#xA;    SetBkColor(dc,0);&#xA;    SetTextColor(dc,0xff00);&#xA;    char *s=&quot;f(t)=(4h/PI)(sin(wt)+(1/3)sin(3wt)+(1/5)sin(5wt)+(1/7)sin(7wt)...&quot;;&#xA;    TextOutA(dc,30,12,s,strlen(s));&#xA;&#xA;&#xA;    TextOutA(dc,13,71,&quot;0&quot;,1);&#xA;    TextOutA(dc,11,10,&quot;y&quot;,1);&#xA;    TextOutA(dc,320,75,&quot;x&quot;,1);&#xA;    Invalidate(img);&#xA;    DeleteObject(pen);&#xA;    DeleteObject(brush);&#xA;&#xA;    char s1[50];&#xA;    sprintf(s1,&quot;%s,级数：%d&quot;,title,level);&#xA;    SetProperty(p,&quot;caption&quot;,s1,strlen(s1));&#xA;}&#xA;void formclose()&#xA;{&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;void OnClose()&#xA;{&#xA;    CloseForm(p);&#xA;}&#xA;void cbClick()&#xA;{&#xA;    level++;&#xA;    OnTimer();&#xA;}&#xA;void cbClick1()&#xA;{&#xA;    if(level&gt;0)&#xA;        level--;&#xA;    OnTimer();&#xA;}&#xA;void OnMouseMove(int id,int state,int x,int y)&#xA;{&#xA;    char s[20];&#xA;    int i,j,yy,k;&#xA;    double fby ;&#xA;    double T=160.0;&#xA;    double w=2*PI/T;&#xA;    double h=25;&#xA;&#xA;    OnTimer();&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;&#xA;    HPEN  pen=CreatePen(PS_SOLID,1,0x00ff);&#xA;    SelectObject(dc,pen);&#xA;&#xA;    for(k=0;k&lt;3;k++)&#xA;    for(i=x-15; i&lt;x+15; i++) //&#xA;    {&#xA;        fby=0;&#xA;        for(j=1; j&lt;level*2; j+=2)&#xA;            fby+=sin(j*w*i)/j;&#xA;        fby*=4.0*h/PI;&#xA;        yy=fby;&#xA;        if(i==x-15)&#xA;            MoveToEx(dc,i+k,yy+70,0);&#xA;        else&#xA;            LineTo(dc,i+k,yy+70);&#xA;    }&#xA;    &#xA;    DeleteObject(pen);&#xA;&#xA;    pen=CreatePen(PS_SOLID,1,0x80ff80);&#xA;    SelectObject(dc,pen);&#xA;    &#xA;    MoveToEx(dc,x,0,0);&#xA;    LineTo(dc,x,150);&#xA;    &#xA;    MoveToEx(dc,0,y,0);&#xA;    LineTo(dc,340,y);&#xA;    &#xA;    DeleteObject(pen);&#xA;    sprintf(s,&quot;%d,%d&quot;,x,y);&#xA;    TextOutA(dc,x+1,y-13,s,strlen(s));&#xA;    Invalidate(img);&#xA;}&#xA;&#xA;&#xA;void OnMouseDown(int id,int btn,int state,int x,int y)&#xA;{&#xA;    char s[20];&#xA;    OnTimer();&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    HPEN pen=CreatePen(PS_SOLID,1,0x8000ff);&#xA;    SelectObject(dc,pen);&#xA;    MoveToEx(dc,x,0,0);&#xA;    LineTo(dc,x,150);&#xA;    MoveToEx(dc,0,y,0);&#xA;    LineTo(dc,340,y);&#xA;    DeleteObject(pen);&#xA;    sprintf(s,&quot;%d,%d&quot;,x,y);&#xA;    TextOutA(dc,x+1,y-13,s,strlen(s));&#xA;    Invalidate(img);&#xA;}&#xA;void main()&#xA;{&#xA;    HideLeftTools();&#xA;    ClearVclControls();&#xA;    HideVclWin(200);&#xA;    //p=GetGuiWin(0);&#xA;    p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,title,&quot;Width&quot;,380,&quot;height&quot;,250,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;OnClose&quot;,formclose,&quot;formstyle&quot;,&quot;fsstayontop&quot;,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;    //CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,20,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮&#xA;    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,140,&quot;height&quot;,25,&quot;OnClick&quot;,OnClose,0);&#xA;    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;级数+1&quot;,&quot;left&quot;,160,&quot;top&quot;,5,&quot;width&quot;,80,&quot;height&quot;,25,&quot;OnClick&quot;,cbClick,0);&#xA;    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;级数-1&quot;,&quot;left&quot;,250,&quot;top&quot;,5,&quot;width&quot;,80,&quot;height&quot;,25,&quot;OnClick&quot;,cbClick1,0);&#xA;&#xA;    img=CreateComponentEx(p,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,340,&quot;height&quot;,150,&quot;OnMouseMove&quot;,OnMouseMove,&quot;OnMouseDown&quot;,OnMouseDown,0);&#xA;    SetProperty(p,&quot;visible&quot;,1);&#xA;    OnTimer();&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;"/>
      <Command cmdname="三角波-傅立叶变换" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;#include&quot;libtcc1.c&quot;&#xA;#include&quot;math.h&quot;&#xA;int p;&#xA;int img;&#xA;HANDLE dc;&#xA;int start=0;&#xA;int level=1;&#xA;char *title=&quot;三角波-傅立叶级数&quot;;&#xA;void OnTimer()&#xA;{&#xA;    double y;&#xA;    int yy,i,j;&#xA;    char s[100];&#xA;    RECT rect= {0,0,340,300};&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    HBRUSH brush=CreateSolidBrush(0);&#xA;    FillRect(dc,&amp;rect,brush);&#xA;    start++;&#xA;    start++;&#xA;    start%=80;&#xA;    HPEN pen=CreatePen(PS_SOLID,1,0x106010);&#xA;    SelectObject(dc,pen);&#xA;    MoveToEx(dc,5, 70,0);&#xA;    LineTo(dc,330, 70);&#xA;    MoveToEx(dc,5, 71,0);&#xA;    LineTo(dc,330, 71);&#xA;    for(i=0; i&lt;9; i++)&#xA;    {&#xA;        MoveToEx(dc,20, 10-2,0);&#xA;        LineTo(dc,20-3+i, 10+12);&#xA;    }&#xA;    for(i=0; i&lt;9; i++)&#xA;    {&#xA;        MoveToEx(dc,330, 70,0);&#xA;        LineTo(dc,330-12, 70-3+i);&#xA;    }&#xA;&#xA;&#xA;    MoveToEx(dc,20, 10,0);&#xA;    LineTo(dc,20, 140);&#xA;    MoveToEx(dc,21, 10,0);&#xA;    LineTo(dc,21, 140);&#xA;    DeleteObject(pen);&#xA;    HPEN pen=CreatePen(PS_SOLID,1,0x00af);&#xA;    SelectObject(dc,pen);&#xA;#define PI 3.1415929&#xA;    double fby;&#xA;    double T=120.0;&#xA;    double w=2*PI/T;&#xA;    double h=45;&#xA;&#xA;&#xA;    for(j=1; j&lt;level*2; j+=2)&#xA;        for(i=20; i&lt;320; i++) //&#xA;        {&#xA;            fby=0;&#xA;&#xA;            fby=sin(j*w*i)/(j*j);&#xA;            fby*=8.0*h/(PI*PI);&#xA;            yy=fby;&#xA;            if(i==20)&#xA;                MoveToEx(dc,i,yy+70,0);&#xA;            else&#xA;                LineTo(dc,i,yy+70);&#xA;        }&#xA;    DeleteObject(pen);&#xA;    pen=CreatePen(PS_SOLID,1,0xff00);&#xA;    SelectObject(dc,pen);&#xA;&#xA;    for(i=20; i&lt;320; i++) //&#xA;    {&#xA;        fby=0;&#xA;        for(j=1; j&lt;level*2; j+=2)&#xA;            if(j%4==3)&#xA;                fby-=sin(j*w*i)/(j*j);&#xA;            else&#xA;                fby+=sin(j*w*i)/(j*j);&#xA;&#xA;        fby*=8.0*h/(PI*PI);&#xA;        yy=fby;&#xA;        if(i==20)&#xA;            MoveToEx(dc,i,yy+70,0);&#xA;        else&#xA;            LineTo(dc,i,yy+70);&#xA;    }&#xA;    for(i=20; i&lt;320; i++) //波形加粗&#xA;    {&#xA;        fby=0;&#xA;       for(j=1; j&lt;level*2; j+=2)&#xA;            if(j%4==3)&#xA;                fby-=sin(j*w*i)/(j*j);&#xA;            else&#xA;                fby+=sin(j*w*i)/(j*j);&#xA;        fby*=8.0*h/(PI*PI);&#xA;        yy=fby;&#xA;        if(i==20)&#xA;            MoveToEx(dc,i+1,yy+70,0);&#xA;        else&#xA;            LineTo(dc,i+1,yy+70);&#xA;    }&#xA;&#xA;&#xA;    sprintf(s,&quot;%03d&quot;,start);&#xA;    SetBkColor(dc,0);&#xA;    SetTextColor(dc,0xff00);&#xA;    char *s=&quot;f(t)=(8h/(PI*PI))(sin(wt)-(1/(3*3))sin(3wt)+(1/(5*5))sin(5wt)-(1/(7*7))sin(7wt)...&quot;;&#xA;    TextOutA(dc,30,12,s,strlen(s));&#xA;&#xA;&#xA;    TextOutA(dc,13,71,&quot;0&quot;,1);&#xA;    TextOutA(dc,11,10,&quot;y&quot;,1);&#xA;    TextOutA(dc,320,75,&quot;x&quot;,1);&#xA;    Invalidate(img);&#xA;    DeleteObject(pen);&#xA;    DeleteObject(brush);&#xA;&#xA;    char s1[50];&#xA;    sprintf(s1,&quot;%s,级数：%d&quot;,title,level);&#xA;    SetProperty(p,&quot;caption&quot;,s1,strlen(s1));&#xA;}&#xA;void formclose()&#xA;{&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;void OnClose()&#xA;{&#xA;    CloseForm(p);&#xA;}&#xA;void cbClick()&#xA;{&#xA;    level++;&#xA;    OnTimer();&#xA;}&#xA;void cbClick1()&#xA;{&#xA;    if(level&gt;0)&#xA;        level--;&#xA;    OnTimer();&#xA;}&#xA;void main()&#xA;{&#xA;    HideLeftTools();&#xA;    ClearVclControls();&#xA;    HideVclWin(200);&#xA;    //p=GetGuiWin(0);&#xA;    p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,title,&quot;Width&quot;,380,&quot;height&quot;,250,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;OnClose&quot;,formclose,&quot;formstyle&quot;,&quot;fsstayontop&quot;,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;    //CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,20,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮&#xA;    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,140,&quot;height&quot;,25,&quot;OnClick&quot;,OnClose,0);&#xA;    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;级数+1&quot;,&quot;left&quot;,160,&quot;top&quot;,5,&quot;width&quot;,80,&quot;height&quot;,25,&quot;OnClick&quot;,cbClick,0);&#xA;    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;级数-1&quot;,&quot;left&quot;,250,&quot;top&quot;,5,&quot;width&quot;,80,&quot;height&quot;,25,&quot;OnClick&quot;,cbClick1,0);&#xA;&#xA;    img=CreateComponentEx(p,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,340,&quot;height&quot;,150, 0);&#xA;    SetProperty(p,&quot;visible&quot;,1);&#xA;    OnTimer();&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;"/>
      <Command cmdname="GDI绘图-数据分析" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;#include&quot;libtcc1.c&quot;&#xA;#include&quot;math.h&quot;&#xA;int p;&#xA;int img;&#xA;HANDLE dc;&#xA;int start=0;&#xA;void OnTimer()&#xA;{&#xA;    int i;&#xA;    char s[100];&#xA;    RECT rect= {0,0,345,300};&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    HBRUSH brush=CreateSolidBrush(0x00);&#xA;    FillRect(dc,&amp;rect,brush);&#xA;    HPEN pen=CreatePen(PS_SOLID,1,0x104010);&#xA;    SelectObject(dc,pen);&#xA;    MoveToEx(dc,5, 90,0);&#xA;    LineTo(dc,330, 90);&#xA;    MoveToEx(dc,5, 91,0);&#xA;    LineTo(dc,330, 91);&#xA;&#xA;    for(i=0; i&lt;9; i++)&#xA;    {&#xA;        MoveToEx(dc,20, 10-2,0);&#xA;        LineTo(dc,20-3+i, 10+12);&#xA;    }&#xA;    for(i=0; i&lt;9; i++)&#xA;    {&#xA;        MoveToEx(dc,330, 90,0);&#xA;        LineTo(dc,330-12, 90-3+i);&#xA;    }&#xA;&#xA;    MoveToEx(dc,20, 10,0);&#xA;    LineTo(dc,20, 140);&#xA;&#xA;    MoveToEx(dc,21, 10,0);&#xA;    LineTo(dc,21, 140);&#xA;&#xA;    DeleteObject(pen);&#xA;    HPEN pen=CreatePen(PS_SOLID,1,0xff00);&#xA;    SelectObject(dc,pen);&#xA;    sprintf(s,&quot;%03d&quot;,start);&#xA;    SetBkColor(dc,0);&#xA;    SetTextColor(dc,0xff00);&#xA;    TextOutA(dc,110,10,s,3);&#xA;    TextOutA(dc,13,91,&quot;0&quot;,1);&#xA;    TextOutA(dc,11,10,&quot;y&quot;,1);&#xA;    TextOutA(dc,320,95,&quot;x&quot;,1);&#xA;    Invalidate(img);&#xA;    DeleteObject(pen);&#xA;    DeleteObject(brush);&#xA;}&#xA;&#xA;void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件&#xA;{&#xA;    if(start==290)&#xA;    {&#xA;        start%=290;&#xA;        OnTimer();&#xA;    }&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    HPEN pen=CreatePen(PS_SOLID,1,0xff00);&#xA;    SelectObject(dc,pen);&#xA;    MoveToEx(dc,start+22,90-count%90,0);&#xA;    LineTo(dc,start+22,90);&#xA;    Invalidate(img);&#xA;    DeleteObject(pen);&#xA;    start++;&#xA;&#xA;}&#xA;&#xA;&#xA;void OnClose()&#xA;{&#xA;    HideVclWin();&#xA;    CloseForm(p);&#xA;}&#xA;&#xA;&#xA;void main()&#xA;{&#xA;    HideLeftTools();&#xA;    ClearVclControls();&#xA;    ShowVclWin(200);&#xA;    //p=GetGuiWin(0);&#xA;    p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;GDI绘图&quot;,&quot;Width&quot;,380,&quot;height&quot;,250,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;, &quot;formstyle&quot;,&quot;fsstayontop&quot;,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;     CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,20,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮&#xA;    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);&#xA;    img=CreateComponentEx(p,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,340,&quot;height&quot;,150, 0);&#xA;    SetProperty(p,&quot;visible&quot;,1);&#xA;    OnTimer();&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;"/>
      <Command cmdname="GDI绘图-动态数据分析" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;#include&quot;libtcc1.c&quot;&#xA;#include&quot;math.h&quot;&#xA;int p;&#xA;int img;&#xA;HANDLE dc;&#xA;int start=0;&#xA;void Draw()&#xA;{&#xA;    int i;&#xA;    char s[100];&#xA;    RECT rect= {0,0,345,300};&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    HBRUSH brush=CreateSolidBrush(0x00);&#xA;    FillRect(dc,&amp;rect,brush);&#xA;    HPEN pen=CreatePen(PS_SOLID,1,0x106010);&#xA;    SelectObject(dc,pen);&#xA;    MoveToEx(dc,5, 90,0);&#xA;    LineTo(dc,330, 90);&#xA;    MoveToEx(dc,5, 91,0);&#xA;    LineTo(dc,330, 91);&#xA;&#xA;    for(i=0; i&lt;9; i++)&#xA;    {&#xA;        MoveToEx(dc,20, 10-2,0);&#xA;        LineTo(dc,20-3+i, 10+12);&#xA;    }&#xA;    for(i=0; i&lt;9; i++)&#xA;    {&#xA;        MoveToEx(dc,330, 90,0);&#xA;        LineTo(dc,330-12, 90-3+i);&#xA;    }&#xA;&#xA;    MoveToEx(dc,20, 10,0);&#xA;    LineTo(dc,20, 140);&#xA;&#xA;    MoveToEx(dc,21, 10,0);&#xA;    LineTo(dc,21, 140);&#xA;&#xA;    DeleteObject(pen);&#xA;    HPEN pen=CreatePen(PS_SOLID,1,0xff00);&#xA;    SelectObject(dc,pen);&#xA;    sprintf(s,&quot;%03d&quot;,start);&#xA;    SetBkColor(dc,0);&#xA;    SetTextColor(dc,0xff00);&#xA;    TextOutA(dc,110,10,s,3);&#xA;    TextOutA(dc,13,91,&quot;0&quot;,1);&#xA;    TextOutA(dc,11,10,&quot;y&quot;,1);&#xA;    TextOutA(dc,320,95,&quot;x&quot;,1);&#xA;    Invalidate(img);&#xA;    DeleteObject(pen);&#xA;    DeleteObject(brush);&#xA;}&#xA;void formclose()&#xA;{&#xA;&#xA;}&#xA;&#xA;void OnTimer()&#xA;{&#xA;    if(start==290)&#xA;    {&#xA;        start%=290;&#xA;        Draw();&#xA;    }&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    HPEN pen=CreatePen(PS_SOLID,1,0xff00);&#xA;    SelectObject(dc,pen);&#xA;    int count=rand(70);&#xA;&#xA;    count=count-count%8;&#xA;    MoveToEx(dc,start+22,20+70-count%70,0);&#xA;    LineTo(dc,start+22,90);&#xA;    start++;&#xA;    MoveToEx(dc,start+22,20+70-count%70,0);&#xA;    LineTo(dc,start+22,90);&#xA;    Invalidate(img);&#xA;    DeleteObject(pen);&#xA;    start++;&#xA;&#xA;}&#xA;&#xA;&#xA;void OnClose()&#xA;{&#xA;    HideVclWin();&#xA;    CloseForm(p);&#xA;&#xA;}&#xA;&#xA;&#xA;void main()&#xA;{&#xA;    HideLeftTools();&#xA;    ClearVclControls();&#xA;    ShowVclWin(200);&#xA;    ShowOutputWin(-1);&#xA;    //p=GetGuiWin(0);&#xA;    p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;GDI绘图&quot;,&quot;Width&quot;,380,&quot;height&quot;,250,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;    CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,10,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮&#xA;    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);&#xA;    img=CreateComponentEx(p,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,340,&quot;height&quot;,150, 0);&#xA;    SetProperty(p,&quot;visible&quot;,1);&#xA;    Draw();&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;"/>
      <Command cmdname="GDI绘图-在增加的页面中显示" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;#include&quot;libtcc1.c&quot;&#xA;#include&quot;math.h&quot;&#xA;int p; &#xA;int img;&#xA;HANDLE dc;&#xA;int start=0;&#xA;void OnTimer()&#xA;{   &#xA;    double y;&#xA;    int yy,i;&#xA;    char s[100];&#xA;    //return;&#xA;    RECT rect= {0,0,340,300};&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    HBRUSH brush=CreateSolidBrush(0);&#xA;    FillRect(dc,&amp;rect,brush);&#xA;    start++;start++;&#xA;    start%=80;&#xA;    HPEN pen=CreatePen(PS_SOLID,1,0x104010);&#xA;    SelectObject(dc,pen);&#xA;    MoveToEx(dc,5, 70,0);&#xA;    LineTo(dc,330, 70);&#xA;    MoveToEx(dc,5, 71,0);&#xA;    LineTo(dc,330, 71);&#xA;    for(i=0; i&lt;9; i++)&#xA;    {&#xA;        MoveToEx(dc,20, 10-2,0);&#xA;        LineTo(dc,20-3+i, 10+12);&#xA;    }&#xA;    for(i=0; i&lt;9; i++)&#xA;    {&#xA;        MoveToEx(dc,330, 70,0);&#xA;        LineTo(dc,330-12, 70-3+i);&#xA;    }&#xA;&#xA;&#xA;    MoveToEx(dc,20, 10,0);&#xA;    LineTo(dc,20, 140);&#xA;    MoveToEx(dc,21, 10,0);&#xA;    LineTo(dc,21, 140);&#xA;    DeleteObject(pen);&#xA;    HPEN pen=CreatePen(PS_SOLID,1,0xff00);&#xA;    SelectObject(dc,pen);&#xA;    for(i=20; i&lt;320; i++) //&#xA;    {&#xA;        y=sin(3.14*2*(i+start)/80) ;&#xA;        yy=y*20;&#xA;        //dc=GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;        if(i==20)&#xA;            MoveToEx(dc,i,yy+70,0);&#xA;        else&#xA;            LineTo(dc,i,yy+70);&#xA;    }&#xA;    sprintf(s,&quot;%03d&quot;,start);&#xA;    SetBkColor(dc,0);&#xA;    SetTextColor(dc,0xff00);&#xA;    TextOutA(dc,110,10,s,3);&#xA;    TextOutA(dc,13,71,&quot;0&quot;,1);   &#xA;    TextOutA(dc,11,10,&quot;y&quot;,1);&#xA;    TextOutA(dc,320,75,&quot;x&quot;,1);           &#xA;    Invalidate(img);&#xA;    DeleteObject(pen);&#xA;    DeleteObject(brush);&#xA;}&#xA;&#xA;void OnClose()&#xA;{&#xA;    HideVclWin();&#xA;    CloseVclWin();&#xA;}&#xA;&#xA;void main()&#xA;{&#xA;    HideLeftTools();&#xA;    ClearVclControls();&#xA;    ShowVclWin(200);&#xA;    ShowOutputWin(-1);&#xA;    p=GetGuiWin(1);////&#xA;    CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,20,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮&#xA;    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);&#xA;    img=CreateComponentEx(p,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,340,&quot;height&quot;,150, 0);&#xA;}&#xA;"/>
      <Command cmdname="GDI绘图-在增加的页面中显示-NoOutput" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;#include&quot;libtcc1.c&quot;&#xA;#include&quot;math.h&quot;&#xA;int p; &#xA;int img;&#xA;HANDLE dc;&#xA;int start=0;&#xA;void OnTimer()&#xA;{   &#xA;    double y;&#xA;    int yy,i;&#xA;    char s[100];&#xA;    //return;&#xA;    RECT rect= {0,0,340,300};&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    HBRUSH brush=CreateSolidBrush(0);&#xA;    FillRect(dc,&amp;rect,brush);&#xA;    start++;start++;&#xA;    start%=80;&#xA;    HPEN pen=CreatePen(PS_SOLID,1,0x104010);&#xA;    SelectObject(dc,pen);&#xA;    MoveToEx(dc,5, 70,0);&#xA;    LineTo(dc,330, 70);&#xA;    MoveToEx(dc,5, 71,0);&#xA;    LineTo(dc,330, 71);&#xA;    for(i=0; i&lt;9; i++)&#xA;    {&#xA;        MoveToEx(dc,20, 10-2,0);&#xA;        LineTo(dc,20-3+i, 10+12);&#xA;    }&#xA;    for(i=0; i&lt;9; i++)&#xA;    {&#xA;        MoveToEx(dc,330, 70,0);&#xA;        LineTo(dc,330-12, 70-3+i);&#xA;    }&#xA;&#xA;&#xA;    MoveToEx(dc,20, 10,0);&#xA;    LineTo(dc,20, 140);&#xA;    MoveToEx(dc,21, 10,0);&#xA;    LineTo(dc,21, 140);&#xA;    DeleteObject(pen);&#xA;    HPEN pen=CreatePen(PS_SOLID,1,0xff00);&#xA;    SelectObject(dc,pen);&#xA;    for(i=20; i&lt;320; i++) //&#xA;    {&#xA;        y=sin(3.14*2*(i+start)/80) ;&#xA;        yy=y*20;&#xA;        //dc=GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;        if(i==20)&#xA;            MoveToEx(dc,i,yy+70,0);&#xA;        else&#xA;            LineTo(dc,i,yy+70);&#xA;    }&#xA;    sprintf(s,&quot;%03d&quot;,start);&#xA;    SetBkColor(dc,0);&#xA;    SetTextColor(dc,0xff00);&#xA;    TextOutA(dc,110,10,s,3);&#xA;    TextOutA(dc,13,71,&quot;0&quot;,1);   &#xA;    TextOutA(dc,11,10,&quot;y&quot;,1);&#xA;    TextOutA(dc,320,75,&quot;x&quot;,1);           &#xA;    Invalidate(img);&#xA;    DeleteObject(pen);&#xA;    DeleteObject(brush);&#xA;}&#xA;&#xA;void OnClose()&#xA;{&#xA;    HideVclWin();&#xA;    CloseVclWin();&#xA;}&#xA;&#xA;void main()&#xA;{&#xA;    HideLeftTools();&#xA;    ClearVclControls();&#xA;    HideVclWin();&#xA;     &#xA;    p=GetGuiWin(1);////&#xA;    CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,20,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮&#xA;    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);&#xA;    img=CreateComponentEx(p,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,340,&quot;height&quot;,150, 0);&#xA;}&#xA;"/>
      <Command cmdname="OpenGL 汉字显示（ftgl_ttf、shx）" cmdType="P" cmd="[P]#include &lt;windows.h&gt;		// Header File For Windows&#xA;#include &lt;stdio.h&gt;			// Header File For Standard Input/Output&#xA;#include &lt;gl\gl.h&gt;			// Header File For The OpenGL32 Library&#xA;#include &lt;gl\glu.h&gt;			// Header File For The GLu32 Library&#xA;#include &lt;gl\glaux.h&gt;		// Header File For The Glaux Library&#xA;//#include&quot;libtcc1.c&quot;&#xA;#include&quot;math.h&quot;&#xA;#pragma comment(lib,&quot;ftgl.def&quot;);&#xA;#pragma comment(lib,&quot;lib\\shx.o&quot;);&#xA;#define bool unsigned char&#xA;int closing=0;&#xA;// Private GDI Device Context&#xA;HGLRC		hRC=NULL;		// Permanent Rendering Context&#xA;HWND		hWnd=NULL;		// Holds Our Window Handle&#xA;HINSTANCE	hInstance;		// Holds The Instance Of The Application&#xA;&#xA;GLuint	base;				// Base Display List For The Font Set&#xA;GLfloat	cnt1;				// 1st Counter Used To Move Text &amp; For Coloring&#xA;GLfloat	cnt2;				// 2nd Counter Used To Move Text &amp; For Coloring&#xA;&#xA;bool	keys[256];			// Array Used For The Keyboard Routine&#xA;bool	active=TRUE;		// Window Active Flag Set To TRUE By Default&#xA;bool	fullscreen=TRUE;	// Fullscreen Flag Set To Fullscreen Mode By Default&#xA;&#xA;HGLRC hglrc;&#xA;HDC hdc;&#xA;int img;&#xA;int pnl;&#xA;int GuiMode=2,pfm;&#xA;int *ft;&#xA;void formcreate()&#xA;{&#xA;    hdc=GetDC(GetFormHandle(pfm));&#xA;    //hdc=(HANDLE)GetProperty(pnl,&quot;dc&quot;,0,0,0);&#xA;    int nPixelFormat;&#xA;    /* static PIXELFORMATDESCRIPTOR pfd=&#xA;     {&#xA;         sizeof(PIXELFORMATDESCRIPTOR),&#xA;         1,&#xA;         PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,&#xA;         PFD_TYPE_RGBA,&#xA;         24,&#xA;         0,0,0,0,0,&#xA;         0,0,&#xA;         0,0,0,0,0,&#xA;         32,&#xA;         0,&#xA;         0,&#xA;         PFD_MAIN_PLANE,&#xA;         0,&#xA;         0,0,0&#xA;     };*/&#xA;    static	PIXELFORMATDESCRIPTOR pfd=				// pfd Tells Windows How We Want Things To Be&#xA;    {&#xA;        sizeof(PIXELFORMATDESCRIPTOR),				// Size Of This Pixel Format Descriptor&#xA;        1,											// Version Number&#xA;        PFD_DRAW_TO_WINDOW |						// Format Must Support Window&#xA;        PFD_SUPPORT_OPENGL |						// Format Must Support OpenGL&#xA;        PFD_DOUBLEBUFFER,							// Must Support Double Buffering&#xA;        PFD_TYPE_RGBA,								// Request An RGBA Format&#xA;        24,										// Select Our Color Depth&#xA;        0, 0, 0, 0, 0, 0,							// Color Bits Ignored&#xA;        0,											// No Alpha Buffer&#xA;        0,											// Shift Bit Ignored&#xA;        0,											// No Accumulation Buffer&#xA;        0, 0, 0, 0,									// Accumulation Bits Ignored&#xA;        16,											// 16Bit Z-Buffer (Depth Buffer)&#xA;        0,											// No Stencil Buffer&#xA;        0,											// No Auxiliary Buffer&#xA;        PFD_MAIN_PLANE,								// Main Drawing Layer&#xA;        0,											// Reserved&#xA;        0, 0, 0										// Layer Masks Ignored&#xA;    };&#xA;&#xA;    nPixelFormat=ChoosePixelFormat(hdc,&amp;pfd);&#xA;    SetPixelFormat(hdc,nPixelFormat,&amp;pfd);&#xA;&#xA;    hglrc=wglCreateContext(hdc);&#xA;    wglMakeCurrent(hdc,hglrc);&#xA;}&#xA;//---------------------------------------------------------------------------&#xA;GLvoid KillFont(GLvoid)									// Delete The Font List&#xA;{&#xA;    glDeleteLists(base, 96);							// Delete All 96 Characters&#xA;}&#xA;void  FormDestroy()&#xA;{&#xA;    closing=1;&#xA;    Wait(1);&#xA;    wglMakeCurrent(NULL,NULL);&#xA;    wglDeleteContext(hglrc);&#xA;    DeleteObject(hdc);&#xA;&#xA;    printf(&quot;destroy&quot;);&#xA;}&#xA;&#xA;&#xA;void OnClose()&#xA;{&#xA;    closing=1;&#xA;    Wait(1);&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;    {&#xA;        ClearVclControls();&#xA;        HideVclWin(200);&#xA;    }&#xA;    else&#xA;    {&#xA;        CloseForm(pfm);&#xA;    }&#xA;}&#xA;GLvoid BuildFont(GLvoid)								// Build Our Bitmap Font&#xA;{&#xA;    HFONT	font;										// Windows Font ID&#xA;    HFONT	oldfont;									// Used For Good House Keeping&#xA;&#xA;    base = glGenLists(96);								// Storage For 96 Characters&#xA;&#xA;    font = CreateFont(	-24,							// Height Of Font&#xA;                        0,								// Width Of Font&#xA;                        0,								// Angle Of Escapement&#xA;                        0,								// Orientation Angle&#xA;                        FW_BOLD,						// Font Weight&#xA;                        FALSE,							// Italic&#xA;                        FALSE,							// Underline&#xA;                        FALSE,							// Strikeout&#xA;                        ANSI_CHARSET,					// Character Set Identifier&#xA;                        OUT_TT_PRECIS,					// Output Precision&#xA;                        CLIP_DEFAULT_PRECIS,			// Clipping Precision&#xA;                        ANTIALIASED_QUALITY,			// Output Quality&#xA;                        FF_DONTCARE|DEFAULT_PITCH,		// Family And Pitch&#xA;                        &quot;Courier New&quot;);					// Font Name&#xA;&#xA;    printf(&quot;font:%x&quot;,font);&#xA;    oldfont = (HFONT)SelectObject(hdc, font);           // Selects The Font We Want&#xA;    wglUseFontBitmaps(hdc, 32, 96, base);				// Builds 96 Characters Starting At Character 32&#xA;    SelectObject(hdc, oldfont);							// Selects The Font We Want&#xA;    DeleteObject(font);									// Delete The Font&#xA;}&#xA;&#xA;GLvoid KillFont(GLvoid)									// Delete The Font List&#xA;{&#xA;    glDeleteLists(base, 96);							// Delete All 96 Characters&#xA;}&#xA;void DrawLine(double x0,double y0,double x1,double y1)&#xA;{&#xA;    glBegin(GL_LINES);&#xA;    glVertex3f(x0,y0, 0.0f);&#xA;    glVertex3f(x1,y1, 0.0f);&#xA;    glEnd();&#xA;}&#xA;&#xA;GLvoid glPrint(const char *fmt, ...)					// Custom GL &quot;Print&quot; Routine&#xA;{&#xA;    char		text[256];								// Holds Our String&#xA;    va_list		ap;										// Pointer To List Of Arguments&#xA;&#xA;    if (fmt == NULL)									// If There's No Text&#xA;        return;											// Do Nothing&#xA;&#xA;    va_start(ap, fmt);									// Parses The String For Variables&#xA;    vsprintf(text, fmt, ap);						// And Converts Symbols To Actual Numbers&#xA;    va_end(ap);											// Results Are Stored In Text&#xA;    //printf(text);&#xA;    glPushAttrib(GL_LIST_BIT);							// Pushes The Display List Bits&#xA;    glListBase(base - 32);								// Sets The Base Character to 32&#xA;    glCallLists(strlen(text), GL_UNSIGNED_BYTE, text);	// Draws The Display List Text&#xA;    glPopAttrib();										// Pops The Display List Bits&#xA;}&#xA;GLvoid glShxPrint(const char *fmt, ...)					// Custom GL &quot;Print&quot; Routine&#xA;{&#xA;    char		text[256];								// Holds Our String&#xA;    va_list		ap;										// Pointer To List Of Arguments&#xA;    int i=0;&#xA;    if (fmt == NULL)									// If There's No Text&#xA;        return;											// Do Nothing&#xA;&#xA;    va_start(ap, fmt);									// Parses The String For Variables&#xA;    vsprintf(text, fmt, ap);						// And Converts Symbols To Actual Numbers&#xA;    va_end(ap);											// Results Are Stored In Text&#xA;    while(text[i])&#xA;    {&#xA;        ReadCharShape(text[i],0);&#xA;        glTranslatef(10,0.0f,0.0f);&#xA;        i++;&#xA;    }&#xA;}&#xA;GLvoid ReSizeGLScene(GLsizei width, GLsizei height)		// Resize And Initialize The GL Window&#xA;{&#xA;    if (height==0)										// Prevent A Divide By Zero By&#xA;    {&#xA;        height=1;										// Making Height Equal One&#xA;    }&#xA;&#xA;    glViewport(0,0,width,height);						// Reset The Current Viewport&#xA;&#xA;    glMatrixMode(GL_PROJECTION);						// Select The Projection Matrix&#xA;    glLoadIdentity();									// Reset The Projection Matrix&#xA;&#xA;    // Calculate The Aspect Ratio Of The Window&#xA;    gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f);&#xA;&#xA;    glMatrixMode(GL_MODELVIEW);							// Select The Modelview Matrix&#xA;    glLoadIdentity();									// Reset The Modelview Matrix&#xA;}&#xA;#define FT_ENC_TAG( value, a, b, c, d )         \&#xA;          unsigned int value = ( ( (int)(a) &lt;&lt; 24 ) |  \&#xA;                    ( (int)(b) &lt;&lt; 16 ) |  \&#xA;                    ( (int)(c) &lt;&lt;  8 ) |  \&#xA;                      (int)(d)         )&#xA;&#xA;&#xA;FT_ENC_TAG( FT_ENCODING_UNICODE,   'u', 'n', 'i', 'c' );&#xA;&#xA;int InitGL(GLvoid)										// All Setup For OpenGL Goes Here&#xA;{&#xA;    int r;&#xA;    glShadeModel(GL_SMOOTH);							// Enable Smooth Shading&#xA;    glClearColor(0.0f, 0.0f, 0.0f, 0.5f);				// Black Background&#xA;    glClearDepth(1.0f);									// Depth Buffer Setup&#xA;    glEnable(GL_DEPTH_TEST);							// Enables Depth Testing&#xA;    glDepthFunc(GL_LEQUAL);								// The Type Of Depth Testing To Do&#xA;    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);	// Really Nice Perspective Calculations&#xA;&#xA;    BuildFont();										// Build The Font&#xA;&#xA;    ft=ftglCreateBufferFont(&quot;c:\\windows\\fonts\\simhei.ttf&quot;);&#xA;    ftglSetFontFaceSize(ft, 37, 72);&#xA;    ftglSetFontDepth(ft, 10);&#xA;    ftglSetFontOutset(ft, 0, 3);&#xA;&#xA;    r=ftglSetFontCharMap(ft, FT_ENCODING_UNICODE);&#xA;    printf(&quot;glft:%x,set char map:%d&quot;,ft,r);&#xA;    return TRUE;										// Initialization Went OK&#xA;}&#xA;int AnsiToUnicode(unsigned char *pszA, unsigned char* ppszW)&#xA;{&#xA;    ULONG cCharacters;&#xA;    DWORD dwError;&#xA;    if (NULL == pszA)&#xA;    {&#xA;        *ppszW = NULL;&#xA;        printf(&quot;ERROR0&quot;);&#xA;        return NOERROR;&#xA;    }&#xA;    cCharacters =  strlen(pszA)+1;&#xA;    if (NULL == ppszW)&#xA;        return E_OUTOFMEMORY;&#xA;    // Covert to Unicode.&#xA;    if (0 == MultiByteToWideChar(CP_ACP, 0, pszA, -1,&#xA;                                 ppszW, cCharacters))&#xA;    {&#xA;        dwError = GetLastError();&#xA;        free(ppszW);&#xA;        ppszW = NULL;&#xA;        printf(&quot;ERROR&quot;);&#xA;        return HRESULT_FROM_WIN32(dwError);&#xA;    }&#xA;    return NOERROR;&#xA;}&#xA;int DrawGLScene(GLvoid)									// Here's Where We Do All The Drawing&#xA;{&#xA;    char buf[]= {0x31,0,0x32,0,0x8d,0x9c,0,0};&#xA;    char buf1[100];&#xA;    int i;&#xA;    AnsiToUnicode(&quot;ftgl(TTF): Name 中国 0086&quot;,buf1);&#xA;    &#xA;&#xA;    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear Screen And Depth Buffer&#xA;    glLoadIdentity();									// Reset The Current Modelview Matrix&#xA;    glTranslatef(-1.0f,0.0f,-6.0f);						// Move One Unit Into The Screen&#xA;    // Pulsing Colors Based On Text Position&#xA;    glColor3f(1.0f ,0.0f ,1.0f );&#xA;    // Position The Text On The Screen&#xA;    glScalef(0.01,0.01,0.01);&#xA;&#xA;      &#xA;    glLoadIdentity();	&#xA;    glTranslatef(-1.0f,0.0f,-6.0f);		&#xA;    glRasterPos2f( -3, -1);&#xA;    glPrint(&quot;Active OpenGL Text With NeHe - &quot;);	// Print GL Text To The Screen&#xA;    &#xA;    /////////////ftgl/////////////////////&#xA;    glLoadIdentity();&#xA;    glTranslatef(-3.0f,0.0f,-6.0f);	&#xA;    glScalef(0.01,0.01,0.01);&#xA;    ftglRenderFontW(ft, buf1, 0xffff);&#xA;    /////////////shx/////////////////////&#xA;    glLoadIdentity();&#xA;    glTranslatef(-3.0f,1.0f,-6.0f);&#xA;    glRasterPos2f(0, 0);&#xA;    glScalef(0.02,0.02,1);&#xA;    glShxPrint(&quot;AutoCAD shx Font:12345!&quot;);&#xA;    cnt1+=0.051f;										// Increase The First Counter&#xA;    cnt2+=0.005f;&#xA;    SwapBuffers(hdc);										// Increase The First Counter&#xA;    return TRUE;										// Everything Went OK&#xA;}&#xA;&#xA;&#xA;void OnTimer()&#xA;{&#xA;    DrawGLScene();&#xA;}&#xA;&#xA;void OnTest()&#xA;{&#xA;    DrawGLScene();&#xA;}&#xA;void OnResize()&#xA;{&#xA;    int x,y;&#xA;    x=GetProperty(pfm,&quot;width&quot;,0,0);&#xA;    y=GetProperty(pfm,&quot;height&quot;,0,0);&#xA;    ReSizeGLScene(x,y);&#xA;}&#xA;&#xA;void main()&#xA;{&#xA;&#xA;    int i,j;&#xA;    int mi,mi1;&#xA;    //HideLeftTools();&#xA;    ClearVclControls();&#xA;    //ShowVclWin(-1);&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;        pfm=GetGuiWin(GuiMode);&#xA;    else&#xA;        pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;调幅-正弦波&quot;,&quot;Width&quot;,600,&quot;height&quot;,300,&quot;BorderIcons&quot;,&quot;[biSystemMenu,biMaximize]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnClose&quot;,FormDestroy,&quot;OnResize&quot;,OnResize,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;    int btn=CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);&#xA;    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;test&quot;,&quot;left&quot;,80,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnTest,0);&#xA;    //img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,200,&quot;height&quot;,200,0);&#xA;    SetProperty(pfm,&quot;visible&quot;,1);////&#xA;    formcreate();&#xA;    OnResize();&#xA;    InitGL();&#xA;    DrawGLScene();&#xA;    ReaderShxFile(&quot;dat\\txt.shx&quot;);&#xA;    int count=0;&#xA;    while(!closing)&#xA;    {&#xA;        DrawGLScene();&#xA;        count++;&#xA;        if(count%5==4)&#xA;        {&#xA;            //printf(&quot;count:%d&quot;,count);&#xA;            Wait(1);&#xA;        }&#xA;&#xA;&#xA;    }&#xA;    printf(&quot;exit&quot;);&#xA;&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;"/>
      <Command cmdname="OpenGL 汉字显示(ftgl、shx)" cmdType="P" cmd="[P]#include &lt;windows.h&gt;		// Header File For Windows&#xA;#include &lt;stdio.h&gt;			// Header File For Standard Input/Output&#xA;#include &lt;gl\gl.h&gt;			// Header File For The OpenGL32 Library&#xA;#include &lt;gl\glu.h&gt;			// Header File For The GLu32 Library&#xA;#include &lt;gl\glaux.h&gt;		// Header File For The Glaux Library&#xA;//#include&quot;libtcc1.c&quot;&#xA;#include&quot;math.h&quot;&#xA;#pragma comment(lib,&quot;lib\\ftgl.def&quot;);&#xA;#pragma comment(lib,&quot;lib\\shx.o&quot;);&#xA;#define bool unsigned char&#xA;int closing=0;&#xA;typedef struct CharIndex&#xA;{&#xA;    int code;&#xA;    int shapePtr;&#xA;    int len;&#xA;} CharIndex;&#xA;&#xA;&#xA;&#xA;typedef struct _ShxFont_&#xA;{&#xA;    int openOK;&#xA;    int indexCount;&#xA;    unsigned char *buffer;&#xA;    CharIndex *indexBuffer;&#xA;    int type;&#xA;    int shxFontDownLine,shxFontUpLine;&#xA;    double scale;&#xA;} ShxFont;&#xA;&#xA;ShxFont *sf;&#xA;// Private GDI Device Context&#xA;HGLRC		hRC=NULL;		// Permanent Rendering Context&#xA;HWND		hWnd=NULL;		// Holds Our Window Handle&#xA;HINSTANCE	hInstance;		// Holds The Instance Of The Application&#xA;&#xA;GLuint	base;				// Base Display List For The Font Set&#xA;GLfloat	cnt1;				// 1st Counter Used To Move Text &amp; For Coloring&#xA;GLfloat	cnt2;				// 2nd Counter Used To Move Text &amp; For Coloring&#xA;&#xA;bool	keys[256];			// Array Used For The Keyboard Routine&#xA;bool	active=TRUE;		// Window Active Flag Set To TRUE By Default&#xA;bool	fullscreen=TRUE;	// Fullscreen Flag Set To Fullscreen Mode By Default&#xA;&#xA;HGLRC hglrc;&#xA;HDC hdc;&#xA;int img;&#xA;int pnl;&#xA;int GuiMode=2,pfm;&#xA;int *ft;&#xA;void formcreate()&#xA;{&#xA;    hdc=GetDC(GetFormHandle(pfm));&#xA;    //hdc=(HANDLE)GetProperty(pnl,&quot;dc&quot;,0,0,0);&#xA;    int nPixelFormat;&#xA;    /* static PIXELFORMATDESCRIPTOR pfd=&#xA;     {&#xA;         sizeof(PIXELFORMATDESCRIPTOR),&#xA;         1,&#xA;         PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,&#xA;         PFD_TYPE_RGBA,&#xA;         24,&#xA;         0,0,0,0,0,&#xA;         0,0,&#xA;         0,0,0,0,0,&#xA;         32,&#xA;         0,&#xA;         0,&#xA;         PFD_MAIN_PLANE,&#xA;         0,&#xA;         0,0,0&#xA;     };*/&#xA;    static	PIXELFORMATDESCRIPTOR pfd=				// pfd Tells Windows How We Want Things To Be&#xA;    {&#xA;        sizeof(PIXELFORMATDESCRIPTOR),				// Size Of This Pixel Format Descriptor&#xA;        1,											// Version Number&#xA;        PFD_DRAW_TO_WINDOW |						// Format Must Support Window&#xA;        PFD_SUPPORT_OPENGL |						// Format Must Support OpenGL&#xA;        PFD_DOUBLEBUFFER,							// Must Support Double Buffering&#xA;        PFD_TYPE_RGBA,								// Request An RGBA Format&#xA;        24,										// Select Our Color Depth&#xA;        0, 0, 0, 0, 0, 0,							// Color Bits Ignored&#xA;        0,											// No Alpha Buffer&#xA;        0,											// Shift Bit Ignored&#xA;        0,											// No Accumulation Buffer&#xA;        0, 0, 0, 0,									// Accumulation Bits Ignored&#xA;        16,											// 16Bit Z-Buffer (Depth Buffer)&#xA;        0,											// No Stencil Buffer&#xA;        0,											// No Auxiliary Buffer&#xA;        PFD_MAIN_PLANE,								// Main Drawing Layer&#xA;        0,											// Reserved&#xA;        0, 0, 0										// Layer Masks Ignored&#xA;    };&#xA;&#xA;    nPixelFormat=ChoosePixelFormat(hdc,&amp;pfd);&#xA;    SetPixelFormat(hdc,nPixelFormat,&amp;pfd);&#xA;&#xA;    hglrc=wglCreateContext(hdc);&#xA;    wglMakeCurrent(hdc,hglrc);&#xA;}&#xA;//---------------------------------------------------------------------------&#xA;GLvoid KillFont(GLvoid)									// Delete The Font List&#xA;{&#xA;    glDeleteLists(base, 96);							// Delete All 96 Characters&#xA;}&#xA;void  FormDestroy()&#xA;{&#xA;    closing=1;&#xA;    Wait(1);&#xA;    wglMakeCurrent(NULL,NULL);&#xA;    wglDeleteContext(hglrc);&#xA;    DeleteObject(hdc);&#xA;&#xA;    printf(&quot;destroy&quot;);&#xA;}&#xA;&#xA;&#xA;void OnClose()&#xA;{&#xA;    closing=1;&#xA;    Wait(1);&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;    {&#xA;        ClearVclControls();&#xA;        HideVclWin(200);&#xA;    }&#xA;    else&#xA;    {&#xA;        CloseForm(pfm);&#xA;    }&#xA;}&#xA;GLvoid BuildFont(GLvoid)								// Build Our Bitmap Font&#xA;{&#xA;    HFONT	font;										// Windows Font ID&#xA;    HFONT	oldfont;									// Used For Good House Keeping&#xA;&#xA;    base = glGenLists(96);								// Storage For 96 Characters&#xA;&#xA;    font = CreateFont(	-24,							// Height Of Font&#xA;                        0,								// Width Of Font&#xA;                        0,								// Angle Of Escapement&#xA;                        0,								// Orientation Angle&#xA;                        FW_BOLD,						// Font Weight&#xA;                        FALSE,							// Italic&#xA;                        FALSE,							// Underline&#xA;                        FALSE,							// Strikeout&#xA;                        ANSI_CHARSET,					// Character Set Identifier&#xA;                        OUT_TT_PRECIS,					// Output Precision&#xA;                        CLIP_DEFAULT_PRECIS,			// Clipping Precision&#xA;                        ANTIALIASED_QUALITY,			// Output Quality&#xA;                        FF_DONTCARE|DEFAULT_PITCH,		// Family And Pitch&#xA;                        &quot;Courier New&quot;);					// Font Name&#xA;&#xA;    printf(&quot;font:%x&quot;,font);&#xA;    oldfont = (HFONT)SelectObject(hdc, font);           // Selects The Font We Want&#xA;    wglUseFontBitmaps(hdc, 32, 96, base);				// Builds 96 Characters Starting At Character 32&#xA;    SelectObject(hdc, oldfont);							// Selects The Font We Want&#xA;    DeleteObject(font);									// Delete The Font&#xA;}&#xA;&#xA;GLvoid KillFont(GLvoid)									// Delete The Font List&#xA;{&#xA;    glDeleteLists(base, 96);							// Delete All 96 Characters&#xA;}&#xA;void DrawLine0(double x0,double y0,double x1,double y1)&#xA;{&#xA;    glBegin(GL_LINES);&#xA;    glVertex3f(x0,y0, 0.0f);&#xA;    glVertex3f(x1,y1, 0.0f);&#xA;    glEnd();&#xA;}&#xA;void DrawLine(ShxFont *sf,double x0,double y0,double x1,double y1)&#xA;{&#xA;    double scale;&#xA;    scale=5.0/GetShxFontHeight(sf)*1.0* sf-&gt;scale;// 0.08;&#xA;    x0*=scale;&#xA;    y0*=scale;&#xA;    x1*=scale;&#xA;    y1*=scale;&#xA;    x0+=0;&#xA;    x1+=0;&#xA;&#xA;    glBegin(GL_LINES);&#xA;    glVertex3f(x0,y0, 0.0f);&#xA;    glVertex3f(x1,y1, 0.0f);&#xA;    glEnd();&#xA;}&#xA;GLvoid glPrint(const char *fmt, ...)					// Custom GL &quot;Print&quot; Routine&#xA;{&#xA;    char		text[256];								// Holds Our String&#xA;    va_list		ap;										// Pointer To List Of Arguments&#xA;&#xA;    if (fmt == NULL)									// If There's No Text&#xA;        return;											// Do Nothing&#xA;&#xA;    va_start(ap, fmt);									// Parses The String For Variables&#xA;    vsprintf(text, fmt, ap);						// And Converts Symbols To Actual Numbers&#xA;    va_end(ap);											// Results Are Stored In Text&#xA;    //printf(text);&#xA;    glPushAttrib(GL_LIST_BIT);							// Pushes The Display List Bits&#xA;    glListBase(base - 32);								// Sets The Base Character to 32&#xA;    glCallLists(strlen(text), GL_UNSIGNED_BYTE, text);	// Draws The Display List Text&#xA;    glPopAttrib();										// Pops The Display List Bits&#xA;}&#xA;GLvoid glShxPrint(ShxFont *sf,const char *fmt, ...)					// Custom GL &quot;Print&quot; Routine&#xA;{&#xA;    char		text[256];								// Holds Our String&#xA;    va_list		ap;										// Pointer To List Of Arguments&#xA;    int i=0;&#xA;    if (fmt == NULL)									// If There's No Text&#xA;        return;											// Do Nothing&#xA;    &#xA;    va_start(ap, fmt);									// Parses The String For Variables&#xA;    vsprintf(text, fmt, ap);						// And Converts Symbols To Actual Numbers&#xA;    va_end(ap);											// Results Are Stored In Text&#xA;    while(text[i])&#xA;    {&#xA;        ReadCharShape(sf,text[i],0);&#xA;        glTranslatef(14,0.0f,0.0f);&#xA;        i++;&#xA;    }&#xA;}&#xA;GLvoid ReSizeGLScene(GLsizei width, GLsizei height)		// Resize And Initialize The GL Window&#xA;{&#xA;    if (height==0)										// Prevent A Divide By Zero By&#xA;    {&#xA;        height=1;										// Making Height Equal One&#xA;    }&#xA;&#xA;    glViewport(0,0,width,height);						// Reset The Current Viewport&#xA;&#xA;    glMatrixMode(GL_PROJECTION);						// Select The Projection Matrix&#xA;    glLoadIdentity();									// Reset The Projection Matrix&#xA;&#xA;    // Calculate The Aspect Ratio Of The Window&#xA;    gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f);&#xA;&#xA;    glMatrixMode(GL_MODELVIEW);							// Select The Modelview Matrix&#xA;    glLoadIdentity();									// Reset The Modelview Matrix&#xA;}&#xA;#define FT_ENC_TAG( value, a, b, c, d )         \&#xA;          unsigned int value = ( ( (int)(a) &lt;&lt; 24 ) |  \&#xA;                    ( (int)(b) &lt;&lt; 16 ) |  \&#xA;                    ( (int)(c) &lt;&lt;  8 ) |  \&#xA;                      (int)(d)         )&#xA;&#xA;&#xA;FT_ENC_TAG( FT_ENCODING_UNICODE,   'u', 'n', 'i', 'c' );&#xA;&#xA;int InitGL(GLvoid)										// All Setup For OpenGL Goes Here&#xA;{&#xA;    int r;&#xA;    glShadeModel(GL_SMOOTH);							// Enable Smooth Shading&#xA;    glClearColor(0.0f, 0.0f, 0.0f, 0.5f);				// Black Background&#xA;    glClearDepth(1.0f);									// Depth Buffer Setup&#xA;    glEnable(GL_DEPTH_TEST);							// Enables Depth Testing&#xA;    glDepthFunc(GL_LEQUAL);								// The Type Of Depth Testing To Do&#xA;    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);	// Really Nice Perspective Calculations&#xA;&#xA;    BuildFont();										// Build The Font&#xA;&#xA;    ft=ftglCreateBufferFont(&quot;c:\\windows\\fonts\\simhei.ttf&quot;);&#xA;    ftglSetFontFaceSize(ft, 37, 72);&#xA;    ftglSetFontDepth(ft, 10);&#xA;    ftglSetFontOutset(ft, 0, 3);&#xA;&#xA;    r=ftglSetFontCharMap(ft, FT_ENCODING_UNICODE);&#xA;    printf(&quot;glft:%x,set char map:%d&quot;,ft,r);&#xA;    return TRUE;										// Initialization Went OK&#xA;}&#xA;int AnsiToUnicode(unsigned char *pszA, unsigned char* ppszW)&#xA;{&#xA;    ULONG cCharacters;&#xA;    DWORD dwError;&#xA;    if (NULL == pszA)&#xA;    {&#xA;        *ppszW = NULL;&#xA;        printf(&quot;ERROR0&quot;);&#xA;        return NOERROR;&#xA;    }&#xA;    cCharacters =  strlen(pszA)+1;&#xA;    if (NULL == ppszW)&#xA;        return E_OUTOFMEMORY;&#xA;    // Covert to Unicode.&#xA;    if (0 == MultiByteToWideChar(CP_ACP, 0, pszA, -1,&#xA;                                 ppszW, cCharacters))&#xA;    {&#xA;        dwError = GetLastError();&#xA;        free(ppszW);&#xA;        ppszW = NULL;&#xA;        printf(&quot;ERROR&quot;);&#xA;        return HRESULT_FROM_WIN32(dwError);&#xA;    }&#xA;    return NOERROR;&#xA;}&#xA;int DrawGLScene(GLvoid)									// Here's Where We Do All The Drawing&#xA;{&#xA;    char buf[]= {0x31,0,0x32,0,0x8d,0x9c,0,0};&#xA;    char buf1[100];&#xA;    int i;&#xA;    AnsiToUnicode(&quot;ftgl(TTF): Name 中国 0086&quot;,buf1);&#xA;    &#xA;&#xA;    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear Screen And Depth Buffer&#xA;    glLoadIdentity();									// Reset The Current Modelview Matrix&#xA;    glTranslatef(-1.0f,0.0f,-6.0f);						// Move One Unit Into The Screen&#xA;    // Pulsing Colors Based On Text Position&#xA;    glColor3f(1.0f ,0.0f ,1.0f );&#xA;    // Position The Text On The Screen&#xA;    glScalef(0.01,0.01,0.01);&#xA;&#xA;      &#xA;    glLoadIdentity();	&#xA;    glTranslatef(-1.0f,0.0f,-6.0f);		&#xA;    glRasterPos2f( -3, -1);&#xA;    glPrint(&quot;Active OpenGL Text With NeHe - &quot;);	// Print GL Text To The Screen&#xA;    &#xA;    /////////////ftgl/////////////////////&#xA;    glLoadIdentity();&#xA;    glTranslatef(-3.0f,0.0f,-6.0f);	&#xA;    glScalef(0.01,0.01,0.01);&#xA;    ftglRenderFontW(ft, buf1, 0xffff);&#xA;    /////////////shx/////////////////////&#xA;    glLoadIdentity();&#xA;    glTranslatef(-3.0f,1.0f,-6.0f);&#xA;    glRasterPos2f(0, 0);&#xA;    glScalef(0.02,0.02,1);&#xA;    glShxPrint(sf,&quot;AutoCAD shx Font:12345!&quot;);&#xA;    cnt1+=0.051f;										// Increase The First Counter&#xA;    cnt2+=0.005f;&#xA;    SwapBuffers(hdc);										// Increase The First Counter&#xA;    return TRUE;										// Everything Went OK&#xA;}&#xA;&#xA;&#xA;void OnTimer()&#xA;{&#xA;    DrawGLScene();&#xA;}&#xA;&#xA;void OnTest()&#xA;{&#xA;    DrawGLScene();&#xA;}&#xA;void OnResize()&#xA;{&#xA;    int x,y;&#xA;    x=GetProperty(pfm,&quot;width&quot;,0,0);&#xA;    y=GetProperty(pfm,&quot;height&quot;,0,0);&#xA;    ReSizeGLScene(x,y);&#xA;}&#xA;&#xA;void main()&#xA;{&#xA;&#xA;    int i,j;&#xA;    int mi,mi1;&#xA;    //HideLeftTools();&#xA;    ClearVclControls();&#xA;    //ShowVclWin(-1);&#xA;    if((GuiMode==0)||(GuiMode==1))&#xA;        pfm=GetGuiWin(GuiMode);&#xA;    else&#xA;        pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;调幅-正弦波&quot;,&quot;Width&quot;,600,&quot;height&quot;,300,&quot;BorderIcons&quot;,&quot;[biSystemMenu,biMaximize]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnClose&quot;,FormDestroy,&quot;OnResize&quot;,OnResize,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;    int btn=CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);&#xA;    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;test&quot;,&quot;left&quot;,80,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnTest,0);&#xA;    //img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,200,&quot;height&quot;,200,0);&#xA;    SetProperty(pfm,&quot;visible&quot;,1);////&#xA;    formcreate();&#xA;    OnResize();&#xA;    InitGL();&#xA;    sf=CreateShxFont(&quot;dat\\txt.shx&quot;);&#xA;    DrawGLScene();&#xA;    &#xA;    int count=0;&#xA;    while(!closing)&#xA;    {&#xA;        DrawGLScene();&#xA;        count++;&#xA;        if(count%5==4)&#xA;        {&#xA;            //printf(&quot;count:%d&quot;,count);&#xA;            Wait(1);&#xA;        }&#xA;&#xA;&#xA;    }&#xA;    printf(&quot;exit&quot;);&#xA;&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;"/>
    </Command>
    <Command cmdname="游戏脚本编程" cmdType="S" cmd="[S]数据发送区/C语言脚本编辑区，[F5]键发送/执行。">
      <Command cmdname="俄罗斯方块" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;#include&quot;libtcc1.c&quot;&#xA;#include&quot;math.h&quot;&#xA;&#xA;#define WHITE 0xffffff&#xA;#define CYAN 0xffff00&#xA;#define YELLOW 0x00ffff&#xA;#define BLACK 0x00000&#xA;#define RED 0x000ff&#xA;#define GREEN 0x000ff00&#xA;&#xA;&#xA;/*定义左上角点在屏幕上的位置*/&#xA;#define MAPXOFT     9&#xA;#define MAPYOFT     5&#xA;&#xA;/*定义下一个方块显示的位置*/&#xA;#define MAPXOFT1     14&#xA;#define MAPYOFT1     -1&#xA;&#xA;&#xA;#define LEFT  37&#xA;#define RIGHT 39&#xA;#define DOWN  40  /*此键为加速键*/&#xA;#define UP    38  /*此键为变形键*/&#xA;#define ESC   27  /*此键为退出键*/&#xA;#define ENTER 13&#xA;&#xA;#ifdef __cplusplus&#xA;#define __CPPARGS ...&#xA;#else&#xA;#define __CPPARGS&#xA;#endif&#xA;&#xA;struct shape&#xA;{&#xA;    int xy[8],next;&#xA;};&#xA;&#xA;&#xA;struct shape shapes[19]=&#xA;{&#xA;    /*x1,y1,x2,y2,x3,y3,x4,y4 指四个小方块的相对坐标，next指此方块变形后应变为哪个小方块&#xA;        { x1,y1,x2,y2,x3,y3,x4,y4,next}*/&#xA;    { 0,-2, 0,-1, 0, 0, 1, 0, 1},&#xA;    {-1, 0, 0, 0, 1,-1, 1, 0, 2},&#xA;    { 0,-2, 1,-2, 1,-1, 1, 0, 3},&#xA;    {-1,-1,-1, 0, 0,-1, 1,-1, 0},&#xA;    { 0,-2, 0,-1, 0, 0, 1,-2, 5},&#xA;    {-1,-1, 0,-1, 1,-1, 1, 0, 6},&#xA;    { 0, 0, 1,-2, 1,-1, 1, 0, 7},&#xA;    {-1,-1,-1, 0, 0, 0, 1, 0, 4},&#xA;    {-1, 0, 0,-1, 0, 0, 1, 0, 9},&#xA;    { 0,-2, 0,-1, 0, 0, 1,-1,10},&#xA;    {-1,-1, 0,-1, 1,-1, 0, 0,11},&#xA;    { 0,-1, 1,-2, 1,-1, 1, 0, 8},&#xA;    {-1, 0, 0,-1, 0, 0, 1,-1,13},&#xA;    { 0,-2, 0,-1, 1,-1, 1, 0,12},&#xA;    {-1,-1, 0,-1, 0, 0, 1, 0,15},&#xA;    { 0,-1, 0, 0, 1,-2, 1,-1,14},&#xA;    { 0,-3, 0,-2, 0,-1, 0, 0,17},&#xA;    {-1, 0, 0, 0, 1, 0, 2, 0,16},&#xA;    { 0,-1, 0, 0, 1,-1, 1, 0,18}&#xA;};&#xA;&#xA;int board[10][20]= {0}; /*定义游戏板初始化为0*/&#xA;char sp[]=&quot;0&quot;,le[]=&quot;0&quot;,sc[]=&quot;00000&quot;;&#xA;int speed,speed0,level,score;&#xA;int sign,flag;&#xA;int style,style1;  /*style为当前方块的种类，style1为即将输出的方块的种类*/&#xA;&#xA;void draw_block(int x,int y,int style,int way);&#xA;void draw_little_block(int x,int y);&#xA;void initialize();&#xA;void speed_change(void);&#xA;void score_change(int);&#xA;void kill_line(int y);&#xA;&#xA;void High_line(int y);&#xA;void fill_board(int x,int y, int style);&#xA;int  change(int *i,int *j,int key);&#xA;void renovate(void);&#xA;void ajustment(void);&#xA;void level_change(void);&#xA;&#xA;int needclose=0;&#xA;&#xA;HPEN pen=0;&#xA;HBRUSH brush=0;&#xA;int p;&#xA;int img;&#xA;HANDLE dc;&#xA;int start=0;&#xA;&#xA;int TimerCounter=0; /* 计时变量，每秒钟增加18。 */&#xA;int KeyDown=0;&#xA;&#xA;void OnTimer()&#xA;{&#xA;    TimerCounter++;&#xA;}&#xA;void OnClose()&#xA;{&#xA;    printf(&quot;need close...&quot;);&#xA;    needclose=1;&#xA;    Wait(1);&#xA;    Wait(1);&#xA;    CloseForm(p);&#xA;}&#xA;void OnDblClick()&#xA;{&#xA;    PlayWave(&quot;ding.wav&quot;);&#xA;    KeyDown=ENTER;&#xA;}&#xA;void OnEnter()&#xA;{&#xA;    PlayWave(&quot;ding.wav&quot;);&#xA;    KeyDown=ENTER;&#xA;}&#xA;void OnLeft()&#xA;{&#xA;    KeyDown=LEFT;&#xA;}&#xA;void OnUp()&#xA;{&#xA;    KeyDown=UP;&#xA;}&#xA;void OnRight()&#xA;{&#xA;    KeyDown=RIGHT;&#xA;}&#xA;void OnDown()&#xA;{&#xA;    KeyDown=DOWN;&#xA;}&#xA;&#xA;void OnKeyDown(int id,int *key,int state)&#xA;{&#xA;    KeyDown=*key;&#xA;}&#xA;&#xA;void InitGraph()&#xA;{&#xA;    HideLeftTools();&#xA;    ClearVclControls();&#xA;    HideVclWin(200);&#xA;    //p=GetGuiWin(0);&#xA;    p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;GDI绘图示例-俄罗斯方块&quot;,&quot;Width&quot;,520,&quot;height&quot;,580,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;BorderIcons&quot;,&quot;[]&quot;,&quot;OnKeyDown&quot;,OnKeyDown,&quot;formstyle&quot;,&quot;fsstayontop&quot;,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;    CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,40,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮&#xA;&#xA;&#xA;    CreateComponentEx(p,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);&#xA;    CreateComponentEx(p,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;Enter&quot;,&quot;left&quot;,80,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnEnter,0);&#xA;    CreateComponentEx(p,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;Left&quot;,&quot;left&quot;,150,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnLeft,0);&#xA;    CreateComponentEx(p,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;Up&quot;,&quot;left&quot;,220,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnUp,0);&#xA;    CreateComponentEx(p,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;Right&quot;,&quot;left&quot;,290,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnRight,0);&#xA;    CreateComponentEx(p,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;Down&quot;,&quot;left&quot;,360,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnDown,0);&#xA;&#xA;    img=CreateComponentEx(p,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,480,&quot;height&quot;,480,&quot;OnDblClick&quot;,OnDblClick,0);&#xA;    SetProperty(p,&quot;visible&quot;,1);&#xA;&#xA;    RECT rect= {0,0,640,480};&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    HBRUSH brush=CreateSolidBrush(0x00);&#xA;    SelectObject(dc,brush);&#xA;    FillRect(dc,&amp;rect,brush);&#xA;    DeleteObject(brush);&#xA;}&#xA;void setcolor(int cl)&#xA;{&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    if(pen!=0) DeleteObject(pen);&#xA;    pen=CreatePen(PS_SOLID,1,cl);&#xA;    SelectObject(dc,pen);&#xA;    //if(brush!=0) DeleteObject(brush);&#xA;    //pen=CreateSolidBrush(RED);&#xA;    //SelectObject(dc,brush);    &#xA;    &#xA;}&#xA;int bioskey(int flat)&#xA;{&#xA;    int tmp;&#xA;    if(flat==1)&#xA;    {&#xA;        if(KeyDown!=0)&#xA;            return 1;&#xA;        else&#xA;            return 0;&#xA;    }&#xA;    tmp=KeyDown;&#xA;    KeyDown=0;&#xA;    return tmp;&#xA;&#xA;}&#xA; &#xA;void outtextxy(int x,int y,char *s)&#xA;{&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    TextOutA(dc,x,y,s,strlen(s));&#xA;}&#xA;void  setbkcolor(int cl)&#xA;{&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    SetBkColor(dc,cl);&#xA;}&#xA;&#xA;void   settextcolor(int cl)&#xA;{&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    SetTextColor(dc,cl);&#xA;&#xA;}&#xA;&#xA;&#xA;void line(int x0,int y0,int x1,int y1)&#xA;{&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    MoveToEx(dc,x0,y0,0);&#xA;    LineTo(dc,x1,y1);&#xA;}&#xA;&#xA;void rectangle(int x0,int y0,int x1,int y1)&#xA;{&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    MoveToEx(dc,x0,y0,0);&#xA;    LineTo(dc,x1,y0);&#xA;    LineTo(dc,x1,y1);&#xA;    LineTo(dc,x0,y1);&#xA;    LineTo(dc,x0,y0);&#xA;}&#xA;void circle(int x,int y,int r)&#xA;{&#xA;    int i;&#xA;    for(i=r;i&gt;=0;i-=2)&#xA;    rectangle(x-i/2,y-i/2,x+i/2,y+i/2);&#xA;    //dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    //Ellipse(dc,x-r/2,y-r/2,x+r/2,y+r/2);     &#xA;}&#xA;&#xA;&#xA;main()&#xA;{&#xA;    int i,j,key,x0=5,y0=1;&#xA;    InitGraph();&#xA;&#xA;    while(!flag)                    /*flag为0表示重新开始游戏*/&#xA;    {&#xA;        if(needclose)return;&#xA;        Wait(1);&#xA;        level=score=speed=0;&#xA;        strcpy(le,&quot;0&quot;);&#xA;        strcpy(sp,&quot;0&quot;);&#xA;        strcpy(sc,&quot;00000&quot;);&#xA;        for(i=0; i&lt;10; i++)&#xA;            for(j=0; j&lt;20; j++)&#xA;                board[i][j]=0;       /*初始化一些变量为0*/&#xA;        ajustment();             /*开始游戏前调整速度和高度*/&#xA;&#xA;&#xA;&#xA;        if(level&gt;0)&#xA;            level_change();       /*根据高度随机确定方块是否存在*/&#xA;        style=rand(100)%19;         /*随机确定方块种类*/&#xA;        while(1)&#xA;        {&#xA;            if(needclose)return;&#xA;            Wait(1);&#xA;            i=x0,j=y0;&#xA;            style1=rand(100)%19;    /*随机确定即将出现的方块种类*/&#xA;            setcolor(WHITE);&#xA;            sign=1;&#xA;&#xA;            draw_block(MAPXOFT1,MAPYOFT1,style1,1);/*画出即将出现的方块*/&#xA;&#xA;            speed0=0;&#xA;            for(j=y0; j&lt;=20; j++) /*使方块下降*/&#xA;            {&#xA;                if(needclose)return;&#xA;                if(!check_block(i,j,style))&#xA;                {&#xA;                    draw_block(i,j-1,style,1);&#xA;                    renovate();&#xA;                    break;&#xA;                }&#xA;                if(speed0!=9)&#xA;                    draw_block(i,j,style,1);&#xA;&#xA;                while(speed0==0)// wait   1 sec&#xA;                {&#xA;                    if(needclose)return;&#xA;                    Wait(0);&#xA;&#xA;                    if (TimerCounter&gt;18/(speed+1))&#xA;                    {&#xA;                        TimerCounter=0;/* 恢复计时变量 */&#xA;                        break;&#xA;                    }&#xA;&#xA;                    if(bioskey(1))&#xA;                    {&#xA;                        key=bioskey(0);&#xA;                        if(change(&amp;i,&amp;j,key))/*根据按键值做调整*/&#xA;                        {&#xA;                            flag=1;&#xA;                            goto end;&#xA;                        }&#xA;                        PlayWave(&quot;down.WAV&quot;);&#xA;                    }&#xA;                }&#xA;                draw_block(i,j,style,0);&#xA;                renovate();       //            /*刷新屏幕*/&#xA;&#xA;            }&#xA;&#xA;            if(j==y0)&#xA;            {&#xA;                break;&#xA;            }&#xA;            j--;&#xA;&#xA;            draw_block(i,j,style,1);&#xA;            fill_board(i,j,style);&#xA;            sign=1;&#xA;&#xA;            High_line(j);&#xA;            kill_line(j);     /*消去的函数，消去若干行并改变分数和速度*/&#xA;&#xA;            draw_block(MAPXOFT1,MAPYOFT1,style1,0);&#xA;            style=style1;&#xA;            while(bioskey(1))    /*清除内存中的按键*/&#xA;                key=bioskey(0);&#xA;        }&#xA;&#xA;        setcolor(CYAN);&#xA;        &#xA;        TimerCounter=0;&#xA; &#xA;        while(bioskey(1))     /*清除内存中的按键*/&#xA;            key=bioskey(0);&#xA;        setbkcolor(BLACK);&#xA;        settextcolor(RED);&#xA;        outtextxy(360,340,&quot;游戏结束!&quot;);&#xA;        outtextxy(360,360,&quot;按【回车】键重新开始&quot;);&#xA;        outtextxy(360,380,&quot;按【ESC】键退出&quot;);&#xA;        Invalidate(img);&#xA;        printf(&quot;Game Over!!!&quot;);&#xA;        Wait(1);&#xA;        while(bioskey(1)==0)&#xA;        {&#xA;            Wait(1);&#xA;            if(needclose)return;&#xA;        }&#xA;        key=bioskey(0);&#xA;end:&#xA;        if(key==ESC||flag)&#xA;            break;&#xA;    }&#xA;    RECT rect= {0,0,640,480};&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    HBRUSH brush=CreateSolidBrush(0xFF);&#xA;    SelectObject(dc,brush);&#xA;    FillRect(dc,&amp;rect,brush);&#xA;    outtextxy(50,30,&quot; 游戏结束 &quot;);&#xA;    Invalidate(img);&#xA;    &#xA;    &#xA;    printf(&quot;exit form game!&quot;);&#xA;}&#xA;&#xA;void ajustment(void)            /*开始游戏前调整速度和高度*/&#xA;{&#xA;    int key,boo=1,left=1;&#xA;    RECT rect= {0,0,640,480};&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    HBRUSH brush=CreateSolidBrush(0x00);&#xA;    SelectObject(dc,brush);&#xA;    FillRect(dc,&amp;rect,brush);&#xA;    DeleteObject(brush);&#xA;    renovate();&#xA;    setcolor(YELLOW);&#xA;   &#xA;    setbkcolor(BLACK);&#xA;    settextcolor(GREEN);&#xA;    outtextxy(150,30,&quot; 按【回车】键开始游戏... &quot;);&#xA;    outtextxy(150,50,&quot; 按【上下左右】设置难度与速度 &quot;);&#xA;    outtextxy(95,280,&quot;   难度    &quot;);&#xA;    outtextxy(335,280,&quot;  速度    &quot;);&#xA;    outtextxy(6.5*16,15*16,le);&#xA;    outtextxy(21.9*16,15*16,sp);&#xA;&#xA;    Invalidate(img);&#xA;    Wait(1);&#xA;&#xA;    while(1)&#xA;    {&#xA;        if(needclose) return;&#xA;        Wait(1);&#xA;        if(TimerCounter&gt;4)&#xA;        {&#xA;            TimerCounter=0;&#xA;            boo*=-1;&#xA;            if(boo==-1)&#xA;                setcolor(BLACK);&#xA;            else&#xA;                setcolor(YELLOW);&#xA;            if(left==1)&#xA;            {&#xA;                line(6*16,17*16,8.5*16,17*16);&#xA;                setcolor(BLACK);&#xA;                line(21.4*16,17*16,23.9*16,17*16);&#xA;            }&#xA;&#xA;            else&#xA;            {&#xA;                line(21.4*16,17*16,23.9*16,17*16);&#xA;                setcolor(BLACK);&#xA;                line(6*16,17*16,8.5*16,17*16);&#xA;            }&#xA;            Invalidate(img);&#xA;            Wait(1);&#xA;&#xA;        }&#xA;        if(bioskey(1))&#xA;        {&#xA;            key=bioskey(0);&#xA;&#xA;            if(key==ENTER)&#xA;                break;&#xA;            else if(key==UP)&#xA;            {&#xA;                if(left==1)&#xA;                {&#xA;                    level--;&#xA;                    if(level==-1)&#xA;                        level=9;&#xA;                }&#xA;                else&#xA;                {&#xA;                    speed--;&#xA;                    if(speed==-1)&#xA;                        speed=9;&#xA;                }&#xA;            }&#xA;            else if(key==DOWN)&#xA;            {&#xA;                if(left==1)&#xA;                {&#xA;                    level++;&#xA;                    if(level==10)&#xA;                        level=0;&#xA;&#xA;                }&#xA;                else&#xA;                {&#xA;                    speed++;&#xA;                    if(speed==10)&#xA;                        speed=0;&#xA;                }&#xA;            }&#xA;&#xA;            else if(key==LEFT||RIGHT)&#xA;                left*=-1;&#xA;            setcolor(YELLOW);&#xA;            sp[0]=speed+'0';&#xA;            le[0]=level+'0';&#xA;            setbkcolor(BLACK);&#xA;            settextcolor(GREEN);&#xA;            outtextxy(6.5*16,15*16,le);&#xA;            outtextxy(21.9*16,15*16,sp);&#xA;            Invalidate(img);&#xA;            Wait(1);&#xA;        }&#xA;    }&#xA;    setcolor(YELLOW);&#xA;    sp[0]=speed+'0';&#xA;    le[0]=level+'0';&#xA;&#xA;&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    HBRUSH brush=CreateSolidBrush(0x00);&#xA;    SelectObject(dc,brush);&#xA;    FillRect(dc,&amp;rect,brush);&#xA;    DeleteObject(brush);&#xA;    renovate();&#xA;    setbkcolor(BLACK);&#xA;    settextcolor(GREEN);&#xA;    outtextxy(-80+(MAPXOFT+21)*16,(MAPYOFT+6)*16,&quot;0000&quot;);      /*输出新分数*/&#xA;    outtextxy(-80+(MAPXOFT+21)*16-16*2.5,(MAPYOFT+6)*16,&quot;分数:&quot;);      /*输出新分数*/&#xA;    outtextxy(-80+(MAPXOFT+21)*16,(MAPYOFT+6)*16-16,le);      /*输出新分数*/&#xA;    outtextxy(-80+(MAPXOFT+21)*16-16*2.5,(MAPYOFT+6)*16-16,&quot;难度:&quot;);      /*输出新分数*/&#xA;    outtextxy(-80+(MAPXOFT+21)*16,(MAPYOFT+6)*16-32,sp);      /*输出新分数*/&#xA;    outtextxy(-80+(MAPXOFT+21)*16-16*2.5,(MAPYOFT+6)*16-32,&quot;速度:&quot;);      /*输出新分数*/&#xA;&#xA;&#xA;    Invalidate(img);&#xA;    Wait(1);&#xA;}&#xA;&#xA;&#xA;void level_change(void)         /*根据高度随机确定方块是否存在*/&#xA;{&#xA;    int i,j;&#xA;    setcolor(WHITE);&#xA;    for(i=1; i&lt;=10; i++)&#xA;        for(j=1; j&lt;=level; j++)&#xA;            if(rand(2))&#xA;            {&#xA;                board[i-1][20-j]=1;&#xA;&#xA;                draw_little_block(i+MAPXOFT,21-j+MAPYOFT);&#xA;            }&#xA;}&#xA;&#xA;/*此x,y为虚拟坐标，为19中形式中的一种：0~18中的一个&#xA;x,y为10*20的方格的坐标，下标从1开始&#xA;way为1表填充，为0表清除*/&#xA;void draw_block(int x,int y,int style,int way)&#xA;{&#xA;    int x1,y1;&#xA;    int i;&#xA;    x1=x+MAPXOFT,y1=y+MAPYOFT;&#xA;    if(way==1)&#xA;        setcolor(WHITE);&#xA;    else&#xA;        setcolor(BLACK);&#xA;&#xA;    for(i=0; i&lt;=6; i+=2)&#xA;        draw_little_block(x1+shapes[style].xy[i],y1+shapes[style].xy[i+1]);&#xA;    if(sign==1)&#xA;        sign=0;&#xA;    if(way==1)&#xA;        Invalidate(img);&#xA;}&#xA;&#xA;void draw_little_block(int x,int y)/*此处仅在10*20的游戏版内画小方块，若在外，不画之。*/&#xA;{&#xA;    if((x&gt;=10&amp;&amp;x&lt;20&amp;&amp;y&gt;=6&amp;&amp;y&lt;26)||sign)&#xA;    {&#xA;        rectangle(x*16,y*16,x*16+16,y*16+16);&#xA;        circle(x*16+8,y*16+8,6);&#xA;    }&#xA;}&#xA;&#xA;&#xA;int check_block(int x,int y,int style)/*此处检查在(x,y)处放置一方块是否可以，若是，则返回1，否则返回0*/&#xA;{&#xA;    int x1=x+MAPXOFT,y1=y+MAPYOFT;&#xA;    int x2,y2,i;&#xA;    for(i=0; i&lt;=6; i+=2)&#xA;    {&#xA;        x2=x1+shapes[style].xy[i];&#xA;        y2=y1+shapes[style].xy[i+1];&#xA;        if(x2&gt;=10&amp;&amp;x2&lt;20&amp;&amp;y2&lt;26&amp;&amp;(y2&lt;6||board[x2-10][y2-6]==0))&#xA;            continue;&#xA;        else&#xA;            break;&#xA;    }&#xA;&#xA;&#xA;    if(i==8)&#xA;        return 1;&#xA;    else&#xA;        return 0;&#xA;}&#xA;&#xA;void speed_change(void)        /*此为变速函数，当分数超过一级时，即加一。*/&#xA;{&#xA;    if(score&gt;=(sp[0]-'0')*100&amp;&amp;(sp[0]-'0')&lt;9)&#xA;    {&#xA;        sp[0]++;&#xA;        speed++;&#xA;&#xA;        setbkcolor(BLACK);&#xA;        settextcolor(GREEN);&#xA;        outtextxy(21.9*16,15*16,sp);&#xA;    }&#xA;}&#xA;&#xA;void score_change(int count)        /*count为消去的行数，据此来改变score的值*/&#xA;{&#xA;    int score_inc[4]= {1,3,7,13};&#xA;    int i;&#xA;&#xA;    score+=score_inc[count-1];&#xA;    sc[4]+=score_inc[count-1];&#xA;    for(i=4; i&gt;=1; i--)&#xA;    {&#xA;        sc[i-1]+=(sc[i]-'0')/10;&#xA;        sc[i]-=(sc[i]-'0')/10*10;&#xA;    }&#xA;    setcolor(YELLOW);&#xA;    &#xA;    setbkcolor(BLACK);&#xA;    settextcolor(GREEN);&#xA;    outtextxy(-80+(MAPXOFT+21)*16,(MAPYOFT+6)*16,sc);      /*输出新分数*/&#xA;}&#xA;&#xA;void High_line(int y)/*消去的函数，消去若干行并改变分数和速度*/&#xA;{&#xA;    int count=0,i,t=1,j,k;&#xA;    int row;&#xA;&#xA;    for(j=0; j&lt;4; j++)&#xA;    {&#xA;        count=0;&#xA;        for(row=y; row&gt;=1; row--)&#xA;        {&#xA;            for(i=1; i&lt;=10; i++)&#xA;                if(!board[i-1][row-1])&#xA;                    break;&#xA;            if(i==11)&#xA;            {&#xA;                count++;&#xA;                for(k=1; k&lt;=10; k++)&#xA;                {&#xA;                    if(j%2==0)&#xA;                        setcolor(RED);&#xA;                    else&#xA;                        setcolor(0x00ff00);&#xA;                    draw_little_block(k+MAPXOFT,row+MAPYOFT);&#xA;                }&#xA;            }&#xA;        }&#xA;        if(count&gt;0)&#xA;        {&#xA;            if(j==0) score_change(count);&#xA;            Invalidate(img);&#xA;            if(j==0)&#xA;                PlayWave(&quot;addscore.wav&quot;);&#xA;            Wait(100);&#xA;        }&#xA;        else&#xA;            return;&#xA;    }&#xA;}&#xA;&#xA;void kill_line(int y)/*消去的函数，消去若干行并改变分数和速度*/&#xA;{&#xA;    int count=0,i,t=1,j,k;&#xA;    for(; y&gt;=1&amp;&amp;t&lt;=4; y--,t++)&#xA;    {&#xA;        for(i=1; i&lt;=10; i++)&#xA;            if(!board[i-1][y-1])&#xA;                break;&#xA;        if(i==11)&#xA;        {&#xA;            count++;&#xA;            for(k=1; k&lt;=10; k++)&#xA;            {&#xA;                setcolor(BLACK);&#xA;                draw_little_block(k+MAPXOFT,y+MAPYOFT);&#xA;            }&#xA;            for(j=y-1; j&gt;=1; j--)&#xA;                for(k=1; k&lt;=10; k++)&#xA;                {&#xA;                    board[k-1][j]=board[k-1][j-1];&#xA;                    if(board[k-1][j])&#xA;                    {&#xA;                        setcolor(BLACK);&#xA;                        draw_little_block(k+MAPXOFT,j+MAPYOFT);&#xA;                        setcolor(WHITE);&#xA;                        draw_little_block(k+MAPXOFT,j+1+MAPYOFT);&#xA;                    }&#xA;                }&#xA;            renovate();&#xA;            Wait(10);&#xA;            y++;&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;void fill_board(int x,int y, int style) /*当一方块停止时，将中相应的值改为1*/&#xA;{&#xA;&#xA;    int x1,y1,i;&#xA;    for(i=0; i&lt;=6; i+=2)&#xA;    {&#xA;        x1=x+shapes[style].xy[i];&#xA;        y1=y+shapes[style].xy[i+1];&#xA;        board[x1-1][y1-1]=1;&#xA;    }&#xA;}&#xA;&#xA;int change(int *i,int *j,int key)/*控制方块移动、变形的函数*/&#xA;{&#xA;    int key1;&#xA;    if(key==UP&amp;&amp;check_block(*i,*j,shapes[style].next))&#xA;    {&#xA;        draw_block(*i,*j,style,0);&#xA;        style=shapes[style].next;&#xA;        draw_block(*i,*j,style,1);&#xA;    }&#xA;    else if(key==LEFT&amp;&amp;check_block(*i-1,*j,style))&#xA;    {&#xA;        draw_block(*i,*j,style,0);&#xA;        (*i)--;&#xA;        draw_block(*i,*j,style,1);&#xA;    }&#xA;    else if(key==RIGHT&amp;&amp;check_block(*i+1,*j,style))&#xA;    {&#xA;        draw_block(*i,*j,style,0);&#xA;        (*i)++;&#xA;        draw_block(*i,*j,style,1);&#xA;    }&#xA;    else if(key==DOWN&amp;&amp;check_block(*i,*j+1,style))&#xA;    {&#xA;        draw_block(*i,*j,style,0);&#xA;        (*j)++;&#xA;        draw_block(*i,*j,style,1);&#xA;        speed0=9;&#xA;    }&#xA;    else if(key==ENTER)&#xA;    {&#xA;        while(1)&#xA;        {&#xA;            Wait(1);&#xA;            if(bioskey(1))&#xA;                key1=bioskey(0);&#xA;            if(key1==ENTER)&#xA;                break;&#xA;        }&#xA;    }&#xA;    else if(key==ESC)&#xA;        return 1;&#xA;    else if(key==21040)&#xA;    {&#xA;        sign=1;&#xA;        draw_block(MAPXOFT1,MAPYOFT1,style1,0);&#xA;        style1=16;&#xA;        sign=1;&#xA;        draw_block(MAPXOFT1,MAPYOFT1,style1,1);&#xA;    }&#xA;    return 0;&#xA;}&#xA;&#xA;&#xA;void renovate(void)    /*刷新屏幕*/&#xA;{&#xA;    int i,j;&#xA;    setcolor(WHITE);&#xA;    for(i=1; i&lt;=10; i++)&#xA;        for(j=1; j&lt;=20; j++)&#xA;            if(board[i-1][j-1]==1)&#xA;                draw_little_block(i+MAPXOFT,j+MAPYOFT);&#xA;&#xA;    setcolor(BLACK);&#xA;&#xA;    rectangle(10*16-1,6*16-1,20*16+1,26*16+1);&#xA;    setcolor(YELLOW);&#xA;    rectangle(10*16-2,6*16-2,20*16+2,26*16+2);&#xA;    Invalidate(img);&#xA;    Wait(0);&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;"/>
      <Command cmdname="五子棋" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;#include &quot;stdio.h&quot;&#xA;#include &quot;conio.h&quot;&#xA;#define SIZE 24&#xA;#define X0 30&#xA;#define Y0 30&#xA;#define Radius 16&#xA;#define TRUE 1&#xA;#include &quot;stdio.h&quot;&#xA;#include &quot;dos.h&quot;&#xA;#include &quot;conio.h&quot;&#xA;#include &quot;stdlib.h&quot;&#xA;&#xA;#define LEFT  37&#xA;#define RIGHT 39&#xA;#define DOWN  40  /*此键为加速键*/&#xA;#define UP    38  /*此键为变形键*/&#xA;#define ESC   27  /*此键为退出键*/&#xA;#define ENTER 13&#xA;#define DEPTH 21  //递归深度，棋力&#xA;&#xA;int player_x,player_y;&#xA;int kx=7,ky=7;&#xA;int old_x,old_y;&#xA;char back[6]= {27,28,25,26,31,48};&#xA;int pfm;&#xA;void graph_init();&#xA;void drawline();&#xA;char getkey();&#xA;void drawcircle(int ,int ,char);&#xA;void drawcross(int,int);&#xA;void setbit(int,int);&#xA;&#xA;int needclose=0;&#xA;int KeyDown=0;&#xA;HPEN pen=0;&#xA;int img;&#xA;HANDLE dc;&#xA;int ms;&#xA;int mx,my;&#xA;void setcolor(int cl)&#xA;{&#xA;    cl*=0xfffff;&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    if(pen!=0) DeleteObject(pen);&#xA;    pen=CreatePen(PS_SOLID,1,cl);&#xA;    SelectObject(dc,pen);&#xA;}&#xA;int bioskey(int flat)&#xA;{&#xA;    int tmp;&#xA;    if(flat==1)&#xA;    {&#xA;        if(KeyDown!=0)&#xA;            return 1;&#xA;        else&#xA;            return 0;&#xA;    }&#xA;    tmp=KeyDown;&#xA;    KeyDown=0;&#xA;    return tmp;&#xA;&#xA;}&#xA;void putpixel(int x,int y,int cl)&#xA;{&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    SetPixel(dc,x,y,cl*0xfffff);&#xA;}&#xA;void settextstyle(int a,int b,int c)&#xA;{&#xA;&#xA;}&#xA;void outtextxy(int x,int y,char *s)&#xA;{&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    TextOutA(dc,x,y,s,strlen(s));&#xA;}&#xA;&#xA;void line(int x0,int y0,int x1,int y1)&#xA;{&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    MoveToEx(dc,x0,y0,0);&#xA;    LineTo(dc,x1,y1);&#xA;}&#xA;&#xA;void rectangle(int x0,int y0,int x1,int y1)&#xA;{&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    MoveToEx(dc,x0,y0,0);&#xA;    LineTo(dc,x1,y0);&#xA;    LineTo(dc,x1,y1);&#xA;    LineTo(dc,x0,y1);&#xA;    LineTo(dc,x0,y0);&#xA;}&#xA;void circle(int x,int y,int r)&#xA;{&#xA;    rectangle(x-r/2,y-r/2,x+r/2,y+r/2);&#xA;}&#xA;&#xA;&#xA;void setmousecoord(int x,int y)&#xA;{&#xA;    RECT rect;&#xA;    //x+=10;&#xA;    //y+=40;&#xA;    rect.left=x-10;&#xA;    rect.top=y-10;&#xA;    rect.right=x+10;&#xA;    rect.bottom=y+10;&#xA;&#xA;    InvalidateImgRect(img,&amp;rect,1);&#xA;    return;&#xA;&#xA;    InvalidateRect(GetFormHandle(pfm),&amp;rect,0);&#xA;    UpdateWindow(GetFormHandle(pfm));&#xA;&#xA;}&#xA;&#xA;&#xA;void setfillstyle(int m1,int m2)&#xA;{&#xA;&#xA;}&#xA;&#xA;void ellipse(int x0,int y0,int start,int end,int r0,int r1)&#xA;{&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    Ellipse(dc,x0-r0/2,y0-r1/2,x0+r0/2,y0+r1/2);&#xA;}&#xA;&#xA;&#xA;&#xA;void OnKeyDown(int id,int *key,int state)&#xA;{&#xA;    KeyDown=*key;&#xA;}&#xA;&#xA;&#xA;&#xA;typedef struct struct1&#xA;{&#xA;    char p[4];&#xA;    char l[4];&#xA;    char d[4];&#xA;} QCL;&#xA;&#xA;&#xA;QCL pos[15][15][2];&#xA;char all[15][15][2];&#xA;&#xA;char keepgo(int,int,int,char,char,int,QCL);&#xA;char goon(int,int,char,char,int);&#xA;char ifgook(int,int,char,char);&#xA;char computer_keep(int,int,int);&#xA;void exit_game();&#xA;unsigned int step=0;&#xA;unsigned keep[11]=&#xA;{&#xA;    0x0015,  //011100&#xA;    0x0062,  //001110&#xA;    0x0613,  //010110&#xA;    0x0614,  //011010&#xA;    0x0000,  //111111&#xA;    0x0001,  //01111&#xA;    0x0002,  //10111&#xA;    0x0003,  //11011&#xA;    0x0004,  //11101&#xA;    0x0005,  //11110&#xA;    0x0000   //11111&#xA;};&#xA;char judge;&#xA;/*****************************/&#xA;/*     return value          */&#xA;/*   -1    can not move      */&#xA;/*   0     nothing           */&#xA;/*   1     5,6  ready        */&#xA;/*   2     3    ready        */&#xA;/*   3     3,3  ready        */&#xA;/*   4     4    ready        */&#xA;/*   5     3,4  ready        */&#xA;/*   6     4,4  ready        */&#xA;/*****************************/&#xA;char computer_go(int) ;&#xA;char many(int ,int);&#xA;char power(int ,int ,char);&#xA;/*****************************/&#xA;/*     return value          */&#xA;/*   -1    lose the game     */&#xA;/*   0     nothing happen    */&#xA;/*   1     win the game      */&#xA;/*****************************/&#xA;&#xA;&#xA;&#xA;&#xA;void active_init(void);&#xA;void game_init(void);&#xA;&#xA;&#xA;unsigned int left,top,right,down;&#xA;unsigned char player,computer;&#xA;QCL Glist;&#xA;char active[15][15][2];&#xA;char qz[15][15];&#xA;&#xA;&#xA;#define LEN 252&#xA;#define COLOR 15&#xA;#define INTR 0X1C    /* The clock tick interrupt */&#xA;&#xA;&#xA;#define X 98&#xA;#define Y 10&#xA;char num[11][9]=&#xA;{&#xA;    {0x7e,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x7e},//0&#xA;    {0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08},//1&#xA;    {0x7e,0x01,0x01,0x01,0x7e,0x80,0x80,0x80,0x7e},//2&#xA;    {0x7e,0x01,0x01,0x01,0x7e,0x01,0x01,0x01,0x7e},//3&#xA;    {0x81,0x81,0x81,0x81,0x7e,0x01,0x01,0x01,0x01},//4&#xA;    {0x7e,0x80,0x80,0x80,0x7e,0x01,0x01,0x01,0x7e},//5&#xA;    {0x7e,0x80,0x80,0x80,0x7e,0x81,0x81,0x81,0x7e},//6&#xA;    {0x7e,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01},//7&#xA;    {0x7e,0x81,0x81,0x81,0x7e,0x81,0x81,0x81,0x7e},//8&#xA;    {0x7e,0x81,0x81,0x81,0x7e,0x01,0x01,0x01,0x7e},//9&#xA;    {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff},&#xA;};&#xA;&#xA;&#xA;#define COLOR 10&#xA;&#xA;void text(int,int,char,int,char *);&#xA;&#xA;int count0=0,second0=0;/*computer's time*/&#xA;int count1=0,second1=0;/*player's time*/&#xA;int check;&#xA;&#xA;&#xA;&#xA;void set(int che)&#xA;{&#xA;    if(che&gt;2) return;&#xA;    check=che;&#xA;}&#xA;void reset()&#xA;{&#xA;    count0=0;&#xA;    count1=0;&#xA;    second0=0;&#xA;    second1=0;&#xA;    check=0;&#xA;&#xA;}&#xA;&#xA;&#xA;void init();&#xA;void attrib(int x,int y,QCL *pl,char color1,char color2);&#xA;void qz_init();&#xA;void game_init(void)&#xA;{&#xA;    init();&#xA;    active_init();&#xA;    qz_init();&#xA;    left=right=top=down=7;&#xA;}&#xA;void active_init(void)&#xA;{&#xA;    int i,j;&#xA;    for(i=0; i&lt;15; i++)&#xA;        for(j=0; j&lt;15; j++)&#xA;            active[i][j][0]=active[i][j][1]=0;&#xA;}&#xA;void qz_init(void)&#xA;{&#xA;    int i,j;&#xA;    for(i=0; i&lt;15; i++)&#xA;        for(j=0; j&lt;15; j++)&#xA;            qz[i][j]=0;&#xA;}&#xA;&#xA;char computer_go(int len)&#xA;{&#xA;    register int i,j;&#xA;    char result,temp1,temp2,temp3;&#xA;    int max,large;&#xA;    char max_x,max_y;&#xA;    //ShowMessage(&quot;Computer go&quot;);&#xA;    step++;&#xA;    for(i=left; i&lt;=right; i++)&#xA;        for(j=top; j&lt;=down; j++)&#xA;        {&#xA;            all[i][j][computer-1]=ifgook(i,j,computer,player);&#xA;            pos[i][j][computer-1]=Glist;&#xA;            all[i][j][player-1]=ifgook(i,j,player,computer);&#xA;            pos[i][j][player-1]=Glist;&#xA;        }&#xA;&#xA;    for(i=left; i&lt;=right; i++)&#xA;        for(j=top; j&lt;=down; j++)&#xA;            if(all[i][j][computer-1]==1)&#xA;            {&#xA;                drawcircle(i,j,computer);&#xA;                return 1;&#xA;            }&#xA;&#xA;    for(i=left; i&lt;=right; i++)&#xA;        for(j=top; j&lt;=down; j++)&#xA;            if(all[i][j][player-1]==1)&#xA;            {&#xA;                if(all[i][j][computer-1]!=-1)&#xA;                {&#xA;                    drawcircle(i,j,computer);&#xA;                    return 0;&#xA;                }&#xA;                else return -1;&#xA;            }&#xA;&#xA;    large=-1;&#xA;    judge=4;&#xA;    if(len==3)&#xA;    {&#xA;        for(i=left; i&lt;=right; i++)&#xA;            for(j=top; j&lt;=down; j++)&#xA;            {&#xA;                if(active[i][j][computer-1]==1)&#xA;                {&#xA;                    switch(all[i][j][computer-1])&#xA;                    {&#xA;                    case -1:&#xA;                        break;&#xA;                    case 0:&#xA;                        break;&#xA;                    case 6:&#xA;                    case 1:&#xA;                        drawcircle(i,j,computer);&#xA;                        return 1;&#xA;                    case 2:&#xA;                    case 3:&#xA;                        break;&#xA;                    case 5:&#xA;                        qz[i][j]=computer;&#xA;                        temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]);&#xA;                        qz[i][j]=0;&#xA;                        if(temp1==-1)&#xA;                        {&#xA;                            drawcircle(i,j,computer);&#xA;                            return 0;&#xA;                        }&#xA;                        break;&#xA;                    case 4:&#xA;                        temp3=power(i,j,computer);&#xA;                        if(temp3&lt;=large) break;&#xA;                        qz[i][j]=computer;&#xA;                        temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]);&#xA;                        qz[i][j]=0;&#xA;                        if(temp1==-1)&#xA;                        {&#xA;                            large=temp3;&#xA;                            max_x=i;&#xA;                            max_y=j;&#xA;                        }&#xA;                        break;&#xA;                    default:&#xA;                        printf(&quot;error if computer_go().&quot;);&#xA;                    }&#xA;                }&#xA;            }&#xA;        if(large&gt;=0)&#xA;        {&#xA;            drawcircle(max_x,max_y,computer);&#xA;            return 0;&#xA;        }&#xA;        result=computer_keep(player_x,player_y,3);&#xA;        if(result==1) return 0;&#xA;    }&#xA;    else&#xA;    {&#xA;        judge=4;&#xA;        large=-1;&#xA;        for(i=left; i&lt;=right; i++)&#xA;            for(j=top; j&lt;=down; j++)&#xA;            {&#xA;                if(active[i][j][computer-1]==1)&#xA;                {&#xA;                    switch(all[i][j][computer-1])&#xA;                    {&#xA;                    case -1:&#xA;                        break;&#xA;                    case 0:&#xA;                        break;&#xA;                    case 6:&#xA;                    case 1:&#xA;                        drawcircle(i,j,computer);&#xA;                        return 1;&#xA;                    case 2:&#xA;                    case 3:&#xA;                        break;&#xA;                    case 5:&#xA;                        qz[i][j]=computer;&#xA;                        temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]);&#xA;                        qz[i][j]=0;&#xA;                        if(temp1==-1)&#xA;                        {&#xA;                            drawcircle(i,j,computer);&#xA;                            return 0;&#xA;                        }&#xA;                        break;&#xA;                    case 4:&#xA;                        temp3=power(i,j,computer);&#xA;                        if(temp3&lt;=large) break;&#xA;                        qz[i][j]=computer;&#xA;                        temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]);&#xA;                        qz[i][j]=0;&#xA;                        if(temp1==-1)&#xA;                        {&#xA;                            large=temp3;&#xA;                            max_x=i;&#xA;                            max_y=j;&#xA;                        }&#xA;                        break;&#xA;                    default:&#xA;                        printf(&quot;error if computer_go().&quot;);&#xA;                    }&#xA;                }&#xA;            }&#xA;        if(large&gt;=0)&#xA;        {&#xA;            drawcircle(max_x,max_y,computer);&#xA;            return 0;&#xA;        }&#xA;    }&#xA;&#xA;    large=-1;&#xA;    judge=4;&#xA;    for(i=left; i&lt;=right; i++)&#xA;        for(j=top; j&lt;=down; j++)&#xA;        {&#xA;            if(active[i][j][player-1]==1)&#xA;            {&#xA;                temp1=all[i][j][computer-1];&#xA;                switch(all[i][j][player-1])&#xA;                {&#xA;                case -1:&#xA;                    break;&#xA;                case 0:&#xA;                    break;&#xA;                case 6:&#xA;                case 1:&#xA;                    if(temp1!=-1)&#xA;                    {&#xA;                        drawcircle(i,j,computer);&#xA;                        return 0;&#xA;                    }&#xA;                    break;&#xA;                case 2:&#xA;                case 3:&#xA;                    break;&#xA;                case 5:&#xA;                    if(temp1!=-1)&#xA;                    {&#xA;                        qz[i][j]=player;&#xA;                        temp2=keepgo(i,j,4,computer,player,0,pos[i][j][player-1]);&#xA;                        qz[i][j]=0;&#xA;                        if(temp2==-1)&#xA;                        {&#xA;                            drawcircle(i,j,computer);&#xA;                            return 0;&#xA;                        }&#xA;                    }&#xA;                    break;&#xA;                case 4:&#xA;                    if(temp1!=-1)&#xA;                    {&#xA;                        temp3=power(i,j,player);&#xA;                        if(temp3&lt;=large) break;&#xA;                        qz[i][j]=player;&#xA;                        temp2=keepgo(i,j,4,computer,player,0,pos[i][j][player-1]);&#xA;                        qz[i][j]=0;&#xA;                        if(temp2==-1)&#xA;                        {&#xA;                            large=temp3;&#xA;                            max_x=i;&#xA;                            max_y=j;&#xA;                        }&#xA;                    }&#xA;                    break;&#xA;                default:&#xA;                    printf(&quot;error if player_go().&quot;);&#xA;                }&#xA;            }&#xA;        }&#xA;    if(large&gt;=0)&#xA;    {&#xA;        drawcircle(max_x,max_y,computer);&#xA;        return 0;&#xA;    }&#xA;&#xA;&#xA;    judge=3;&#xA;    large=-1;&#xA;    for(i=left; i&lt;=right; i++)&#xA;        for(j=top; j&lt;=down; j++)&#xA;        {&#xA;            if(active[i][j][computer-1]==1)&#xA;            {&#xA;                switch(all[i][j][computer-1])&#xA;                {&#xA;                case -1:&#xA;                    break;&#xA;                case 0:&#xA;                    break;&#xA;                case 6:&#xA;                case 5:&#xA;                    drawcircle(i,j,computer);&#xA;                    return 0;&#xA;                case 1:&#xA;                    drawcircle(i,j,computer);&#xA;                    return 1;&#xA;                case 2:&#xA;                case 3:&#xA;                    temp3=power(i,j,computer);&#xA;                    if(temp3&lt;=large) break;&#xA;                    qz[i][j]=computer;&#xA;                    temp1=keepgo(i,j,3,player,computer,0,pos[i][j][computer-1]);&#xA;                    qz[i][j]=0;&#xA;                    if(temp1==-1)&#xA;                    {&#xA;                        large=temp3;&#xA;                        max_x=i;&#xA;                        max_y=j;&#xA;                    }&#xA;                    break;&#xA;                case 4:&#xA;                    temp3=power(i,j,computer);&#xA;                    if(temp3&lt;=large) break;&#xA;                    qz[i][j]=computer;&#xA;                    temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]);&#xA;                    qz[i][j]=0;&#xA;                    if(temp1==-1)&#xA;                    {&#xA;                        large=temp3;&#xA;                        max_x=i;&#xA;                        max_y=j;&#xA;                    }&#xA;                    break;&#xA;                default:&#xA;                    printf(&quot;error if player_go().&quot;);&#xA;                }&#xA;            }&#xA;        }&#xA;    if(large&gt;=0)&#xA;    {&#xA;        drawcircle(max_x,max_y,computer);&#xA;        return 0;&#xA;    }&#xA;&#xA;&#xA;    large=-1;&#xA;    judge=3;&#xA;    for(i=left; i&lt;=right; i++)&#xA;        for(j=top; j&lt;=down; j++)&#xA;        {&#xA;            if(active[i][j][player-1]==1)&#xA;            {&#xA;                temp1=all[i][j][computer-1];&#xA;                switch(all[i][j][player-1])&#xA;                {&#xA;                case -1:&#xA;                    break;&#xA;                case 0:&#xA;                    break;&#xA;                case 6:&#xA;                case 5:&#xA;                case 1:&#xA;                    if(temp1!=-1)&#xA;                    {&#xA;                        drawcircle(i,j,computer);&#xA;                        return 0;&#xA;                    }&#xA;                    break;&#xA;                case 3:&#xA;                    if(temp1!=-1)&#xA;                    {&#xA;                        qz[i][j]=player;&#xA;                        temp2=keepgo(i,j,3,computer,player,0,pos[i][j][player-1]);&#xA;                        qz[i][j]=0;&#xA;                        if(temp2!=1)&#xA;                        {&#xA;                            drawcircle(i,j,computer);&#xA;                            return 0;&#xA;                        }&#xA;                    }&#xA;                    break;&#xA;                case 2:&#xA;                    if(temp1!=-1)&#xA;                    {&#xA;                        temp3=power(i,j,player);&#xA;                        if(temp3&lt;=large) break;&#xA;                        qz[i][j]=player;&#xA;                        temp2=keepgo(i,j,3,computer,player,0,pos[i][j][player-1]);&#xA;                        qz[i][j]=0;&#xA;                        if(temp2!=1)&#xA;                        {&#xA;                            large=temp3;&#xA;                            max_x=i;&#xA;                            max_y=j;&#xA;                        }&#xA;                    }&#xA;                    break;&#xA;                case 4:&#xA;                    if(temp1!=-1)&#xA;                    {&#xA;                        temp3=power(i,j,player);&#xA;                        if(temp3&lt;=large) break;&#xA;                        qz[i][j]=player;&#xA;                        temp2=keepgo(i,j,4,computer,player,0,pos[i][j][player-1]);&#xA;                        qz[i][j]=0;&#xA;                        if(temp2==-1)&#xA;                        {&#xA;                            large=temp3;&#xA;                            max_x=i;&#xA;                            max_y=j;&#xA;                        }&#xA;                    }&#xA;                    break;&#xA;                default:&#xA;                    printf(&quot;error if player_go().&quot;);&#xA;                }&#xA;            }&#xA;        }&#xA;    if(large&gt;=0)&#xA;    {&#xA;        drawcircle(max_x,max_y,computer);&#xA;        return 0;&#xA;    }&#xA;&#xA;    max=-1;&#xA;    max_x=6;&#xA;    max_y=7;&#xA;    if(computer==2&amp;&amp;step&lt;=5)&#xA;    {&#xA;        for(i=left; i&lt;=right; i++)&#xA;            for(j=top; j&lt;=down; j++)&#xA;            {&#xA;                if(all[i][j][0]&gt;0&amp;&amp;all[i][j][1]&gt;0)&#xA;                {&#xA;                    temp1=power(i,j,1);&#xA;                    if(temp1&gt;max)&#xA;                    {&#xA;                        max=temp1;&#xA;                        max_x=i;&#xA;                        max_y=j;&#xA;                    }&#xA;                    else if(temp1==max&amp;&amp;power(max_x,max_y,computer)&lt;power(i,j,computer))&#xA;                    {&#xA;                        max_x=i;&#xA;                        max_y=j;&#xA;                    }&#xA;                }&#xA;            }&#xA;        if(max&gt;=0)&#xA;        {&#xA;            drawcircle(max_x,max_y,computer);&#xA;            return 0;&#xA;        }&#xA;&#xA;        for(i=left; i&lt;=right; i++)&#xA;            for(j=top; j&lt;=down; j++)&#xA;            {&#xA;                if(all[i][j][computer-1]!=-1)&#xA;                {&#xA;                    temp1=power(i,j,1);&#xA;                    if(temp1&gt;max)&#xA;                    {&#xA;                        max=temp1;&#xA;                        max_x=i;&#xA;                        max_y=j;&#xA;                    }&#xA;                }&#xA;            }&#xA;        if(max&gt;=0)&#xA;        {&#xA;            drawcircle(max_x,max_y,computer);&#xA;            return 0;&#xA;        }&#xA;    }&#xA;&#xA;    if(computer==1&amp;&amp;step&lt;=5)&#xA;    {&#xA;        for(i=left; i&lt;=right; i++)&#xA;            for(j=top; j&lt;=down; j++)&#xA;            {&#xA;                if(all[i][j][computer-1]!=-1&amp;&amp;active[i][j][computer-1]==1&amp;&amp;all[i][j][player-1]&gt;0)&#xA;                {&#xA;                    temp1=power(i,j,computer);&#xA;                    if(temp1&gt;max)&#xA;                    {&#xA;                        max=temp1;&#xA;                        max_x=i;&#xA;                        max_y=j;&#xA;                    }&#xA;                    else if(temp1==max&amp;&amp;power(max_x,max_y,player)&lt;power(i,j,player))&#xA;                    {&#xA;                        max_x=i;&#xA;                        max_y=j;&#xA;                    }&#xA;                }&#xA;            }&#xA;        if(max&gt;=0)&#xA;        {&#xA;            drawcircle(max_x,max_y,computer);&#xA;            return 0;&#xA;        }&#xA;    }&#xA;&#xA;    for(i=left; i&lt;=right; i++)&#xA;        for(j=top; j&lt;=down; j++)&#xA;        {&#xA;            if(qz[i][j]==0&amp;&amp;all[i][j][computer-1]!=-1)&#xA;            {&#xA;                temp1=many(i,j);&#xA;                if(temp1&gt;max)&#xA;                {&#xA;                    max=temp1;&#xA;                    max_x=i;&#xA;                    max_y=j;&#xA;                }&#xA;            }&#xA;        }&#xA;    drawcircle(max_x,max_y,computer);&#xA;    return 0;&#xA;}&#xA;&#xA;char player_go()&#xA;{&#xA;    char result;&#xA;&#xA;    result=getkey();&#xA;&#xA;    if(needclose)&#xA;    {&#xA;        printf(&quot;exit player go&quot;);&#xA;        return 0;&#xA;    }&#xA;&#xA;    switch(result)&#xA;    {&#xA;    case 0:&#xA;        return 0;&#xA;    case -1:&#xA;        return -1;&#xA;    case 1:&#xA;        return 1;&#xA;    case 3:&#xA;    case 2:&#xA;        return 3;&#xA;    case 4:&#xA;    case 5:&#xA;    case 6:&#xA;        return 4;&#xA;    default:&#xA;        return result;&#xA;    }&#xA;}&#xA;&#xA;char ifgook(int x,int y,char color1,char color2)&#xA;{&#xA;    register int i;&#xA;    int k3=0,k4=0;&#xA;    if(qz[x][y]!=0) return -1;&#xA;    qz[x][y]=color1;&#xA;    attrib(x,y,&amp;Glist,color1,color2);&#xA;    qz[x][y]=0;&#xA;    for(i=0; i&lt;4; i++)&#xA;    {&#xA;        if(Glist.p[i]&gt;=0&amp;&amp;Glist.p[i]&lt;=3)&#xA;            k3++;&#xA;        else if(Glist.p[i]==10)&#xA;            return 1;   /* there is five .*/&#xA;&#xA;        else if(Glist.p[i]&lt;10&amp;&amp;Glist.p[i]&gt;=5)&#xA;            k4++;&#xA;&#xA;        if(Glist.p[i]==4&amp;&amp;color1==1) return -1;&#xA;        if(Glist.p[i]==4&amp;&amp;color1==2) return 1;&#xA;    }&#xA;    if(k4&gt;1)&#xA;    {&#xA;        if(color1==1) return -1;&#xA;        else   return 6;&#xA;    }&#xA;    if(k3&gt;1&amp;&amp;color1==1) return -1;&#xA;    if(k3==1&amp;&amp;k4==1) return 5;  /* case  a 3 and a 4 */&#xA;    if(k3&gt;1) return 3;&#xA;    if(k4==1) return 4 ;        /* case a 4          */&#xA;    if(k3==1) return 2 ;        /* case a 3          */&#xA;    return 0;&#xA;}&#xA;&#xA;char keepgo(int x,int y,int  len,char color1,char color2,int depth,QCL list)&#xA;{&#xA;    int dx,dy,x0,y0;&#xA;    int i,bx,by,mask,d,r0,r1,r2;&#xA;    char old_judge;&#xA;    if(depth&gt;=DEPTH) return -1;&#xA;    else   depth++;&#xA;    for(i=0; i&lt;4; i++)&#xA;    {&#xA;        switch(i)&#xA;        {&#xA;        case 0:&#xA;            dx=0;&#xA;            dy=1;&#xA;            break;&#xA;        case 1:&#xA;            dx=1;&#xA;            dy=1;&#xA;            break;&#xA;        case 2:&#xA;            dx=1;&#xA;            dy=0;&#xA;            break;&#xA;        case 3:&#xA;            dx=1;&#xA;            dy=-1;&#xA;            break;&#xA;        }&#xA;        if(list.l[i]==len)&#xA;        {&#xA;            int j;&#xA;            j=list.p[i];&#xA;            bx=x-dx*list.d[i];&#xA;            by=y-dy*list.d[i];&#xA;            mask=keep[j];&#xA;            while(mask!=0)&#xA;            {&#xA;&#xA;                d=(mask&amp;0x000f)-1;&#xA;                x0=bx+d*dx;&#xA;                y0=by+d*dy;&#xA;                r1=ifgook(x0,y0,color1,color2);&#xA;&#xA;                switch(r1)&#xA;                {&#xA;                case -1:&#xA;                    break;&#xA;                case 0:&#xA;                    if(judge==4||judge==5)&#xA;                    {&#xA;                        qz[x0][y0]=color1;&#xA;                        r2=goon(x,y,color2,color1,depth);&#xA;                        qz[x0][y0]=0;&#xA;                        if(r2==1) break;&#xA;                        else return 1;&#xA;                    }&#xA;                    if(judge==3)&#xA;                    {&#xA;                        judge=4;&#xA;                        qz[x0][y0]=color1;&#xA;                        r2=goon(x0,y0,color1,color2,depth);&#xA;                        judge=3;&#xA;                        if(r2==1) judge=4;&#xA;                        r2=goon(x,y,color2,color1,depth);&#xA;                        qz[x0][y0]=0;&#xA;                        judge=3;&#xA;                        if(r2==1) break;&#xA;                        else return 1;&#xA;                    }&#xA;                case 2:&#xA;                case 3:&#xA;                    old_judge=judge;&#xA;                    if(judge==3) judge=4;&#xA;                    qz[x0][y0]=color1;&#xA;                    r2=goon(x,y,color2,color1,depth);&#xA;                    qz[x0][y0]=0;&#xA;                    judge=old_judge;&#xA;                    if(r2==1) break;&#xA;                    else return 1;&#xA;                case 1:&#xA;                    return 1;&#xA;                case 4:&#xA;                case 5:&#xA;                case 6:&#xA;                    old_judge=judge;&#xA;                    if(judge==3||judge==4) judge=5;&#xA;                    qz[x0][y0]=color1;&#xA;                    r2=goon(x,y,color2,color1,depth);&#xA;                    qz[x0][y0]=0;&#xA;                    judge=old_judge;&#xA;                    if(r2==1) break;&#xA;                    else return 1;&#xA;                default:&#xA;                    printf(&quot;error in keepgo()&quot;);&#xA;                    break;&#xA;                }&#xA;                mask=mask&gt;&gt;4;&#xA;            }&#xA;        }&#xA;    }&#xA;    return -1;&#xA;}&#xA;char goon(int x,int y,char color1,char color2,int depth)&#xA;{&#xA;    int i,dx,dy,k1,k2,rang1,rang2,temp;&#xA;    int nx,ny;&#xA;    char r1,r2;&#xA;    for(i=0; i&lt;4; i++)&#xA;    {&#xA;        k1=1;&#xA;        k2=1;&#xA;        switch(i)&#xA;        {&#xA;        case 0:&#xA;            dx=0;&#xA;            dy=1;&#xA;            rang1=(y&gt;4)?4:y;&#xA;            rang2=(14-y&gt;4)?4:14-y;&#xA;            break;&#xA;        case 1:&#xA;            dx=1;&#xA;            dy=1;&#xA;            rang1=(x&lt;y)?x:y;&#xA;            rang1=(rang1&gt;4)?4:rang1;&#xA;            rang2=(x&gt;y)?x:y;&#xA;            rang2=(14-rang2&gt;4)?4:14-rang2;&#xA;            break;&#xA;        case 2:&#xA;            dx=1;&#xA;            dy=0;&#xA;            rang1=(x&gt;4)?4:x;&#xA;            rang2=(14-x&gt;4)?4:14-x;&#xA;            break;&#xA;        case 3:&#xA;            dx=1;&#xA;            dy=-1;&#xA;            rang1=(x&lt;14-y)?x:14-y;&#xA;            rang1=(rang1&gt;4)?4:rang1;&#xA;            rang2=(14-x&lt;y)?14-x:y;&#xA;            rang2=(rang2&gt;4)?4:rang2;&#xA;            break;&#xA;        }&#xA;        while(k1&lt;=rang1)&#xA;        {&#xA;            nx=x-k1*dx;&#xA;            ny=y-k1*dy;&#xA;            temp=qz[nx][ny];&#xA;            k1++;&#xA;            if(temp==0)&#xA;            {&#xA;                r1=ifgook(nx,ny,color1,color2);&#xA;                switch(r1)&#xA;                {&#xA;                case -1:&#xA;                case 0:&#xA;                    break;&#xA;                case 1:&#xA;                    return 1;&#xA;                case 2:&#xA;                case 3:&#xA;                    if(judge!=3) break;&#xA;                    qz[nx][ny]=color1;&#xA;                    r2=keepgo(nx,ny,3,color2,color1,depth,Glist);&#xA;                    qz[nx][ny]=0;&#xA;                    if(r2==-1) return 1;&#xA;                    break;&#xA;                case 6:&#xA;                case 5:&#xA;                case 4:&#xA;                    if(judge==5) break;&#xA;                    qz[nx][ny]=color1;&#xA;                    r2=keepgo(nx,ny,4,color2,color1,depth,Glist);&#xA;                    qz[nx][ny]=0;&#xA;                    if(r2==-1) return 1;&#xA;                    break;&#xA;                }&#xA;            }&#xA;            if(temp==color2) break;&#xA;        }&#xA;&#xA;        while(k2&lt;=rang2)&#xA;        {&#xA;            nx=x+k2*dx;&#xA;            ny=y+k2*dy;&#xA;            temp=qz[nx][ny];&#xA;            k2++;&#xA;            if(temp==0)&#xA;            {&#xA;                r1=ifgook(nx,ny,color1,color2);&#xA;                switch(r1)&#xA;                {&#xA;                case -1:&#xA;                case 0:&#xA;                    break;&#xA;                case 1:&#xA;                    return 1;&#xA;                case 2:&#xA;                case 3:&#xA;                    if(judge!=3) break;&#xA;                    qz[nx][ny]=color1;&#xA;                    r2=keepgo(nx,ny,3,color2,color1,depth,Glist);&#xA;                    qz[nx][ny]=0;&#xA;                    if(r2==-1) return 1;&#xA;                    break;&#xA;                case 5:&#xA;                case 6:&#xA;                case 4:&#xA;                    if(judge==5) break;&#xA;                    qz[nx][ny]=color1;&#xA;                    r2=keepgo(nx,ny,4,color2,color1,depth,Glist);&#xA;                    qz[nx][ny]=0;&#xA;                    if(r2==-1) return 1;&#xA;                    break;&#xA;                }&#xA;            }&#xA;            if(temp==color2) break;&#xA;        }&#xA;    }&#xA;    return -1;&#xA;}&#xA;char computer_keep(int x,int y,int len)&#xA;{&#xA;    int dx,dy,x0,y0;&#xA;    int i,j,bx,by,mask,d,r1,r2;&#xA;    int temp;&#xA;    char old_judge;&#xA;    int max=-1,max_x,max_y;&#xA;    QCL list;&#xA;    attrib(x,y,&amp;list,player,computer);&#xA;    judge=3;&#xA;    for(i=0; i&lt;4; i++)&#xA;    {&#xA;        switch(i)&#xA;        {&#xA;        case 0:&#xA;            dx=0;&#xA;            dy=1;&#xA;            break;&#xA;        case 1:&#xA;            dx=1;&#xA;            dy=1;&#xA;            break;&#xA;        case 2:&#xA;            dx=1;&#xA;            dy=0;&#xA;            break;&#xA;        case 3:&#xA;            dx=1;&#xA;            dy=-1;&#xA;            break;&#xA;        }&#xA;        if(list.l[i]==len)&#xA;        {&#xA;            j=list.p[i];&#xA;            bx=x-dx*list.d[i];&#xA;            by=y-dy*list.d[i];&#xA;            mask=keep[j];&#xA;            while(mask!=0)&#xA;            {&#xA;                d=(mask&amp;0x000f)-1;&#xA;                x0=bx+d*dx;&#xA;                y0=by+d*dy;&#xA;                r1=ifgook(x0,y0,computer,player);&#xA;                switch(r1)&#xA;                {&#xA;                case -1:&#xA;                    break;&#xA;                case 0:&#xA;                    old_judge=judge;&#xA;                    judge=4;&#xA;                    qz[x0][y0]=computer;&#xA;                    r2=goon(x0,y0,computer,player,0);&#xA;                    if(r2==-1) judge=3;&#xA;                    r2=goon(x,y,player,computer,0);&#xA;                    qz[x0][y0]=0;&#xA;                    judge=old_judge;&#xA;                    if(r2==1) break;&#xA;                    r2=power(x0,y0,1);&#xA;                    if(max&lt;r2)&#xA;                    {&#xA;                        max=r2;&#xA;                        max_x=x0;&#xA;                        max_y=y0;&#xA;                    }&#xA;                    break;&#xA;                case 1:&#xA;                    drawcircle(x0,y0,computer);&#xA;                    return 1;&#xA;                case 2:&#xA;                case 3:&#xA;                    old_judge=judge;&#xA;                    judge=4;&#xA;                    qz[x0][y0]=computer;&#xA;                    r2=goon(x,y,player,computer,0);&#xA;                    qz[x0][y0]=0;&#xA;                    judge=old_judge;&#xA;                    if(r2==1) break;&#xA;                    drawcircle(x0,y0,computer);&#xA;                    return 1;&#xA;                case 4:&#xA;                case 5:&#xA;                case 6:&#xA;                    drawcircle(x0,y0,computer);&#xA;                    return 1;&#xA;                default:&#xA;                    printf(&quot;error in keepgo()&quot;);&#xA;                    break;&#xA;                }&#xA;                mask=mask&gt;&gt;4;&#xA;            }//end while&#xA;            if(max&gt;=0)&#xA;            {&#xA;                drawcircle(max_x,max_y,computer);&#xA;                return 1;&#xA;            }&#xA;            mask=keep[j];&#xA;            while(mask!=0)&#xA;            {&#xA;                d=(mask&amp;0x000f)-1;&#xA;                x0=bx+d*dx;&#xA;                y0=by+d*dy;&#xA;                r1=ifgook(x0,y0,computer,player);&#xA;                temp=power(x0,y0,player);&#xA;                if(temp&gt;max&amp;&amp;r1!=-1)&#xA;                {&#xA;                    max=temp;&#xA;                    max_x=x0;&#xA;                    max_y=y0;&#xA;                }&#xA;                mask=mask&gt;&gt;4;&#xA;            }&#xA;            if(max&gt;=0)&#xA;            {&#xA;                drawcircle(max_x,max_y,computer);&#xA;                return 1;&#xA;            }&#xA;        } //end if&#xA;    }  //end for&#xA;    return 0;&#xA;}&#xA;char many(int x,int y)&#xA;{&#xA;    int l,t,r,d;&#xA;    int num=0,id=0;&#xA;    l=(x-2&gt;0)?x-2:0;&#xA;    t=(y-2&gt;0)?y-2:0;&#xA;    r=(x+2&gt;14)?14:x+2;&#xA;    d=(y+2&gt;14)?14:y+2;&#xA;&#xA;    if(x-1&gt;=l&amp;&amp;y-1&gt;=t)&#xA;    {&#xA;        if(qz[x-1][y-1]==0)&#xA;        {&#xA;            num++;&#xA;            if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==0)  ;&#xA;            else if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==computer)  num++;&#xA;            else  num--;&#xA;        }&#xA;        else if(qz[x-1][y-1]==computer)&#xA;        {&#xA;            id=1;&#xA;            num+=2;&#xA;            if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==0)  num++;&#xA;            else if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==computer)  num+=2;&#xA;            else  num--;&#xA;        }&#xA;        else num-=2;&#xA;    }&#xA;    else num-=2;&#xA;&#xA;    if(y-1&gt;=t)&#xA;    {&#xA;        if(qz[x][y-1]==0)&#xA;        {&#xA;            num++;&#xA;            if(y-2&gt;=t&amp;&amp;qz[x][y-2]==0)  ;&#xA;            else if(y-2&gt;=t&amp;&amp;qz[x][y-2]==computer)  num++;&#xA;            else  num--;&#xA;        }&#xA;        else  if(qz[x][y-1]==computer)&#xA;        {&#xA;            id=1;&#xA;            num+=2;&#xA;            if(y-2&gt;=t&amp;&amp;qz[x][y-2]==0)  num++;&#xA;            else if(y-2&gt;=t&amp;&amp;qz[x][y-2]==computer)  num+=2;&#xA;            else  num--;&#xA;        }&#xA;        else num-=2;&#xA;    }&#xA;    else num-=2;&#xA;&#xA;    if(x+1&lt;=r&amp;&amp;y-1&gt;=t)&#xA;    {&#xA;        if(qz[x+1][y-1]==0)&#xA;        {&#xA;            num++;&#xA;            if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==0)  ;&#xA;            else if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==computer)  num++;&#xA;            else  num--;&#xA;        }&#xA;        else if(qz[x+1][y-1]==computer)&#xA;        {&#xA;            id=1;&#xA;            num+=2;&#xA;            if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==0)  num++;&#xA;            else  if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==computer)  num+=2;&#xA;            else  num--;&#xA;&#xA;        }&#xA;        else num-=2;&#xA;    }&#xA;    else num-=2;&#xA;&#xA;    if(x-1&gt;=l)&#xA;    {&#xA;        if(qz[x-1][y]==0)&#xA;        {&#xA;            num++;&#xA;            if(x-2&gt;=l&amp;&amp;qz[x-2][y]==0)  ;&#xA;            else if(x-2&gt;=l&amp;&amp;qz[x-2][y]==computer)  num++;&#xA;            else  num--;&#xA;        }&#xA;        else  if(qz[x-1][y]==computer)&#xA;        {&#xA;            id=1;&#xA;            num+=2;&#xA;            if(x-2&gt;=l&amp;&amp;qz[x-2][y]==0)  num++;&#xA;            else if(x-2&gt;=l&amp;&amp;qz[x-2][y]==computer)  num+=2;&#xA;            else  num--;&#xA;        }&#xA;        else num-=2;&#xA;    }&#xA;    else num-=2;&#xA;&#xA;    if(x-1&gt;=l&amp;&amp;y+1&lt;=d)&#xA;    {&#xA;        if(qz[x-1][y+1]==0)&#xA;        {&#xA;            num++;&#xA;            if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==0)  ;&#xA;            else if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==computer)  num++;&#xA;            else  num--;&#xA;        }&#xA;        else  if(qz[x-1][y+1]==computer)&#xA;        {&#xA;            id=1;&#xA;            num+=2;&#xA;            if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==0)  num++;&#xA;            else if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==computer)  num+=2;&#xA;            else  num--;&#xA;        }&#xA;        else num-=2;&#xA;    }&#xA;    else num-=2;&#xA;&#xA;    if(y+1&lt;=d)&#xA;    {&#xA;        if(qz[x][y+1]==0)&#xA;        {&#xA;            num++;&#xA;            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  ;&#xA;            else if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  num++;&#xA;            else  num--;&#xA;        }&#xA;        else  if(qz[x][y+1]==computer)&#xA;        {&#xA;            id=1;&#xA;            num+=2;&#xA;            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  num++;&#xA;            else if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  num+=2;&#xA;            else  num--;&#xA;&#xA;        }&#xA;        else num-=2;&#xA;    }&#xA;    else num-=2;&#xA;&#xA;    if(x+1&lt;=r&amp;&amp;y+1&lt;=d)&#xA;    {&#xA;        if(qz[x+1][y+1]==0)&#xA;        {&#xA;            num++;&#xA;            if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==0)  ;&#xA;            else if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==computer)  num++;&#xA;            else  num--;&#xA;        }&#xA;        else  if(qz[x+1][y+1]==computer)&#xA;        {&#xA;            id=1;&#xA;            num+=2;&#xA;            if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==0)  num++;&#xA;            else if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==computer)  num+=2;&#xA;            else  num--;&#xA;        }&#xA;        else num-=2;&#xA;    }&#xA;    else num-=2;&#xA;&#xA;    if(x+1&lt;=r)&#xA;    {&#xA;        if(qz[x+1][y]==0)&#xA;        {&#xA;            num++;&#xA;            if(x+2&lt;=r&amp;&amp;qz[x+2][y]==0)  ;&#xA;            else if(x+2&lt;=r&amp;&amp;qz[x+2][y]==computer)  num++;&#xA;            else  num--;&#xA;        }&#xA;        else   if(qz[x+1][y]==computer)&#xA;        {&#xA;            id=1;&#xA;            num+=2;&#xA;            if(x+2&lt;=r&amp;&amp;qz[x+2][y]==0)  num++;&#xA;            else if(x+2&lt;=r&amp;&amp;qz[x+2][y]==computer)  num+=2;&#xA;            else  num--;&#xA;        }&#xA;        else num-=2;&#xA;    }&#xA;    else num-=2;&#xA;&#xA;    if (id==1) return num;&#xA;    else return -1;&#xA;}&#xA;char power(int x,int y,char color)&#xA;{&#xA;    int l,t,r,d,num;&#xA;    l=(x-2&gt;0)?x-2:0;&#xA;    t=(y-2&gt;0)?y-2:0;&#xA;    r=(x+2&gt;14)?14:x+2;&#xA;    d=(y+2&gt;14)?14:y+2;&#xA;&#xA;    num=0;&#xA;    if(x-1&gt;=l&amp;&amp;y-1&gt;=t)&#xA;        if(qz[x-1][y-1]==color)&#xA;        {&#xA;            num+=2;&#xA;            if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==color)  num+=2;&#xA;            else if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==0)  num++;&#xA;            else  num--;&#xA;        }&#xA;        else if(qz[x-1][y-1]==0)&#xA;        {&#xA;            num++;&#xA;            if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==color)  num++;&#xA;            else if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==0)  ;&#xA;            else num--;&#xA;        }&#xA;    //else num--;&#xA;&#xA;    if(y-1&gt;=t)&#xA;        if(qz[x][y-1]==color)&#xA;        {&#xA;            num+=2;&#xA;            if(y-2&gt;=t&amp;&amp;qz[x][y-2]==color)  num+=2;&#xA;            else if(y-2&gt;=t&amp;&amp;qz[x][y-2]==0)  num++;&#xA;            else num--;&#xA;        }&#xA;        else if(qz[x][y-1]==0)&#xA;        {&#xA;            num++;&#xA;            if(y-2&gt;=t&amp;&amp;qz[x][y-2]==color)  num++;&#xA;            else if(y-2&gt;=t&amp;&amp;qz[x][y-2]==0) ;&#xA;            else num--;&#xA;        }&#xA;    //else num--;&#xA;&#xA;    if(x+1&lt;=r&amp;&amp;y-1&gt;=t)&#xA;        if(qz[x+1][y-1]==color)&#xA;        {&#xA;            num+=2;&#xA;            if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==color)  num+=2;&#xA;            else if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==0)  num++;&#xA;            else num--;&#xA;        }&#xA;        else if(qz[x+1][y-1]==0)&#xA;        {&#xA;            num++;&#xA;            if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==color)  num++;&#xA;            else if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==0)  ;&#xA;            else num--;&#xA;        }&#xA;    //else num--;&#xA;&#xA;    if(x-1&gt;=l)&#xA;        if(qz[x-1][y]==color)&#xA;        {&#xA;            num+=2;&#xA;            if(x-2&gt;=l&amp;&amp;qz[x-2][y]==color)  num+=2;&#xA;            else if(x-2&gt;=l&amp;&amp;qz[x-2][y]==0)  num++;&#xA;            else num--;&#xA;        }&#xA;        else if(qz[x-1][y]==0)&#xA;        {&#xA;            num++;&#xA;            if(x-2&gt;=l&amp;&amp;qz[x-2][y]==color)  num++;&#xA;            else if(x-2&gt;=l&amp;&amp;qz[x-2][y]==0) ;&#xA;            else  num--;&#xA;        }&#xA;    //else num--;&#xA;&#xA;    if(x-1&gt;=l&amp;&amp;y+1&lt;=d)&#xA;        if(qz[x-1][y+1]==color)&#xA;        {&#xA;            num+=2;&#xA;            if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==color)  num+=2;&#xA;            else if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==0)  num++;&#xA;            else num--;&#xA;        }&#xA;        else if(qz[x-1][y+1]==0)&#xA;        {&#xA;            num++;&#xA;            if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==color)  num++;&#xA;            else if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==0)  ;&#xA;            else num--;&#xA;        }&#xA;    //else num--;&#xA;&#xA;    if(y+1&lt;=d)&#xA;        if(qz[x][y+1]==color)&#xA;        {&#xA;            num+=2;&#xA;            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==color)  num+=2;&#xA;            else if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  num++;&#xA;            else num--;&#xA;        }&#xA;        else if(qz[x][y+1]==0)&#xA;        {&#xA;            num++;&#xA;            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==color)  num++;&#xA;            else if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  ;&#xA;            else num--;&#xA;        }&#xA;    //else num--;&#xA;&#xA;    if(x+1&lt;=r&amp;&amp;y+1&lt;=d)&#xA;        if(qz[x+1][y+1]==color)&#xA;        {&#xA;            num+=2;&#xA;            if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==color)  num+=2;&#xA;            else if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==0)  num++;&#xA;            else num--;&#xA;        }&#xA;        else  if(qz[x+1][y+1]==0)&#xA;        {&#xA;            num++;&#xA;            if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==color)  num++;&#xA;            else if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==0)  ;&#xA;            else num--;&#xA;        }&#xA;    //else num--;&#xA;&#xA;    if(x+1&lt;=r)&#xA;        if(qz[x+1][y]==color)&#xA;        {&#xA;            num+=2;&#xA;            if(x+2&lt;=r&amp;&amp;qz[x+2][y]==color)  num+=2;&#xA;            else if(x+2&lt;=r&amp;&amp;qz[x+2][y]==0)  num++;&#xA;            else num--;&#xA;        }&#xA;        else if(qz[x+1][y]==0)&#xA;        {&#xA;            num++;&#xA;            if(x+2&lt;=r&amp;&amp;qz[x+2][y]==color)  num++;&#xA;            else if(x+2&lt;=r&amp;&amp;qz[x+2][y]==0)  ;&#xA;            else num--;&#xA;        }&#xA;    //else num--;&#xA;    return num;&#xA;}&#xA;&#xA;///////////////////////five.c////////////////////////////////////////&#xA;char lose[4]= {27,12,35,47};&#xA;char lose2[6]= {41,42,27,12,35,47};&#xA;char win[4]= {27,34,35,47};&#xA;char str1[6]= {27,28,32,33,31,48};&#xA;char gamego[8]= {27,28,37,43,44,45,31,48};&#xA;extern unsigned int step;&#xA;void p(void)&#xA;{&#xA;    int i,j;&#xA;    for(i=0; i&lt;15; i++)&#xA;    {&#xA;&#xA;        for(j=0; j&lt;15; j++)&#xA;            printf(&quot;%d&quot;,qz[j][i]);&#xA;    }&#xA;}&#xA;&#xA;&#xA;void init(void)&#xA;{&#xA;    drawline();&#xA;    old_x=7;&#xA;    old_y=7;&#xA;    setbit(7,7);&#xA;}&#xA;void drawline()&#xA;{&#xA;    int j;&#xA;    char str[2];&#xA;    char string[3];&#xA;&#xA;    setfillstyle(1,14);&#xA;&#xA;    setcolor(9);&#xA;    str[1]='\0';&#xA;    string[2]='\0';&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    SetTextColor(dc,0xff00);&#xA;    SetBkColor(dc,0);&#xA;    for(j=0; j&lt;15; j++)&#xA;    {&#xA;        line(X0+SIZE*(j),Y0,X0+SIZE*(j),Y0+SIZE*14);&#xA;        line(X0,Y0+SIZE*(j),X0+SIZE*14,Y0+SIZE*(j));&#xA;        if(j&gt;=9)&#xA;        {&#xA;            string[0]='1';&#xA;            string[1]='0'+j-9;&#xA;        }&#xA;        else&#xA;        {&#xA;            string[0]='1'+j;&#xA;            string[1]='\0';&#xA;        }&#xA;&#xA;        outtextxy(X0-16,Y0+SIZE*j-7,string);&#xA;        str[0]='A'+j;&#xA;        outtextxy(X0+SIZE*j-3,Y0-15,str);&#xA;    }&#xA;}&#xA;char getkey()&#xA;{&#xA;    int key,ok=0;&#xA;    int  f,oldx,oldy;&#xA;    int can1,can2;&#xA;    while(1)&#xA;    {&#xA;        if(needclose)&#xA;        {&#xA;            printf(&quot;exit getkey&quot;);&#xA;            return 0;&#xA;        }&#xA;        Wait(1);&#xA;        if(bioskey(1)==1)&#xA;        {&#xA;            key=bioskey(0);&#xA;            if(key!=ENTER)&#xA;            {&#xA;                switch(key)&#xA;                {&#xA;                case LEFT:&#xA;&#xA;                    printf(&quot;left0 kx:%d,ky:%d&quot;,kx,ky);&#xA;                    kx=(kx==0)?0:--kx;&#xA;                    printf(&quot;left1 kx:%d,ky:%d&quot;,kx,ky);&#xA;                    setbit(kx,ky);&#xA;                    break; /*left*/&#xA;                case RIGHT:&#xA;                    kx=(kx==14)?14:++kx;&#xA;                    setbit(kx,ky);&#xA;                    break; /*right*/&#xA;                case UP:&#xA;                    ky=(ky==0)?0:--ky;&#xA;                    setbit(kx,ky);&#xA;                    break; /*up*/&#xA;                case DOWN:&#xA;                    ky=(ky==14)?14:++ky;&#xA;                    setbit(kx,ky);;&#xA;                    break; /*down*/&#xA;                case ESC:&#xA;                    return 0x10;&#xA;                    break;&#xA;                case 'r':&#xA;                case 'R':&#xA;                    return 0x11;&#xA;                default:&#xA;                    break;&#xA;                }&#xA;            }&#xA;            else  ok=1;&#xA;        }&#xA;        if(oldx!=kx||oldy!=ky)&#xA;        {&#xA;            oldx=kx;&#xA;            oldy=ky;&#xA;        }&#xA;        /**/&#xA;&#xA;        if((mx&gt;X0-SIZE/2)&amp;&amp;(my&gt;Y0-SIZE/2))&#xA;            if((mx&lt;X0+SIZE*14.5)&amp;&amp;(my&lt;Y0+SIZE*14.5))&#xA;            {&#xA;                printf(&quot;check mouse down,x:%d,y:%d&quot;,mx,my);&#xA;                //readmouse(&amp;f,&amp;mx,&amp;my);&#xA;                can1=(mx-X0)%SIZE;&#xA;                can2=(my-Y0)%SIZE;&#xA;                if(can1&lt;=(SIZE/2)) kx=(mx-X0)/SIZE;&#xA;                else kx=(mx-X0)/SIZE+1;&#xA;                if(can2&lt;=(SIZE/2)) ky=(my-Y0)/SIZE;&#xA;                else ky=(my-Y0)/SIZE+1;&#xA;                mx=0;&#xA;                my=0;&#xA;                f=1;&#xA;            }&#xA;&#xA;        if(f==1)  ok=1;&#xA;        if(ok==1)&#xA;        {&#xA;            char result;&#xA;            result=ifgook(kx,ky,player,computer);&#xA;            player_x=kx;&#xA;            player_y=ky;&#xA;            if(qz[kx][ky]==0)&#xA;            {&#xA;                drawcircle(kx,ky,player);&#xA;                return result;&#xA;            }&#xA;            if(qz[kx][ky]==0&amp;&amp;result==-1) return result;&#xA;            ok=0;&#xA;        }&#xA;    }&#xA;}&#xA;void drawcircle(int x,int y,char color)&#xA;{&#xA;    int i;&#xA;    int l,r,d,t;&#xA;    qz[x][y]=color;&#xA;    color--;&#xA;    active[x][y][0]=0;&#xA;    active[x][y][1]=0;&#xA;&#xA;    l=(x-2&gt;0)?x-2:0;&#xA;    t=(y-2&gt;0)?y-2:0;&#xA;    r=(x+2&gt;14)?14:x+2;&#xA;    d=(y+2&gt;14)?14:y+2;&#xA;&#xA;&#xA;    if(x-1&gt;=l&amp;&amp;y-1&gt;=t)&#xA;        if(qz[x-1][y-1]==0)&#xA;        {&#xA;            active[x-1][y-1][color]=1;&#xA;            if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==0)  active[x-2][y-2][color]=1;&#xA;        }&#xA;&#xA;    if(y-1&gt;=t)&#xA;        if(qz[x][y-1]==0)&#xA;        {&#xA;            active[x][y-1][color]=1;&#xA;            if(y-2&gt;=t&amp;&amp;qz[x][y-2]==0)  active[x][y-2][color]=1;&#xA;        }&#xA;&#xA;    if(x+1&lt;=r&amp;&amp;y-1&gt;=t)&#xA;        if(qz[x+1][y-1]==0)&#xA;        {&#xA;            active[x+1][y-1][color]=1;&#xA;            if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==0)  active[x+2][y-2][color]=1;&#xA;        }&#xA;&#xA;    if(x-1&gt;=l)&#xA;        if(qz[x-1][y]==0)&#xA;        {&#xA;            active[x-1][y][color]=1;&#xA;            if(x-2&gt;=l&amp;&amp;qz[x-2][y]==0)  active[x-2][y][color]=1;&#xA;        }&#xA;&#xA;    if(x-1&gt;=l&amp;&amp;y+1&lt;=d)&#xA;        if(qz[x-1][y+1]==0)&#xA;        {&#xA;            active[x-1][y+1][color]=1;&#xA;            if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==0)  active[x-2][y+2][color]=1;&#xA;        }&#xA;&#xA;    if(y+1&lt;=d)&#xA;        if(qz[x][y+1]==0)&#xA;        {&#xA;            active[x][y+1][color]=1;&#xA;            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  active[x][y+2][color]=1;&#xA;        }&#xA;&#xA;    if(x+1&lt;=r&amp;&amp;y+1&lt;=d)&#xA;        if(qz[x+1][y+1]==0)&#xA;        {&#xA;            active[x+1][y+1][color]=1;&#xA;            if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==0)  active[x+2][y+2][color]=1;&#xA;        }&#xA;&#xA;    if(x+1&lt;=r)&#xA;        if(qz[x+1][y]==0)&#xA;        {&#xA;            active[x+1][y][color]=1;&#xA;            if(x+2&lt;=r&amp;&amp;qz[x+2][y]==0)  active[x+2][y][color]=1;&#xA;        }&#xA;&#xA;    if(y+1&lt;=d)&#xA;        if(qz[x][y+1]==0)&#xA;        {&#xA;            active[x][y+1][color]=1;&#xA;            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  active[x][y+2][color]=1;&#xA;        }&#xA;&#xA;    if(l&lt;left)  left=l;&#xA;    if(r&gt;right) right=r;&#xA;    if(t&lt;top)   top=t;&#xA;    if(d&gt;down)  down=d;&#xA;&#xA;    drawcross(old_x,old_y);&#xA;    color=(color==0)?0:15;&#xA;    setcolor(0);&#xA;    setfillstyle(1,color);&#xA;     circle(X0+SIZE*x,Y0+SIZE*y,Radius);&#xA;&#xA;    setcolor(color^0xff);&#xA;&#xA;&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;&#xA;    HBRUSH brush;&#xA;    if(color==0)&#xA;    {&#xA;         setcolor(16);&#xA;        brush=CreateSolidBrush(0xffff);&#xA;    }&#xA;    else&#xA;    {&#xA;         setcolor(10);&#xA;        brush=CreateSolidBrush(0xffff00);&#xA;    }&#xA;     SelectObject(dc,brush);&#xA;    ellipse(X0+SIZE*x,Y0+SIZE*y,90+(1-color)*180,180+(1-color)*180,Radius-2,Radius-2);&#xA;    DeleteObject( brush);&#xA;&#xA;    drawcross(x,y);&#xA;&#xA;    old_x=x;&#xA;    old_y=y;&#xA;    setbit(x,y);&#xA;&#xA;}&#xA;void drawcross(int x,int y)&#xA;{&#xA;&#xA;    setcolor(2);&#xA;    line(X0+SIZE*x-6,Y0+SIZE*y,X0+SIZE*x+6,Y0+SIZE*y);&#xA;    line(X0+SIZE*x,Y0+SIZE*y-6,X0+SIZE*x,Y0+SIZE*y+6);&#xA;&#xA;}&#xA;&#xA;void setbit(int x,int y)&#xA;{&#xA;    int mx,my;&#xA;    mx=X0+SIZE*x;&#xA;    my=Y0+SIZE*y;&#xA;    printf(&quot;setbit,x:%d,y:%d&quot;,x,y);&#xA;    setmousecoord(mx,my);&#xA;}&#xA;&#xA;&#xA;unsigned condition[2][11]=&#xA;{&#xA;    {&#xA;        0x0054,&#xA;        0x0150,&#xA;        0x0144,&#xA;        0x0114,&#xA;        0x0555,&#xA;        0x0154,&#xA;        0x0151,&#xA;        0x0145,&#xA;        0x0115,&#xA;        0x0055,&#xA;        0x0155&#xA;    },&#xA;    {&#xA;        0x00a8,&#xA;        0x02a0,&#xA;        0x0288,&#xA;        0x0228,&#xA;        0x0aaa,&#xA;        0x02a8,&#xA;        0x02a2,&#xA;        0x028a,&#xA;        0x022a,&#xA;        0x00aa,&#xA;        0x02aa&#xA;    }&#xA;};&#xA;&#xA;int compare(unsigned input,int len,char color);&#xA;void attrib(int x,int y,QCL *pl,char color1,char color2)&#xA;{&#xA;    int h,i,j,dx,dy,k1,k2,k,num,rang1,rang2;&#xA;    register int temp;&#xA;    pl-&gt;p[0]=-1;&#xA;    pl-&gt;p[1]=-1;&#xA;    pl-&gt;p[2]=-1;&#xA;    pl-&gt;p[3]=-1;&#xA;    pl-&gt;l[0]=0;&#xA;    pl-&gt;l[1]=0;&#xA;    pl-&gt;l[2]=0;&#xA;    pl-&gt;l[3]=0;&#xA;&#xA;    for(i=0; i&lt;4; i++)&#xA;    {&#xA;        k1=1;&#xA;        k2=1;&#xA;        num=1;&#xA;        switch(i)&#xA;        {&#xA;        case 0:&#xA;            dx=0;&#xA;            dy=1;&#xA;            rang1=(y&gt;4)?4:y;&#xA;            rang2=(14-y&gt;4)?4:14-y;&#xA;            break;&#xA;        case 1:&#xA;            dx=1;&#xA;            dy=1;&#xA;            rang1=(x&lt;y)?x:y;&#xA;            rang1=(rang1&gt;4)?4:rang1;&#xA;            rang2=(x&gt;y)?x:y;&#xA;            rang2=(14-rang2&gt;4)?4:14-rang2;&#xA;            break;&#xA;        case 2:&#xA;            dx=1;&#xA;            dy=0;&#xA;            rang1=(x&gt;4)?4:x;&#xA;            rang2=(14-x&gt;4)?4:14-x;&#xA;            break;&#xA;        case 3:&#xA;            dx=1;&#xA;            dy=-1;&#xA;            rang1=(x&lt;14-y)?x:14-y;&#xA;            rang1=(rang1&gt;4)?4:rang1;&#xA;            rang2=(14-x&lt;y)?14-x:y;&#xA;            rang2=(rang2&gt;4)?4:rang2;&#xA;            break;&#xA;        }&#xA;        while(k1&lt;=rang1)&#xA;        {&#xA;            temp=qz[x-k1*dx][y-k1*dy];&#xA;            if(temp==0&amp;&amp;k1+1&lt;=rang1&amp;&amp;qz[x-(k1+1)*dx][y-(k1+1)*dy]==0)&#xA;            {&#xA;                k1+=2;&#xA;                break;&#xA;            }&#xA;            k1++;&#xA;            if(temp==color2) break;&#xA;            if(temp==color1) num++;&#xA;        }&#xA;        k1--;&#xA;&#xA;        while(k2&lt;=rang2)&#xA;        {&#xA;            temp=qz[x+k2*dx][y+k2*dy];&#xA;            if(temp==0&amp;&amp;k2+1&lt;=rang2&amp;&amp;qz[x+(k2+1)*dx][y+(k2+1)*dy]==0)&#xA;            {&#xA;                k2+=2;&#xA;                break;&#xA;            }&#xA;            k2++;&#xA;            if(temp==color2) break;&#xA;            if(temp==color1) num++;&#xA;        }&#xA;&#xA;        k=k1+k2;&#xA;        if(k&gt;4)&#xA;        {&#xA;            int m,n,back;&#xA;            unsigned swap=0,swap1;&#xA;            for(m=0; m&lt;5; m++)&#xA;                swap=swap|(qz[x-(k1-m)*dx][y-(k1-m)*dy]&lt;&lt;(m&lt;&lt;1));&#xA;            swap1=swap;&#xA;            switch(num)&#xA;            {&#xA;            case 3:&#xA;                if(k&gt;5)&#xA;                {&#xA;                    for(n=m; n&lt;k; n++)&#xA;                    {&#xA;                        swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;10);&#xA;                        back=compare(swap1,6,color1);&#xA;                        if(back&gt;=0)&#xA;                        {&#xA;                            pl-&gt;p[i]=back;&#xA;                            pl-&gt;l[i]=3;&#xA;                            pl-&gt;d[i]=k1-(n-m);&#xA;                            break;&#xA;                        }&#xA;                        swap1=swap1&gt;&gt;2;&#xA;                    }&#xA;                }&#xA;                if(pl-&gt;p[i]&gt;=0) continue;&#xA;                break;&#xA;            case 4:&#xA;                for(n=m-1; n&lt;k; n++)&#xA;                {&#xA;                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;8);&#xA;                    back=compare(swap1,5,color1);&#xA;                    if(back&gt;=0)&#xA;                    {&#xA;                        pl-&gt;p[i]=back;&#xA;                        pl-&gt;l[i]=4;&#xA;                        pl-&gt;d[i]=k1-(n-m)-1;&#xA;                        break;&#xA;                    }&#xA;                    swap1=swap1&gt;&gt;2;&#xA;                }&#xA;                if(pl-&gt;p[i]&gt;=0) continue;&#xA;                break;&#xA;            case 5:&#xA;                for(n=m-1; n&lt;k; n++)&#xA;                {&#xA;                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;8);&#xA;                    if(swap1==condition[color1-1][10])&#xA;                    {&#xA;                        pl-&gt;p[i]=10;&#xA;                        pl-&gt;l[i]=5;&#xA;                        pl-&gt;d[i]=k1-(n-m)-1;&#xA;                        break;&#xA;                    }&#xA;                    swap1=swap1&gt;&gt;2;&#xA;                }&#xA;                if(pl-&gt;p[i]&gt;=0) continue;&#xA;                break;&#xA;            case 7:&#xA;            case 8:&#xA;            case 9:&#xA;            case 6:&#xA;                for(n=m; n&lt;k; n++)&#xA;                {&#xA;                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;10);&#xA;                    if(swap1==condition[color1-1][4])&#xA;                    {&#xA;                        pl-&gt;p[i]=4;&#xA;                        pl-&gt;l[i]=6;&#xA;                        pl-&gt;d[i]=k1-(n-m);&#xA;                        break;&#xA;                    }&#xA;                    swap1=swap1&gt;&gt;2;&#xA;                }&#xA;                if(pl-&gt;p[i]&gt;=0) continue;&#xA;&#xA;                swap1=swap;&#xA;                for(n=m-1; n&lt;k; n++)&#xA;                {&#xA;                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;8);&#xA;                    if(swap1==condition[color1-1][10])&#xA;                    {&#xA;                        pl-&gt;p[i]=10;&#xA;                        pl-&gt;l[i]=5;&#xA;                        pl-&gt;d[i]=k1-(n-m)-1;&#xA;                        break;&#xA;                    }&#xA;                    swap1=swap1&gt;&gt;2;&#xA;                }&#xA;                if(pl-&gt;p[i]&gt;=0) continue;&#xA;&#xA;                for(n=m-1; n&lt;k; n++)&#xA;                {&#xA;                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;8);&#xA;                    back=compare(swap1,5,color1);&#xA;                    if(back&gt;=0)&#xA;                    {&#xA;                        pl-&gt;p[i]=back;&#xA;                        pl-&gt;l[i]=4;&#xA;                        pl-&gt;d[i]=k1-(n-m)-1;&#xA;                        break;&#xA;                    }&#xA;                    swap1=swap1&gt;&gt;2;&#xA;                }&#xA;                if(pl-&gt;p[i]&gt;=0) continue;&#xA;&#xA;                swap1=swap;&#xA;                for(n=m; n&lt;k; n++)&#xA;                {&#xA;                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;10);&#xA;                    back=compare(swap1,6,color1);&#xA;                    if(back&gt;=0)&#xA;                    {&#xA;                        pl-&gt;p[i]=back;&#xA;                        pl-&gt;l[i]=3;&#xA;                        pl-&gt;d[i]=k1-(n-m);&#xA;                        break;&#xA;                    }&#xA;                    swap1=swap1&gt;&gt;2;&#xA;                }&#xA;                if(pl-&gt;p[i]&gt;=0) continue;&#xA;                break;&#xA;            default:&#xA;                break;&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;int compare(unsigned input,int len,char color)&#xA;{&#xA;    int i;&#xA;    color--;&#xA;    switch(len)&#xA;    {&#xA;    case 5:&#xA;        for(i=5; i&lt;10; i++)&#xA;            if(input==condition[color][i]) return i;&#xA;        return -1;&#xA;    case 6:&#xA;        for(i=0; i&lt;4; i++)&#xA;            if(input==condition[color][i]) return i;&#xA;        return -1;&#xA;    default:&#xA;        printf(&quot;error len in compare\n&quot;);&#xA;        break;&#xA;    }&#xA;}&#xA;/////////////////////////////////////////////////////////////&#xA;void OnMouseDown(int id,int btn,int state,int x,int y)&#xA;{&#xA;&#xA;    mx=x;&#xA;    my=y;&#xA;    printf(&quot;mouse down,x:%d,y:%d&quot;,mx,my);&#xA;}&#xA;void OnClose()&#xA;{&#xA;    printf(&quot;need close...&quot;);&#xA;    needclose=1;&#xA;    Wait(1);&#xA;&#xA;}&#xA;void InitGraph()&#xA;{&#xA;    HideLeftTools();&#xA;    ClearVclControls();&#xA;    //ShowVclWin(200);&#xA;    HideVclWin(200);&#xA;    //p=GetGuiWin(0);&#xA;    pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;五子棋&quot;,&quot;Width&quot;,430,&quot;height&quot;,480,&quot;BorderIcons&quot;,&quot;[]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnKeyDown&quot;,OnKeyDown,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;    //CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,40,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮&#xA;    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);&#xA;    img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,400,&quot;height&quot;,400,&quot;OnMouseDown&quot;,OnMouseDown,0);&#xA;    //ms=CreateComponentEx(pfm,&quot;label&quot;,&quot;caption&quot;,&quot;X&quot;,&quot;left&quot;, 0,&quot;top&quot;, 0,&quot;width&quot;,20,&quot;height&quot;,20,0);&#xA;&#xA;    SetProperty(pfm,&quot;visible&quot;,1);&#xA;&#xA;    RECT rect= {0,0,640,480};&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    HBRUSH brush=CreateSolidBrush(0x0000);&#xA;    SelectObject(dc,brush);&#xA;    FillRect(dc,&amp;rect,brush);&#xA;    DeleteObject(brush);&#xA;}&#xA;void main(void)&#xA;{&#xA;    int i;&#xA;    char who,END=0;&#xA;    int result,temp;&#xA;    InitGraph();&#xA;&#xA;&#xA;    while(!END)&#xA;    {&#xA;        SetProperty(pfm,&quot;caption&quot;,&quot;五子棋&quot;);&#xA;        if(needclose)&#xA;        {&#xA;            CloseForm(pfm);&#xA;            return;&#xA;        }&#xA;        who=1;&#xA;&#xA;        reset();&#xA;        printf(&quot;game init...............&quot;);&#xA;        RECT rect= {0,0,640,480};&#xA;        dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;        HBRUSH brush=CreateSolidBrush(0x0000);&#xA;        SelectObject(dc,brush);&#xA;        FillRect(dc,&amp;rect,brush);&#xA;        DeleteObject(brush);&#xA;&#xA;        game_init();&#xA;        Invalidate(img);&#xA;        if(MessageBox(GetFormHandle(pfm),&quot;你想先手吗？&quot;,&quot;开始下棋&quot;,4)==6 )&#xA;            player=2;&#xA;        else&#xA;            player=1;&#xA;&#xA;        mx=0;&#xA;        my=0;&#xA;        computer=(player==1)?2:1;&#xA;        step=0;&#xA;        //drawcircle(7,7,1);&#xA;&#xA;        SetProperty(pfm,&quot;caption&quot;,&quot;五子棋-轮到您走棋&quot;);&#xA;&#xA;        temp=0;&#xA;        result=0;&#xA;&#xA;        while(1)&#xA;        {&#xA;            set(who+1);&#xA;&#xA;            if(who==player-1)&#xA;            {&#xA;                printf(&quot;player go&quot;);&#xA;                SetProperty(pfm,&quot;caption&quot;,&quot;五子棋-轮到您走棋&quot;);&#xA;                temp=player_go();&#xA;            }&#xA;            else&#xA;            {&#xA;                printf(&quot;computer go&quot;);&#xA;                SetProperty(pfm,&quot;caption&quot;,&quot;五子棋-轮到计算机走棋&quot;);&#xA;                result=computer_go(temp);&#xA;            }&#xA;            if(needclose)&#xA;            {&#xA;                printf(&quot;exit go&quot;);&#xA;                CloseForm(pfm);&#xA;                return;&#xA;            }&#xA;            printf(&quot;temp:%d,result:%d&quot;,temp,result);&#xA;&#xA;            if(temp==1||result==-1)&#xA;            {&#xA;                set(0);&#xA;&#xA;                MessageBox(GetFormHandle(pfm),&quot;未知!          &quot;,&quot;本局结束&quot;,0);&#xA;                if(needclose) return;&#xA;&#xA;                mx=0;&#xA;                my=0;&#xA;                break;&#xA;            }&#xA;            if(temp==-1)&#xA;            {&#xA;                set(0);&#xA;&#xA;                MessageBox(GetFormHandle(pfm),&quot;您赢了!          &quot;,&quot;本局结束&quot;,0);&#xA;                if(needclose) return;&#xA;&#xA;                mx=0;&#xA;                my=0;&#xA;                break;&#xA;            }&#xA;            if(result==1)&#xA;            {&#xA;                printf(&quot;result==1&quot;);&#xA;                set(0);&#xA;&#xA;                MessageBox(GetFormHandle(pfm),&quot;计算机赢了!         &quot;,&quot;本局结束&quot;,0);&#xA;                if(needclose) return;&#xA;&#xA;                mx=0;&#xA;                my=0;&#xA;                break;&#xA;            }&#xA;            if(temp==0x10)&#xA;            {&#xA;                END=1;&#xA;                break;&#xA;            }&#xA;            if(temp==0x11) break;&#xA;            who^=1;&#xA;        }&#xA;    }&#xA;&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;"/>
      <Command cmdname="五子棋-页面显示" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;#include &quot;stdio.h&quot;&#xA;#include &quot;conio.h&quot;&#xA;#define SIZE 24&#xA;#define X0 30&#xA;#define Y0 30&#xA;#define Radius 16&#xA;#define TRUE 1&#xA;#include &quot;stdio.h&quot;&#xA;#include &quot;dos.h&quot;&#xA;#include &quot;conio.h&quot;&#xA;#include &quot;stdlib.h&quot;&#xA;&#xA;#define LEFT  37&#xA;#define RIGHT 39&#xA;#define DOWN  40  /*此键为加速键*/&#xA;#define UP    38  /*此键为变形键*/&#xA;#define ESC   27  /*此键为退出键*/&#xA;#define ENTER 13&#xA;#define DEPTH 14  //递归深度，棋力&#xA;&#xA;int player_x,player_y;&#xA;int kx=7,ky=7;&#xA;int old_x,old_y;&#xA;char back[6]= {27,28,25,26,31,48};&#xA;int pfm;&#xA;void graph_init();&#xA;void drawline();&#xA;char getkey();&#xA;void drawcircle(int ,int ,char);&#xA;void drawcross(int,int);&#xA;void setbit(int,int);&#xA;&#xA;int needclose=0;&#xA;int KeyDown=0;&#xA;HPEN pen=0;&#xA;int img;&#xA;HANDLE dc;&#xA;int ms;&#xA;int mx,my;&#xA;void setcolor(int cl)&#xA;{&#xA;    cl*=0xfffff;&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    if(pen!=0) DeleteObject(pen);&#xA;    pen=CreatePen(PS_SOLID,1,cl);&#xA;    SelectObject(dc,pen);&#xA;}&#xA;int bioskey(int flat)&#xA;{&#xA;    int tmp;&#xA;    if(flat==1)&#xA;    {&#xA;        if(KeyDown!=0)&#xA;            return 1;&#xA;        else&#xA;            return 0;&#xA;    }&#xA;    tmp=KeyDown;&#xA;    KeyDown=0;&#xA;    return tmp;&#xA;&#xA;}&#xA;void putpixel(int x,int y,int cl)&#xA;{&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    SetPixel(dc,x,y,cl*0xfffff);&#xA;}&#xA;void settextstyle(int a,int b,int c)&#xA;{&#xA;&#xA;}&#xA;void outtextxy(int x,int y,char *s)&#xA;{&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    TextOutA(dc,x,y,s,strlen(s));&#xA;}&#xA;&#xA;void line(int x0,int y0,int x1,int y1)&#xA;{&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    MoveToEx(dc,x0,y0,0);&#xA;    LineTo(dc,x1,y1);&#xA;}&#xA;&#xA;void rectangle(int x0,int y0,int x1,int y1)&#xA;{&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    MoveToEx(dc,x0,y0,0);&#xA;    LineTo(dc,x1,y0);&#xA;    LineTo(dc,x1,y1);&#xA;    LineTo(dc,x0,y1);&#xA;    LineTo(dc,x0,y0);&#xA;}&#xA;void circle(int x,int y,int r)&#xA;{&#xA;    rectangle(x-r/2,y-r/2,x+r/2,y+r/2);&#xA;}&#xA;&#xA;&#xA;void setmousecoord(int x,int y)&#xA;{&#xA; &#xA;    RECT rect;&#xA;    x+=10;&#xA;    y+=40;&#xA;    rect.left=x-10;&#xA;    rect.top=y-10;&#xA;    rect.right=x+10;&#xA;    rect.bottom=y+10;&#xA;&#xA;    InvalidateRect(GetFormHandle(pfm),&amp;rect,0);&#xA;    UpdateWindow(GetFormHandle(pfm));&#xA;    &#xA;}&#xA;&#xA;&#xA;void setfillstyle(int m1,int m2)&#xA;{&#xA;&#xA;}&#xA;&#xA;void ellipse(int x0,int y0,int start,int end,int r0,int r1)&#xA;{&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    Ellipse(dc,x0-r0/2,y0-r1/2,x0+r0/2,y0+r1/2);&#xA;}&#xA;&#xA;&#xA;&#xA;void OnKeyDown(int id,int *key,int state)&#xA;{&#xA;    KeyDown=*key;&#xA;}&#xA;&#xA;&#xA;&#xA;typedef struct struct1&#xA;{&#xA;    char p[4];&#xA;    char l[4];&#xA;    char d[4];&#xA;} QCL;&#xA;&#xA;&#xA;QCL pos[15][15][2];&#xA;char all[15][15][2];&#xA;&#xA;char keepgo(int,int,int,char,char,int,QCL);&#xA;char goon(int,int,char,char,int);&#xA;char ifgook(int,int,char,char);&#xA;char computer_keep(int,int,int);&#xA;void exit_game();&#xA;unsigned int step=0;&#xA;unsigned keep[11]=&#xA;{&#xA;    0x0015,  //011100&#xA;    0x0062,  //001110&#xA;    0x0613,  //010110&#xA;    0x0614,  //011010&#xA;    0x0000,  //111111&#xA;    0x0001,  //01111&#xA;    0x0002,  //10111&#xA;    0x0003,  //11011&#xA;    0x0004,  //11101&#xA;    0x0005,  //11110&#xA;    0x0000   //11111&#xA;};&#xA;char judge;&#xA;/*****************************/&#xA;/*     return value          */&#xA;/*   -1    can not move      */&#xA;/*   0     nothing           */&#xA;/*   1     5,6  ready        */&#xA;/*   2     3    ready        */&#xA;/*   3     3,3  ready        */&#xA;/*   4     4    ready        */&#xA;/*   5     3,4  ready        */&#xA;/*   6     4,4  ready        */&#xA;/*****************************/&#xA;char computer_go(int) ;&#xA;char many(int ,int);&#xA;char power(int ,int ,char);&#xA;/*****************************/&#xA;/*     return value          */&#xA;/*   -1    lose the game     */&#xA;/*   0     nothing happen    */&#xA;/*   1     win the game      */&#xA;/*****************************/&#xA;&#xA;&#xA;&#xA;&#xA;void active_init(void);&#xA;void game_init(void);&#xA;&#xA;&#xA;unsigned int left,top,right,down;&#xA;unsigned char player,computer;&#xA;QCL Glist;&#xA;char active[15][15][2];&#xA;char qz[15][15];&#xA;&#xA;&#xA;#define LEN 252&#xA;#define COLOR 15&#xA;#define INTR 0X1C    /* The clock tick interrupt */&#xA;&#xA;&#xA;#define X 98&#xA;#define Y 10&#xA;char num[11][9]=&#xA;{&#xA;    {0x7e,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x7e},//0&#xA;    {0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08},//1&#xA;    {0x7e,0x01,0x01,0x01,0x7e,0x80,0x80,0x80,0x7e},//2&#xA;    {0x7e,0x01,0x01,0x01,0x7e,0x01,0x01,0x01,0x7e},//3&#xA;    {0x81,0x81,0x81,0x81,0x7e,0x01,0x01,0x01,0x01},//4&#xA;    {0x7e,0x80,0x80,0x80,0x7e,0x01,0x01,0x01,0x7e},//5&#xA;    {0x7e,0x80,0x80,0x80,0x7e,0x81,0x81,0x81,0x7e},//6&#xA;    {0x7e,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01},//7&#xA;    {0x7e,0x81,0x81,0x81,0x7e,0x81,0x81,0x81,0x7e},//8&#xA;    {0x7e,0x81,0x81,0x81,0x7e,0x01,0x01,0x01,0x7e},//9&#xA;    {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff},&#xA;};&#xA;&#xA;&#xA;#define COLOR 10&#xA;&#xA;void text(int,int,char,int,char *);&#xA;&#xA;int count0=0,second0=0;/*computer's time*/&#xA;int count1=0,second1=0;/*player's time*/&#xA;int check;&#xA;&#xA;&#xA;&#xA;void set(int che)&#xA;{&#xA;    if(che&gt;2) return;&#xA;    check=che;&#xA;}&#xA;void reset()&#xA;{&#xA;    count0=0;&#xA;    count1=0;&#xA;    second0=0;&#xA;    second1=0;&#xA;    check=0;&#xA;&#xA;}&#xA;&#xA;&#xA;void init();&#xA;void attrib(int x,int y,QCL *pl,char color1,char color2);&#xA;void qz_init();&#xA;void game_init(void)&#xA;{&#xA;    init();&#xA;    active_init();&#xA;    qz_init();&#xA;    left=right=top=down=7;&#xA;}&#xA;void active_init(void)&#xA;{&#xA;    int i,j;&#xA;    for(i=0; i&lt;15; i++)&#xA;        for(j=0; j&lt;15; j++)&#xA;            active[i][j][0]=active[i][j][1]=0;&#xA;}&#xA;void qz_init(void)&#xA;{&#xA;    int i,j;&#xA;    for(i=0; i&lt;15; i++)&#xA;        for(j=0; j&lt;15; j++)&#xA;            qz[i][j]=0;&#xA;}&#xA;&#xA;char computer_go(int len)&#xA;{&#xA;    register int i,j;&#xA;    char result,temp1,temp2,temp3;&#xA;    int max,large;&#xA;    char max_x,max_y;&#xA;    //ShowMessage(&quot;Computer go&quot;);&#xA;    step++;&#xA;    for(i=left; i&lt;=right; i++)&#xA;        for(j=top; j&lt;=down; j++)&#xA;        {&#xA;            all[i][j][computer-1]=ifgook(i,j,computer,player);&#xA;            pos[i][j][computer-1]=Glist;&#xA;            all[i][j][player-1]=ifgook(i,j,player,computer);&#xA;            pos[i][j][player-1]=Glist;&#xA;        }&#xA;&#xA;    for(i=left; i&lt;=right; i++)&#xA;        for(j=top; j&lt;=down; j++)&#xA;            if(all[i][j][computer-1]==1)&#xA;            {&#xA;                drawcircle(i,j,computer);&#xA;                return 1;&#xA;            }&#xA;&#xA;    for(i=left; i&lt;=right; i++)&#xA;        for(j=top; j&lt;=down; j++)&#xA;            if(all[i][j][player-1]==1)&#xA;            {&#xA;                if(all[i][j][computer-1]!=-1)&#xA;                {&#xA;                    drawcircle(i,j,computer);&#xA;                    return 0;&#xA;                }&#xA;                else return -1;&#xA;            }&#xA;&#xA;    large=-1;&#xA;    judge=4;&#xA;    if(len==3)&#xA;    {&#xA;        for(i=left; i&lt;=right; i++)&#xA;            for(j=top; j&lt;=down; j++)&#xA;            {&#xA;                if(active[i][j][computer-1]==1)&#xA;                {&#xA;                    switch(all[i][j][computer-1])&#xA;                    {&#xA;                    case -1:&#xA;                        break;&#xA;                    case 0:&#xA;                        break;&#xA;                    case 6:&#xA;                    case 1:&#xA;                        drawcircle(i,j,computer);&#xA;                        return 1;&#xA;                    case 2:&#xA;                    case 3:&#xA;                        break;&#xA;                    case 5:&#xA;                        qz[i][j]=computer;&#xA;                        temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]);&#xA;                        qz[i][j]=0;&#xA;                        if(temp1==-1)&#xA;                        {&#xA;                            drawcircle(i,j,computer);&#xA;                            return 0;&#xA;                        }&#xA;                        break;&#xA;                    case 4:&#xA;                        temp3=power(i,j,computer);&#xA;                        if(temp3&lt;=large) break;&#xA;                        qz[i][j]=computer;&#xA;                        temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]);&#xA;                        qz[i][j]=0;&#xA;                        if(temp1==-1)&#xA;                        {&#xA;                            large=temp3;&#xA;                            max_x=i;&#xA;                            max_y=j;&#xA;                        }&#xA;                        break;&#xA;                    default:&#xA;                        printf(&quot;error if computer_go().&quot;);&#xA;                    }&#xA;                }&#xA;            }&#xA;        if(large&gt;=0)&#xA;        {&#xA;            drawcircle(max_x,max_y,computer);&#xA;            return 0;&#xA;        }&#xA;        result=computer_keep(player_x,player_y,3);&#xA;        if(result==1) return 0;&#xA;    }&#xA;    else&#xA;    {&#xA;        judge=4;&#xA;        large=-1;&#xA;        for(i=left; i&lt;=right; i++)&#xA;            for(j=top; j&lt;=down; j++)&#xA;            {&#xA;                if(active[i][j][computer-1]==1)&#xA;                {&#xA;                    switch(all[i][j][computer-1])&#xA;                    {&#xA;                    case -1:&#xA;                        break;&#xA;                    case 0:&#xA;                        break;&#xA;                    case 6:&#xA;                    case 1:&#xA;                        drawcircle(i,j,computer);&#xA;                        return 1;&#xA;                    case 2:&#xA;                    case 3:&#xA;                        break;&#xA;                    case 5:&#xA;                        qz[i][j]=computer;&#xA;                        temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]);&#xA;                        qz[i][j]=0;&#xA;                        if(temp1==-1)&#xA;                        {&#xA;                            drawcircle(i,j,computer);&#xA;                            return 0;&#xA;                        }&#xA;                        break;&#xA;                    case 4:&#xA;                        temp3=power(i,j,computer);&#xA;                        if(temp3&lt;=large) break;&#xA;                        qz[i][j]=computer;&#xA;                        temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]);&#xA;                        qz[i][j]=0;&#xA;                        if(temp1==-1)&#xA;                        {&#xA;                            large=temp3;&#xA;                            max_x=i;&#xA;                            max_y=j;&#xA;                        }&#xA;                        break;&#xA;                    default:&#xA;                        printf(&quot;error if computer_go().&quot;);&#xA;                    }&#xA;                }&#xA;            }&#xA;        if(large&gt;=0)&#xA;        {&#xA;            drawcircle(max_x,max_y,computer);&#xA;            return 0;&#xA;        }&#xA;    }&#xA;&#xA;    large=-1;&#xA;    judge=4;&#xA;    for(i=left; i&lt;=right; i++)&#xA;        for(j=top; j&lt;=down; j++)&#xA;        {&#xA;            if(active[i][j][player-1]==1)&#xA;            {&#xA;                temp1=all[i][j][computer-1];&#xA;                switch(all[i][j][player-1])&#xA;                {&#xA;                case -1:&#xA;                    break;&#xA;                case 0:&#xA;                    break;&#xA;                case 6:&#xA;                case 1:&#xA;                    if(temp1!=-1)&#xA;                    {&#xA;                        drawcircle(i,j,computer);&#xA;                        return 0;&#xA;                    }&#xA;                    break;&#xA;                case 2:&#xA;                case 3:&#xA;                    break;&#xA;                case 5:&#xA;                    if(temp1!=-1)&#xA;                    {&#xA;                        qz[i][j]=player;&#xA;                        temp2=keepgo(i,j,4,computer,player,0,pos[i][j][player-1]);&#xA;                        qz[i][j]=0;&#xA;                        if(temp2==-1)&#xA;                        {&#xA;                            drawcircle(i,j,computer);&#xA;                            return 0;&#xA;                        }&#xA;                    }&#xA;                    break;&#xA;                case 4:&#xA;                    if(temp1!=-1)&#xA;                    {&#xA;                        temp3=power(i,j,player);&#xA;                        if(temp3&lt;=large) break;&#xA;                        qz[i][j]=player;&#xA;                        temp2=keepgo(i,j,4,computer,player,0,pos[i][j][player-1]);&#xA;                        qz[i][j]=0;&#xA;                        if(temp2==-1)&#xA;                        {&#xA;                            large=temp3;&#xA;                            max_x=i;&#xA;                            max_y=j;&#xA;                        }&#xA;                    }&#xA;                    break;&#xA;                default:&#xA;                    printf(&quot;error if player_go().&quot;);&#xA;                }&#xA;            }&#xA;        }&#xA;    if(large&gt;=0)&#xA;    {&#xA;        drawcircle(max_x,max_y,computer);&#xA;        return 0;&#xA;    }&#xA;&#xA;&#xA;    judge=3;&#xA;    large=-1;&#xA;    for(i=left; i&lt;=right; i++)&#xA;        for(j=top; j&lt;=down; j++)&#xA;        {&#xA;            if(active[i][j][computer-1]==1)&#xA;            {&#xA;                switch(all[i][j][computer-1])&#xA;                {&#xA;                case -1:&#xA;                    break;&#xA;                case 0:&#xA;                    break;&#xA;                case 6:&#xA;                case 5:&#xA;                    drawcircle(i,j,computer);&#xA;                    return 0;&#xA;                case 1:&#xA;                    drawcircle(i,j,computer);&#xA;                    return 1;&#xA;                case 2:&#xA;                case 3:&#xA;                    temp3=power(i,j,computer);&#xA;                    if(temp3&lt;=large) break;&#xA;                    qz[i][j]=computer;&#xA;                    temp1=keepgo(i,j,3,player,computer,0,pos[i][j][computer-1]);&#xA;                    qz[i][j]=0;&#xA;                    if(temp1==-1)&#xA;                    {&#xA;                        large=temp3;&#xA;                        max_x=i;&#xA;                        max_y=j;&#xA;                    }&#xA;                    break;&#xA;                case 4:&#xA;                    temp3=power(i,j,computer);&#xA;                    if(temp3&lt;=large) break;&#xA;                    qz[i][j]=computer;&#xA;                    temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]);&#xA;                    qz[i][j]=0;&#xA;                    if(temp1==-1)&#xA;                    {&#xA;                        large=temp3;&#xA;                        max_x=i;&#xA;                        max_y=j;&#xA;                    }&#xA;                    break;&#xA;                default:&#xA;                    printf(&quot;error if player_go().&quot;);&#xA;                }&#xA;            }&#xA;        }&#xA;    if(large&gt;=0)&#xA;    {&#xA;        drawcircle(max_x,max_y,computer);&#xA;        return 0;&#xA;    }&#xA;&#xA;&#xA;    large=-1;&#xA;    judge=3;&#xA;    for(i=left; i&lt;=right; i++)&#xA;        for(j=top; j&lt;=down; j++)&#xA;        {&#xA;            if(active[i][j][player-1]==1)&#xA;            {&#xA;                temp1=all[i][j][computer-1];&#xA;                switch(all[i][j][player-1])&#xA;                {&#xA;                case -1:&#xA;                    break;&#xA;                case 0:&#xA;                    break;&#xA;                case 6:&#xA;                case 5:&#xA;                case 1:&#xA;                    if(temp1!=-1)&#xA;                    {&#xA;                        drawcircle(i,j,computer);&#xA;                        return 0;&#xA;                    }&#xA;                    break;&#xA;                case 3:&#xA;                    if(temp1!=-1)&#xA;                    {&#xA;                        qz[i][j]=player;&#xA;                        temp2=keepgo(i,j,3,computer,player,0,pos[i][j][player-1]);&#xA;                        qz[i][j]=0;&#xA;                        if(temp2!=1)&#xA;                        {&#xA;                            drawcircle(i,j,computer);&#xA;                            return 0;&#xA;                        }&#xA;                    }&#xA;                    break;&#xA;                case 2:&#xA;                    if(temp1!=-1)&#xA;                    {&#xA;                        temp3=power(i,j,player);&#xA;                        if(temp3&lt;=large) break;&#xA;                        qz[i][j]=player;&#xA;                        temp2=keepgo(i,j,3,computer,player,0,pos[i][j][player-1]);&#xA;                        qz[i][j]=0;&#xA;                        if(temp2!=1)&#xA;                        {&#xA;                            large=temp3;&#xA;                            max_x=i;&#xA;                            max_y=j;&#xA;                        }&#xA;                    }&#xA;                    break;&#xA;                case 4:&#xA;                    if(temp1!=-1)&#xA;                    {&#xA;                        temp3=power(i,j,player);&#xA;                        if(temp3&lt;=large) break;&#xA;                        qz[i][j]=player;&#xA;                        temp2=keepgo(i,j,4,computer,player,0,pos[i][j][player-1]);&#xA;                        qz[i][j]=0;&#xA;                        if(temp2==-1)&#xA;                        {&#xA;                            large=temp3;&#xA;                            max_x=i;&#xA;                            max_y=j;&#xA;                        }&#xA;                    }&#xA;                    break;&#xA;                default:&#xA;                    printf(&quot;error if player_go().&quot;);&#xA;                }&#xA;            }&#xA;        }&#xA;    if(large&gt;=0)&#xA;    {&#xA;        drawcircle(max_x,max_y,computer);&#xA;        return 0;&#xA;    }&#xA;&#xA;    max=-1;&#xA;    max_x=6;&#xA;    max_y=7;&#xA;    if(computer==2&amp;&amp;step&lt;=5)&#xA;    {&#xA;        for(i=left; i&lt;=right; i++)&#xA;            for(j=top; j&lt;=down; j++)&#xA;            {&#xA;                if(all[i][j][0]&gt;0&amp;&amp;all[i][j][1]&gt;0)&#xA;                {&#xA;                    temp1=power(i,j,1);&#xA;                    if(temp1&gt;max)&#xA;                    {&#xA;                        max=temp1;&#xA;                        max_x=i;&#xA;                        max_y=j;&#xA;                    }&#xA;                    else if(temp1==max&amp;&amp;power(max_x,max_y,computer)&lt;power(i,j,computer))&#xA;                    {&#xA;                        max_x=i;&#xA;                        max_y=j;&#xA;                    }&#xA;                }&#xA;            }&#xA;        if(max&gt;=0)&#xA;        {&#xA;            drawcircle(max_x,max_y,computer);&#xA;            return 0;&#xA;        }&#xA;&#xA;        for(i=left; i&lt;=right; i++)&#xA;            for(j=top; j&lt;=down; j++)&#xA;            {&#xA;                if(all[i][j][computer-1]!=-1)&#xA;                {&#xA;                    temp1=power(i,j,1);&#xA;                    if(temp1&gt;max)&#xA;                    {&#xA;                        max=temp1;&#xA;                        max_x=i;&#xA;                        max_y=j;&#xA;                    }&#xA;                }&#xA;            }&#xA;        if(max&gt;=0)&#xA;        {&#xA;            drawcircle(max_x,max_y,computer);&#xA;            return 0;&#xA;        }&#xA;    }&#xA;&#xA;    if(computer==1&amp;&amp;step&lt;=5)&#xA;    {&#xA;        for(i=left; i&lt;=right; i++)&#xA;            for(j=top; j&lt;=down; j++)&#xA;            {&#xA;                if(all[i][j][computer-1]!=-1&amp;&amp;active[i][j][computer-1]==1&amp;&amp;all[i][j][player-1]&gt;0)&#xA;                {&#xA;                    temp1=power(i,j,computer);&#xA;                    if(temp1&gt;max)&#xA;                    {&#xA;                        max=temp1;&#xA;                        max_x=i;&#xA;                        max_y=j;&#xA;                    }&#xA;                    else if(temp1==max&amp;&amp;power(max_x,max_y,player)&lt;power(i,j,player))&#xA;                    {&#xA;                        max_x=i;&#xA;                        max_y=j;&#xA;                    }&#xA;                }&#xA;            }&#xA;        if(max&gt;=0)&#xA;        {&#xA;            drawcircle(max_x,max_y,computer);&#xA;            return 0;&#xA;        }&#xA;    }&#xA;&#xA;    for(i=left; i&lt;=right; i++)&#xA;        for(j=top; j&lt;=down; j++)&#xA;        {&#xA;            if(qz[i][j]==0&amp;&amp;all[i][j][computer-1]!=-1)&#xA;            {&#xA;                temp1=many(i,j);&#xA;                if(temp1&gt;max)&#xA;                {&#xA;                    max=temp1;&#xA;                    max_x=i;&#xA;                    max_y=j;&#xA;                }&#xA;            }&#xA;        }&#xA;    drawcircle(max_x,max_y,computer);&#xA;    return 0;&#xA;}&#xA;&#xA;char player_go()&#xA;{&#xA;    char result;&#xA;&#xA;    result=getkey();&#xA;&#xA;    if(needclose)&#xA;    {&#xA;        printf(&quot;exit player go&quot;);&#xA;        return 0;&#xA;    }&#xA;&#xA;    switch(result)&#xA;    {&#xA;    case 0:&#xA;        return 0;&#xA;    case -1:&#xA;        return -1;&#xA;    case 1:&#xA;        return 1;&#xA;    case 3:&#xA;    case 2:&#xA;        return 3;&#xA;    case 4:&#xA;    case 5:&#xA;    case 6:&#xA;        return 4;&#xA;    default:&#xA;        return result;&#xA;    }&#xA;}&#xA;&#xA;char ifgook(int x,int y,char color1,char color2)&#xA;{&#xA;    register int i;&#xA;    int k3=0,k4=0;&#xA;    if(qz[x][y]!=0) return -1;&#xA;    qz[x][y]=color1;&#xA;    attrib(x,y,&amp;Glist,color1,color2);&#xA;    qz[x][y]=0;&#xA;    for(i=0; i&lt;4; i++)&#xA;    {&#xA;        if(Glist.p[i]&gt;=0&amp;&amp;Glist.p[i]&lt;=3)&#xA;            k3++;&#xA;        else if(Glist.p[i]==10)&#xA;            return 1;   /* there is five .*/&#xA;&#xA;        else if(Glist.p[i]&lt;10&amp;&amp;Glist.p[i]&gt;=5)&#xA;            k4++;&#xA;&#xA;        if(Glist.p[i]==4&amp;&amp;color1==1) return -1;&#xA;        if(Glist.p[i]==4&amp;&amp;color1==2) return 1;&#xA;    }&#xA;    if(k4&gt;1)&#xA;    {&#xA;        if(color1==1) return -1;&#xA;        else   return 6;&#xA;    }&#xA;    if(k3&gt;1&amp;&amp;color1==1) return -1;&#xA;    if(k3==1&amp;&amp;k4==1) return 5;  /* case  a 3 and a 4 */&#xA;    if(k3&gt;1) return 3;&#xA;    if(k4==1) return 4 ;        /* case a 4          */&#xA;    if(k3==1) return 2 ;        /* case a 3          */&#xA;    return 0;&#xA;}&#xA;&#xA;char keepgo(int x,int y,int  len,char color1,char color2,int depth,QCL list)&#xA;{&#xA;    int dx,dy,x0,y0;&#xA;    int i,bx,by,mask,d,r0,r1,r2;&#xA;    char old_judge;&#xA;    if(depth&gt;=DEPTH) return -1;&#xA;    else   depth++;&#xA;    for(i=0; i&lt;4; i++)&#xA;    {&#xA;        switch(i)&#xA;        {&#xA;        case 0:&#xA;            dx=0;&#xA;            dy=1;&#xA;            break;&#xA;        case 1:&#xA;            dx=1;&#xA;            dy=1;&#xA;            break;&#xA;        case 2:&#xA;            dx=1;&#xA;            dy=0;&#xA;            break;&#xA;        case 3:&#xA;            dx=1;&#xA;            dy=-1;&#xA;            break;&#xA;        }&#xA;        if(list.l[i]==len)&#xA;        {&#xA;            int j;&#xA;            j=list.p[i];&#xA;            bx=x-dx*list.d[i];&#xA;            by=y-dy*list.d[i];&#xA;            mask=keep[j];&#xA;            while(mask!=0)&#xA;            {&#xA;&#xA;                d=(mask&amp;0x000f)-1;&#xA;                x0=bx+d*dx;&#xA;                y0=by+d*dy;&#xA;                r1=ifgook(x0,y0,color1,color2);&#xA;&#xA;                switch(r1)&#xA;                {&#xA;                case -1:&#xA;                    break;&#xA;                case 0:&#xA;                    if(judge==4||judge==5)&#xA;                    {&#xA;                        qz[x0][y0]=color1;&#xA;                        r2=goon(x,y,color2,color1,depth);&#xA;                        qz[x0][y0]=0;&#xA;                        if(r2==1) break;&#xA;                        else return 1;&#xA;                    }&#xA;                    if(judge==3)&#xA;                    {&#xA;                        judge=4;&#xA;                        qz[x0][y0]=color1;&#xA;                        r2=goon(x0,y0,color1,color2,depth);&#xA;                        judge=3;&#xA;                        if(r2==1) judge=4;&#xA;                        r2=goon(x,y,color2,color1,depth);&#xA;                        qz[x0][y0]=0;&#xA;                        judge=3;&#xA;                        if(r2==1) break;&#xA;                        else return 1;&#xA;                    }&#xA;                case 2:&#xA;                case 3:&#xA;                    old_judge=judge;&#xA;                    if(judge==3) judge=4;&#xA;                    qz[x0][y0]=color1;&#xA;                    r2=goon(x,y,color2,color1,depth);&#xA;                    qz[x0][y0]=0;&#xA;                    judge=old_judge;&#xA;                    if(r2==1) break;&#xA;                    else return 1;&#xA;                case 1:&#xA;                    return 1;&#xA;                case 4:&#xA;                case 5:&#xA;                case 6:&#xA;                    old_judge=judge;&#xA;                    if(judge==3||judge==4) judge=5;&#xA;                    qz[x0][y0]=color1;&#xA;                    r2=goon(x,y,color2,color1,depth);&#xA;                    qz[x0][y0]=0;&#xA;                    judge=old_judge;&#xA;                    if(r2==1) break;&#xA;                    else return 1;&#xA;                default:&#xA;                    printf(&quot;error in keepgo()&quot;);&#xA;                    break;&#xA;                }&#xA;                mask=mask&gt;&gt;4;&#xA;            }&#xA;        }&#xA;    }&#xA;    return -1;&#xA;}&#xA;char goon(int x,int y,char color1,char color2,int depth)&#xA;{&#xA;    int i,dx,dy,k1,k2,rang1,rang2,temp;&#xA;    int nx,ny;&#xA;    char r1,r2;&#xA;    for(i=0; i&lt;4; i++)&#xA;    {&#xA;        k1=1;&#xA;        k2=1;&#xA;        switch(i)&#xA;        {&#xA;        case 0:&#xA;            dx=0;&#xA;            dy=1;&#xA;            rang1=(y&gt;4)?4:y;&#xA;            rang2=(14-y&gt;4)?4:14-y;&#xA;            break;&#xA;        case 1:&#xA;            dx=1;&#xA;            dy=1;&#xA;            rang1=(x&lt;y)?x:y;&#xA;            rang1=(rang1&gt;4)?4:rang1;&#xA;            rang2=(x&gt;y)?x:y;&#xA;            rang2=(14-rang2&gt;4)?4:14-rang2;&#xA;            break;&#xA;        case 2:&#xA;            dx=1;&#xA;            dy=0;&#xA;            rang1=(x&gt;4)?4:x;&#xA;            rang2=(14-x&gt;4)?4:14-x;&#xA;            break;&#xA;        case 3:&#xA;            dx=1;&#xA;            dy=-1;&#xA;            rang1=(x&lt;14-y)?x:14-y;&#xA;            rang1=(rang1&gt;4)?4:rang1;&#xA;            rang2=(14-x&lt;y)?14-x:y;&#xA;            rang2=(rang2&gt;4)?4:rang2;&#xA;            break;&#xA;        }&#xA;        while(k1&lt;=rang1)&#xA;        {&#xA;            nx=x-k1*dx;&#xA;            ny=y-k1*dy;&#xA;            temp=qz[nx][ny];&#xA;            k1++;&#xA;            if(temp==0)&#xA;            {&#xA;                r1=ifgook(nx,ny,color1,color2);&#xA;                switch(r1)&#xA;                {&#xA;                case -1:&#xA;                case 0:&#xA;                    break;&#xA;                case 1:&#xA;                    return 1;&#xA;                case 2:&#xA;                case 3:&#xA;                    if(judge!=3) break;&#xA;                    qz[nx][ny]=color1;&#xA;                    r2=keepgo(nx,ny,3,color2,color1,depth,Glist);&#xA;                    qz[nx][ny]=0;&#xA;                    if(r2==-1) return 1;&#xA;                    break;&#xA;                case 6:&#xA;                case 5:&#xA;                case 4:&#xA;                    if(judge==5) break;&#xA;                    qz[nx][ny]=color1;&#xA;                    r2=keepgo(nx,ny,4,color2,color1,depth,Glist);&#xA;                    qz[nx][ny]=0;&#xA;                    if(r2==-1) return 1;&#xA;                    break;&#xA;                }&#xA;            }&#xA;            if(temp==color2) break;&#xA;        }&#xA;&#xA;        while(k2&lt;=rang2)&#xA;        {&#xA;            nx=x+k2*dx;&#xA;            ny=y+k2*dy;&#xA;            temp=qz[nx][ny];&#xA;            k2++;&#xA;            if(temp==0)&#xA;            {&#xA;                r1=ifgook(nx,ny,color1,color2);&#xA;                switch(r1)&#xA;                {&#xA;                case -1:&#xA;                case 0:&#xA;                    break;&#xA;                case 1:&#xA;                    return 1;&#xA;                case 2:&#xA;                case 3:&#xA;                    if(judge!=3) break;&#xA;                    qz[nx][ny]=color1;&#xA;                    r2=keepgo(nx,ny,3,color2,color1,depth,Glist);&#xA;                    qz[nx][ny]=0;&#xA;                    if(r2==-1) return 1;&#xA;                    break;&#xA;                case 5:&#xA;                case 6:&#xA;                case 4:&#xA;                    if(judge==5) break;&#xA;                    qz[nx][ny]=color1;&#xA;                    r2=keepgo(nx,ny,4,color2,color1,depth,Glist);&#xA;                    qz[nx][ny]=0;&#xA;                    if(r2==-1) return 1;&#xA;                    break;&#xA;                }&#xA;            }&#xA;            if(temp==color2) break;&#xA;        }&#xA;    }&#xA;    return -1;&#xA;}&#xA;char computer_keep(int x,int y,int len)&#xA;{&#xA;    int dx,dy,x0,y0;&#xA;    int i,j,bx,by,mask,d,r1,r2;&#xA;    int temp;&#xA;    char old_judge;&#xA;    int max=-1,max_x,max_y;&#xA;    QCL list;&#xA;    attrib(x,y,&amp;list,player,computer);&#xA;    judge=3;&#xA;    for(i=0; i&lt;4; i++)&#xA;    {&#xA;        switch(i)&#xA;        {&#xA;        case 0:&#xA;            dx=0;&#xA;            dy=1;&#xA;            break;&#xA;        case 1:&#xA;            dx=1;&#xA;            dy=1;&#xA;            break;&#xA;        case 2:&#xA;            dx=1;&#xA;            dy=0;&#xA;            break;&#xA;        case 3:&#xA;            dx=1;&#xA;            dy=-1;&#xA;            break;&#xA;        }&#xA;        if(list.l[i]==len)&#xA;        {&#xA;            j=list.p[i];&#xA;            bx=x-dx*list.d[i];&#xA;            by=y-dy*list.d[i];&#xA;            mask=keep[j];&#xA;            while(mask!=0)&#xA;            {&#xA;                d=(mask&amp;0x000f)-1;&#xA;                x0=bx+d*dx;&#xA;                y0=by+d*dy;&#xA;                r1=ifgook(x0,y0,computer,player);&#xA;                switch(r1)&#xA;                {&#xA;                case -1:&#xA;                    break;&#xA;                case 0:&#xA;                    old_judge=judge;&#xA;                    judge=4;&#xA;                    qz[x0][y0]=computer;&#xA;                    r2=goon(x0,y0,computer,player,0);&#xA;                    if(r2==-1) judge=3;&#xA;                    r2=goon(x,y,player,computer,0);&#xA;                    qz[x0][y0]=0;&#xA;                    judge=old_judge;&#xA;                    if(r2==1) break;&#xA;                    r2=power(x0,y0,1);&#xA;                    if(max&lt;r2)&#xA;                    {&#xA;                        max=r2;&#xA;                        max_x=x0;&#xA;                        max_y=y0;&#xA;                    }&#xA;                    break;&#xA;                case 1:&#xA;                    drawcircle(x0,y0,computer);&#xA;                    return 1;&#xA;                case 2:&#xA;                case 3:&#xA;                    old_judge=judge;&#xA;                    judge=4;&#xA;                    qz[x0][y0]=computer;&#xA;                    r2=goon(x,y,player,computer,0);&#xA;                    qz[x0][y0]=0;&#xA;                    judge=old_judge;&#xA;                    if(r2==1) break;&#xA;                    drawcircle(x0,y0,computer);&#xA;                    return 1;&#xA;                case 4:&#xA;                case 5:&#xA;                case 6:&#xA;                    drawcircle(x0,y0,computer);&#xA;                    return 1;&#xA;                default:&#xA;                    printf(&quot;error in keepgo()&quot;);&#xA;                    break;&#xA;                }&#xA;                mask=mask&gt;&gt;4;&#xA;            }//end while&#xA;            if(max&gt;=0)&#xA;            {&#xA;                drawcircle(max_x,max_y,computer);&#xA;                return 1;&#xA;            }&#xA;            mask=keep[j];&#xA;            while(mask!=0)&#xA;            {&#xA;                d=(mask&amp;0x000f)-1;&#xA;                x0=bx+d*dx;&#xA;                y0=by+d*dy;&#xA;                r1=ifgook(x0,y0,computer,player);&#xA;                temp=power(x0,y0,player);&#xA;                if(temp&gt;max&amp;&amp;r1!=-1)&#xA;                {&#xA;                    max=temp;&#xA;                    max_x=x0;&#xA;                    max_y=y0;&#xA;                }&#xA;                mask=mask&gt;&gt;4;&#xA;            }&#xA;            if(max&gt;=0)&#xA;            {&#xA;                drawcircle(max_x,max_y,computer);&#xA;                return 1;&#xA;            }&#xA;        } //end if&#xA;    }  //end for&#xA;    return 0;&#xA;}&#xA;char many(int x,int y)&#xA;{&#xA;    int l,t,r,d;&#xA;    int num=0,id=0;&#xA;    l=(x-2&gt;0)?x-2:0;&#xA;    t=(y-2&gt;0)?y-2:0;&#xA;    r=(x+2&gt;14)?14:x+2;&#xA;    d=(y+2&gt;14)?14:y+2;&#xA;&#xA;    if(x-1&gt;=l&amp;&amp;y-1&gt;=t)&#xA;    {&#xA;        if(qz[x-1][y-1]==0)&#xA;        {&#xA;            num++;&#xA;            if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==0)  ;&#xA;            else if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==computer)  num++;&#xA;            else  num--;&#xA;        }&#xA;        else if(qz[x-1][y-1]==computer)&#xA;        {&#xA;            id=1;&#xA;            num+=2;&#xA;            if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==0)  num++;&#xA;            else if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==computer)  num+=2;&#xA;            else  num--;&#xA;        }&#xA;        else num-=2;&#xA;    }&#xA;    else num-=2;&#xA;&#xA;    if(y-1&gt;=t)&#xA;    {&#xA;        if(qz[x][y-1]==0)&#xA;        {&#xA;            num++;&#xA;            if(y-2&gt;=t&amp;&amp;qz[x][y-2]==0)  ;&#xA;            else if(y-2&gt;=t&amp;&amp;qz[x][y-2]==computer)  num++;&#xA;            else  num--;&#xA;        }&#xA;        else  if(qz[x][y-1]==computer)&#xA;        {&#xA;            id=1;&#xA;            num+=2;&#xA;            if(y-2&gt;=t&amp;&amp;qz[x][y-2]==0)  num++;&#xA;            else if(y-2&gt;=t&amp;&amp;qz[x][y-2]==computer)  num+=2;&#xA;            else  num--;&#xA;        }&#xA;        else num-=2;&#xA;    }&#xA;    else num-=2;&#xA;&#xA;    if(x+1&lt;=r&amp;&amp;y-1&gt;=t)&#xA;    {&#xA;        if(qz[x+1][y-1]==0)&#xA;        {&#xA;            num++;&#xA;            if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==0)  ;&#xA;            else if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==computer)  num++;&#xA;            else  num--;&#xA;        }&#xA;        else if(qz[x+1][y-1]==computer)&#xA;        {&#xA;            id=1;&#xA;            num+=2;&#xA;            if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==0)  num++;&#xA;            else  if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==computer)  num+=2;&#xA;            else  num--;&#xA;&#xA;        }&#xA;        else num-=2;&#xA;    }&#xA;    else num-=2;&#xA;&#xA;    if(x-1&gt;=l)&#xA;    {&#xA;        if(qz[x-1][y]==0)&#xA;        {&#xA;            num++;&#xA;            if(x-2&gt;=l&amp;&amp;qz[x-2][y]==0)  ;&#xA;            else if(x-2&gt;=l&amp;&amp;qz[x-2][y]==computer)  num++;&#xA;            else  num--;&#xA;        }&#xA;        else  if(qz[x-1][y]==computer)&#xA;        {&#xA;            id=1;&#xA;            num+=2;&#xA;            if(x-2&gt;=l&amp;&amp;qz[x-2][y]==0)  num++;&#xA;            else if(x-2&gt;=l&amp;&amp;qz[x-2][y]==computer)  num+=2;&#xA;            else  num--;&#xA;        }&#xA;        else num-=2;&#xA;    }&#xA;    else num-=2;&#xA;&#xA;    if(x-1&gt;=l&amp;&amp;y+1&lt;=d)&#xA;    {&#xA;        if(qz[x-1][y+1]==0)&#xA;        {&#xA;            num++;&#xA;            if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==0)  ;&#xA;            else if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==computer)  num++;&#xA;            else  num--;&#xA;        }&#xA;        else  if(qz[x-1][y+1]==computer)&#xA;        {&#xA;            id=1;&#xA;            num+=2;&#xA;            if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==0)  num++;&#xA;            else if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==computer)  num+=2;&#xA;            else  num--;&#xA;        }&#xA;        else num-=2;&#xA;    }&#xA;    else num-=2;&#xA;&#xA;    if(y+1&lt;=d)&#xA;    {&#xA;        if(qz[x][y+1]==0)&#xA;        {&#xA;            num++;&#xA;            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  ;&#xA;            else if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  num++;&#xA;            else  num--;&#xA;        }&#xA;        else  if(qz[x][y+1]==computer)&#xA;        {&#xA;            id=1;&#xA;            num+=2;&#xA;            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  num++;&#xA;            else if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  num+=2;&#xA;            else  num--;&#xA;&#xA;        }&#xA;        else num-=2;&#xA;    }&#xA;    else num-=2;&#xA;&#xA;    if(x+1&lt;=r&amp;&amp;y+1&lt;=d)&#xA;    {&#xA;        if(qz[x+1][y+1]==0)&#xA;        {&#xA;            num++;&#xA;            if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==0)  ;&#xA;            else if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==computer)  num++;&#xA;            else  num--;&#xA;        }&#xA;        else  if(qz[x+1][y+1]==computer)&#xA;        {&#xA;            id=1;&#xA;            num+=2;&#xA;            if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==0)  num++;&#xA;            else if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==computer)  num+=2;&#xA;            else  num--;&#xA;        }&#xA;        else num-=2;&#xA;    }&#xA;    else num-=2;&#xA;&#xA;    if(x+1&lt;=r)&#xA;    {&#xA;        if(qz[x+1][y]==0)&#xA;        {&#xA;            num++;&#xA;            if(x+2&lt;=r&amp;&amp;qz[x+2][y]==0)  ;&#xA;            else if(x+2&lt;=r&amp;&amp;qz[x+2][y]==computer)  num++;&#xA;            else  num--;&#xA;        }&#xA;        else   if(qz[x+1][y]==computer)&#xA;        {&#xA;            id=1;&#xA;            num+=2;&#xA;            if(x+2&lt;=r&amp;&amp;qz[x+2][y]==0)  num++;&#xA;            else if(x+2&lt;=r&amp;&amp;qz[x+2][y]==computer)  num+=2;&#xA;            else  num--;&#xA;        }&#xA;        else num-=2;&#xA;    }&#xA;    else num-=2;&#xA;&#xA;    if (id==1) return num;&#xA;    else return -1;&#xA;}&#xA;char power(int x,int y,char color)&#xA;{&#xA;    int l,t,r,d,num;&#xA;    l=(x-2&gt;0)?x-2:0;&#xA;    t=(y-2&gt;0)?y-2:0;&#xA;    r=(x+2&gt;14)?14:x+2;&#xA;    d=(y+2&gt;14)?14:y+2;&#xA;&#xA;    num=0;&#xA;    if(x-1&gt;=l&amp;&amp;y-1&gt;=t)&#xA;        if(qz[x-1][y-1]==color)&#xA;        {&#xA;            num+=2;&#xA;            if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==color)  num+=2;&#xA;            else if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==0)  num++;&#xA;            else  num--;&#xA;        }&#xA;        else if(qz[x-1][y-1]==0)&#xA;        {&#xA;            num++;&#xA;            if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==color)  num++;&#xA;            else if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==0)  ;&#xA;            else num--;&#xA;        }&#xA;    //else num--;&#xA;&#xA;    if(y-1&gt;=t)&#xA;        if(qz[x][y-1]==color)&#xA;        {&#xA;            num+=2;&#xA;            if(y-2&gt;=t&amp;&amp;qz[x][y-2]==color)  num+=2;&#xA;            else if(y-2&gt;=t&amp;&amp;qz[x][y-2]==0)  num++;&#xA;            else num--;&#xA;        }&#xA;        else if(qz[x][y-1]==0)&#xA;        {&#xA;            num++;&#xA;            if(y-2&gt;=t&amp;&amp;qz[x][y-2]==color)  num++;&#xA;            else if(y-2&gt;=t&amp;&amp;qz[x][y-2]==0) ;&#xA;            else num--;&#xA;        }&#xA;    //else num--;&#xA;&#xA;    if(x+1&lt;=r&amp;&amp;y-1&gt;=t)&#xA;        if(qz[x+1][y-1]==color)&#xA;        {&#xA;            num+=2;&#xA;            if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==color)  num+=2;&#xA;            else if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==0)  num++;&#xA;            else num--;&#xA;        }&#xA;        else if(qz[x+1][y-1]==0)&#xA;        {&#xA;            num++;&#xA;            if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==color)  num++;&#xA;            else if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==0)  ;&#xA;            else num--;&#xA;        }&#xA;    //else num--;&#xA;&#xA;    if(x-1&gt;=l)&#xA;        if(qz[x-1][y]==color)&#xA;        {&#xA;            num+=2;&#xA;            if(x-2&gt;=l&amp;&amp;qz[x-2][y]==color)  num+=2;&#xA;            else if(x-2&gt;=l&amp;&amp;qz[x-2][y]==0)  num++;&#xA;            else num--;&#xA;        }&#xA;        else if(qz[x-1][y]==0)&#xA;        {&#xA;            num++;&#xA;            if(x-2&gt;=l&amp;&amp;qz[x-2][y]==color)  num++;&#xA;            else if(x-2&gt;=l&amp;&amp;qz[x-2][y]==0) ;&#xA;            else  num--;&#xA;        }&#xA;    //else num--;&#xA;&#xA;    if(x-1&gt;=l&amp;&amp;y+1&lt;=d)&#xA;        if(qz[x-1][y+1]==color)&#xA;        {&#xA;            num+=2;&#xA;            if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==color)  num+=2;&#xA;            else if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==0)  num++;&#xA;            else num--;&#xA;        }&#xA;        else if(qz[x-1][y+1]==0)&#xA;        {&#xA;            num++;&#xA;            if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==color)  num++;&#xA;            else if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==0)  ;&#xA;            else num--;&#xA;        }&#xA;    //else num--;&#xA;&#xA;    if(y+1&lt;=d)&#xA;        if(qz[x][y+1]==color)&#xA;        {&#xA;            num+=2;&#xA;            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==color)  num+=2;&#xA;            else if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  num++;&#xA;            else num--;&#xA;        }&#xA;        else if(qz[x][y+1]==0)&#xA;        {&#xA;            num++;&#xA;            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==color)  num++;&#xA;            else if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  ;&#xA;            else num--;&#xA;        }&#xA;    //else num--;&#xA;&#xA;    if(x+1&lt;=r&amp;&amp;y+1&lt;=d)&#xA;        if(qz[x+1][y+1]==color)&#xA;        {&#xA;            num+=2;&#xA;            if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==color)  num+=2;&#xA;            else if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==0)  num++;&#xA;            else num--;&#xA;        }&#xA;        else  if(qz[x+1][y+1]==0)&#xA;        {&#xA;            num++;&#xA;            if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==color)  num++;&#xA;            else if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==0)  ;&#xA;            else num--;&#xA;        }&#xA;    //else num--;&#xA;&#xA;    if(x+1&lt;=r)&#xA;        if(qz[x+1][y]==color)&#xA;        {&#xA;            num+=2;&#xA;            if(x+2&lt;=r&amp;&amp;qz[x+2][y]==color)  num+=2;&#xA;            else if(x+2&lt;=r&amp;&amp;qz[x+2][y]==0)  num++;&#xA;            else num--;&#xA;        }&#xA;        else if(qz[x+1][y]==0)&#xA;        {&#xA;            num++;&#xA;            if(x+2&lt;=r&amp;&amp;qz[x+2][y]==color)  num++;&#xA;            else if(x+2&lt;=r&amp;&amp;qz[x+2][y]==0)  ;&#xA;            else num--;&#xA;        }&#xA;    //else num--;&#xA;    return num;&#xA;}&#xA;&#xA;///////////////////////five.c////////////////////////////////////////&#xA;char lose[4]= {27,12,35,47};&#xA;char lose2[6]= {41,42,27,12,35,47};&#xA;char win[4]= {27,34,35,47};&#xA;char str1[6]= {27,28,32,33,31,48};&#xA;char gamego[8]= {27,28,37,43,44,45,31,48};&#xA;extern unsigned int step;&#xA;void p(void)&#xA;{&#xA;    int i,j;&#xA;    for(i=0; i&lt;15; i++)&#xA;    {&#xA;&#xA;        for(j=0; j&lt;15; j++)&#xA;            printf(&quot;%d&quot;,qz[j][i]);&#xA;    }&#xA;}&#xA;&#xA;&#xA;void init(void)&#xA;{&#xA;    drawline();&#xA;    old_x=7;&#xA;    old_y=7;&#xA;    setbit(7,7);&#xA;}&#xA;void drawline()&#xA;{&#xA;    int j;&#xA;    char str[2];&#xA;    char string[3];&#xA;&#xA;    setfillstyle(1,14);&#xA;&#xA;    setcolor(9);&#xA;    str[1]='\0';&#xA;    string[2]='\0';&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    SetTextColor(dc,0xff00);&#xA;    SetBkColor(dc,0);&#xA;    for(j=0; j&lt;15; j++)&#xA;    {&#xA;        line(X0+SIZE*(j),Y0,X0+SIZE*(j),Y0+SIZE*14);&#xA;        line(X0,Y0+SIZE*(j),X0+SIZE*14,Y0+SIZE*(j));&#xA;        if(j&gt;=9)&#xA;        {&#xA;            string[0]='1';&#xA;            string[1]='0'+j-9;&#xA;        }&#xA;        else&#xA;        {&#xA;            string[0]='1'+j;&#xA;            string[1]='\0';&#xA;        }&#xA;&#xA;        outtextxy(X0-16,Y0+SIZE*j-7,string);&#xA;        str[0]='A'+j;&#xA;        outtextxy(X0+SIZE*j-3,Y0-15,str);&#xA;    }&#xA;}&#xA;char getkey()&#xA;{&#xA;    int key,ok=0;&#xA;    int  f,oldx,oldy;&#xA;    int can1,can2;&#xA;    while(1)&#xA;    {&#xA;        if(needclose)&#xA;        {&#xA;            printf(&quot;exit getkey&quot;);&#xA;            return 0;&#xA;        }&#xA;        Wait(1);&#xA;        if(bioskey(1)==1)&#xA;        {&#xA;            key=bioskey(0);&#xA;            if(key!=ENTER)&#xA;            {&#xA;                switch(key)&#xA;                {&#xA;                case LEFT:&#xA;&#xA;                    printf(&quot;left0 kx:%d,ky:%d&quot;,kx,ky);&#xA;                    kx=(kx==0)?0:--kx;&#xA;                    printf(&quot;left1 kx:%d,ky:%d&quot;,kx,ky);&#xA;                    setbit(kx,ky);&#xA;                    break; /*left*/&#xA;                case RIGHT:&#xA;                    kx=(kx==14)?14:++kx;&#xA;                    setbit(kx,ky);&#xA;                    break; /*right*/&#xA;                case UP:&#xA;                    ky=(ky==0)?0:--ky;&#xA;                    setbit(kx,ky);&#xA;                    break; /*up*/&#xA;                case DOWN:&#xA;                    ky=(ky==14)?14:++ky;&#xA;                    setbit(kx,ky);;&#xA;                    break; /*down*/&#xA;                case ESC:&#xA;                    return 0x10;&#xA;                    break;&#xA;                case 'r':&#xA;                case 'R':&#xA;                    return 0x11;&#xA;                default:&#xA;                    break;&#xA;                }&#xA;            }&#xA;            else  ok=1;&#xA;        }&#xA;        if(oldx!=kx||oldy!=ky)&#xA;        {&#xA;            oldx=kx;&#xA;            oldy=ky;&#xA;        }&#xA;        /**/&#xA;&#xA;        if((mx&gt;X0-SIZE/2)&amp;&amp;(my&gt;Y0-SIZE/2))&#xA;            if((mx&lt;X0+SIZE*14.5)&amp;&amp;(my&lt;Y0+SIZE*14.5))&#xA;            {&#xA;                printf(&quot;check mouse down,x:%d,y:%d&quot;,mx,my);&#xA;                //readmouse(&amp;f,&amp;mx,&amp;my);&#xA;                can1=(mx-X0)%SIZE;&#xA;                can2=(my-Y0)%SIZE;&#xA;                if(can1&lt;=(SIZE/2)) kx=(mx-X0)/SIZE;&#xA;                else kx=(mx-X0)/SIZE+1;&#xA;                if(can2&lt;=(SIZE/2)) ky=(my-Y0)/SIZE;&#xA;                else ky=(my-Y0)/SIZE+1;&#xA;                mx=0;&#xA;                my=0;&#xA;                f=1;&#xA;            }&#xA;&#xA;        if(f==1)  ok=1;&#xA;        if(ok==1)&#xA;        {&#xA;            char result;&#xA;            result=ifgook(kx,ky,player,computer);&#xA;            player_x=kx;&#xA;            player_y=ky;&#xA;            if(qz[kx][ky]==0)&#xA;            {&#xA;                drawcircle(kx,ky,player);&#xA;                return result;&#xA;            }&#xA;            if(qz[kx][ky]==0&amp;&amp;result==-1) return result;&#xA;            ok=0;&#xA;        }&#xA;    }&#xA;}&#xA;void drawcircle(int x,int y,char color)&#xA;{&#xA;    int i;&#xA;    int l,r,d,t;&#xA;    qz[x][y]=color;&#xA;    color--;&#xA;    active[x][y][0]=0;&#xA;    active[x][y][1]=0;&#xA;&#xA;    l=(x-2&gt;0)?x-2:0;&#xA;    t=(y-2&gt;0)?y-2:0;&#xA;    r=(x+2&gt;14)?14:x+2;&#xA;    d=(y+2&gt;14)?14:y+2;&#xA;&#xA;&#xA;    if(x-1&gt;=l&amp;&amp;y-1&gt;=t)&#xA;        if(qz[x-1][y-1]==0)&#xA;        {&#xA;            active[x-1][y-1][color]=1;&#xA;            if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==0)  active[x-2][y-2][color]=1;&#xA;        }&#xA;&#xA;    if(y-1&gt;=t)&#xA;        if(qz[x][y-1]==0)&#xA;        {&#xA;            active[x][y-1][color]=1;&#xA;            if(y-2&gt;=t&amp;&amp;qz[x][y-2]==0)  active[x][y-2][color]=1;&#xA;        }&#xA;&#xA;    if(x+1&lt;=r&amp;&amp;y-1&gt;=t)&#xA;        if(qz[x+1][y-1]==0)&#xA;        {&#xA;            active[x+1][y-1][color]=1;&#xA;            if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==0)  active[x+2][y-2][color]=1;&#xA;        }&#xA;&#xA;    if(x-1&gt;=l)&#xA;        if(qz[x-1][y]==0)&#xA;        {&#xA;            active[x-1][y][color]=1;&#xA;            if(x-2&gt;=l&amp;&amp;qz[x-2][y]==0)  active[x-2][y][color]=1;&#xA;        }&#xA;&#xA;    if(x-1&gt;=l&amp;&amp;y+1&lt;=d)&#xA;        if(qz[x-1][y+1]==0)&#xA;        {&#xA;            active[x-1][y+1][color]=1;&#xA;            if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==0)  active[x-2][y+2][color]=1;&#xA;        }&#xA;&#xA;    if(y+1&lt;=d)&#xA;        if(qz[x][y+1]==0)&#xA;        {&#xA;            active[x][y+1][color]=1;&#xA;            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  active[x][y+2][color]=1;&#xA;        }&#xA;&#xA;    if(x+1&lt;=r&amp;&amp;y+1&lt;=d)&#xA;        if(qz[x+1][y+1]==0)&#xA;        {&#xA;            active[x+1][y+1][color]=1;&#xA;            if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==0)  active[x+2][y+2][color]=1;&#xA;        }&#xA;&#xA;    if(x+1&lt;=r)&#xA;        if(qz[x+1][y]==0)&#xA;        {&#xA;            active[x+1][y][color]=1;&#xA;            if(x+2&lt;=r&amp;&amp;qz[x+2][y]==0)  active[x+2][y][color]=1;&#xA;        }&#xA;&#xA;    if(y+1&lt;=d)&#xA;        if(qz[x][y+1]==0)&#xA;        {&#xA;            active[x][y+1][color]=1;&#xA;            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  active[x][y+2][color]=1;&#xA;        }&#xA;&#xA;    if(l&lt;left)  left=l;&#xA;    if(r&gt;right) right=r;&#xA;    if(t&lt;top)   top=t;&#xA;    if(d&gt;down)  down=d;&#xA;&#xA;    drawcross(old_x,old_y);&#xA;    color=(color==0)?0:15;&#xA;    setcolor(0);&#xA;    setfillstyle(1,color);&#xA;    circle(X0+SIZE*x,Y0+SIZE*y,Radius);&#xA;&#xA;    setcolor(color^0xff);&#xA;&#xA;&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;&#xA;    HBRUSH brush;&#xA;    if(color==0)&#xA;    {&#xA;        setcolor(16);&#xA;        brush=CreateSolidBrush(0xffff);&#xA;    }&#xA;    else&#xA;    {&#xA;        setcolor(10);&#xA;        brush=CreateSolidBrush(0xffff00);&#xA;    }&#xA;    SelectObject(dc,brush);&#xA;    ellipse(X0+SIZE*x,Y0+SIZE*y,90+(1-color)*180,180+(1-color)*180,Radius-2,Radius-2);&#xA;    DeleteObject( brush);&#xA;&#xA;    drawcross(x,y);&#xA;&#xA;    old_x=x;&#xA;    old_y=y;&#xA;    setbit(x,y);&#xA;&#xA;}&#xA;void drawcross(int x,int y)&#xA;{&#xA;&#xA;    setcolor(2);&#xA;    line(X0+SIZE*x-6,Y0+SIZE*y,X0+SIZE*x+6,Y0+SIZE*y);&#xA;    line(X0+SIZE*x,Y0+SIZE*y-6,X0+SIZE*x,Y0+SIZE*y+6);&#xA;&#xA;}&#xA;&#xA;void setbit(int x,int y)&#xA;{&#xA;    int mx,my;&#xA;    mx=X0+SIZE*x;&#xA;    my=Y0+SIZE*y;&#xA;    printf(&quot;setbit,x:%d,y:%d&quot;,x,y);&#xA;    setmousecoord(mx,my);&#xA;}&#xA;&#xA;&#xA;unsigned condition[2][11]=&#xA;{&#xA;    {&#xA;        0x0054,&#xA;        0x0150,&#xA;        0x0144,&#xA;        0x0114,&#xA;        0x0555,&#xA;        0x0154,&#xA;        0x0151,&#xA;        0x0145,&#xA;        0x0115,&#xA;        0x0055,&#xA;        0x0155&#xA;    },&#xA;    {&#xA;        0x00a8,&#xA;        0x02a0,&#xA;        0x0288,&#xA;        0x0228,&#xA;        0x0aaa,&#xA;        0x02a8,&#xA;        0x02a2,&#xA;        0x028a,&#xA;        0x022a,&#xA;        0x00aa,&#xA;        0x02aa&#xA;    }&#xA;};&#xA;&#xA;int compare(unsigned input,int len,char color);&#xA;void attrib(int x,int y,QCL *pl,char color1,char color2)&#xA;{&#xA;    int h,i,j,dx,dy,k1,k2,k,num,rang1,rang2;&#xA;    register int temp;&#xA;    pl-&gt;p[0]=-1;&#xA;    pl-&gt;p[1]=-1;&#xA;    pl-&gt;p[2]=-1;&#xA;    pl-&gt;p[3]=-1;&#xA;    pl-&gt;l[0]=0;&#xA;    pl-&gt;l[1]=0;&#xA;    pl-&gt;l[2]=0;&#xA;    pl-&gt;l[3]=0;&#xA;&#xA;    for(i=0; i&lt;4; i++)&#xA;    {&#xA;        k1=1;&#xA;        k2=1;&#xA;        num=1;&#xA;        switch(i)&#xA;        {&#xA;        case 0:&#xA;            dx=0;&#xA;            dy=1;&#xA;            rang1=(y&gt;4)?4:y;&#xA;            rang2=(14-y&gt;4)?4:14-y;&#xA;            break;&#xA;        case 1:&#xA;            dx=1;&#xA;            dy=1;&#xA;            rang1=(x&lt;y)?x:y;&#xA;            rang1=(rang1&gt;4)?4:rang1;&#xA;            rang2=(x&gt;y)?x:y;&#xA;            rang2=(14-rang2&gt;4)?4:14-rang2;&#xA;            break;&#xA;        case 2:&#xA;            dx=1;&#xA;            dy=0;&#xA;            rang1=(x&gt;4)?4:x;&#xA;            rang2=(14-x&gt;4)?4:14-x;&#xA;            break;&#xA;        case 3:&#xA;            dx=1;&#xA;            dy=-1;&#xA;            rang1=(x&lt;14-y)?x:14-y;&#xA;            rang1=(rang1&gt;4)?4:rang1;&#xA;            rang2=(14-x&lt;y)?14-x:y;&#xA;            rang2=(rang2&gt;4)?4:rang2;&#xA;            break;&#xA;        }&#xA;        while(k1&lt;=rang1)&#xA;        {&#xA;            temp=qz[x-k1*dx][y-k1*dy];&#xA;            if(temp==0&amp;&amp;k1+1&lt;=rang1&amp;&amp;qz[x-(k1+1)*dx][y-(k1+1)*dy]==0)&#xA;            {&#xA;                k1+=2;&#xA;                break;&#xA;            }&#xA;            k1++;&#xA;            if(temp==color2) break;&#xA;            if(temp==color1) num++;&#xA;        }&#xA;        k1--;&#xA;&#xA;        while(k2&lt;=rang2)&#xA;        {&#xA;            temp=qz[x+k2*dx][y+k2*dy];&#xA;            if(temp==0&amp;&amp;k2+1&lt;=rang2&amp;&amp;qz[x+(k2+1)*dx][y+(k2+1)*dy]==0)&#xA;            {&#xA;                k2+=2;&#xA;                break;&#xA;            }&#xA;            k2++;&#xA;            if(temp==color2) break;&#xA;            if(temp==color1) num++;&#xA;        }&#xA;&#xA;        k=k1+k2;&#xA;        if(k&gt;4)&#xA;        {&#xA;            int m,n,back;&#xA;            unsigned swap=0,swap1;&#xA;            for(m=0; m&lt;5; m++)&#xA;                swap=swap|(qz[x-(k1-m)*dx][y-(k1-m)*dy]&lt;&lt;(m&lt;&lt;1));&#xA;            swap1=swap;&#xA;            switch(num)&#xA;            {&#xA;            case 3:&#xA;                if(k&gt;5)&#xA;                {&#xA;                    for(n=m; n&lt;k; n++)&#xA;                    {&#xA;                        swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;10);&#xA;                        back=compare(swap1,6,color1);&#xA;                        if(back&gt;=0)&#xA;                        {&#xA;                            pl-&gt;p[i]=back;&#xA;                            pl-&gt;l[i]=3;&#xA;                            pl-&gt;d[i]=k1-(n-m);&#xA;                            break;&#xA;                        }&#xA;                        swap1=swap1&gt;&gt;2;&#xA;                    }&#xA;                }&#xA;                if(pl-&gt;p[i]&gt;=0) continue;&#xA;                break;&#xA;            case 4:&#xA;                for(n=m-1; n&lt;k; n++)&#xA;                {&#xA;                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;8);&#xA;                    back=compare(swap1,5,color1);&#xA;                    if(back&gt;=0)&#xA;                    {&#xA;                        pl-&gt;p[i]=back;&#xA;                        pl-&gt;l[i]=4;&#xA;                        pl-&gt;d[i]=k1-(n-m)-1;&#xA;                        break;&#xA;                    }&#xA;                    swap1=swap1&gt;&gt;2;&#xA;                }&#xA;                if(pl-&gt;p[i]&gt;=0) continue;&#xA;                break;&#xA;            case 5:&#xA;                for(n=m-1; n&lt;k; n++)&#xA;                {&#xA;                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;8);&#xA;                    if(swap1==condition[color1-1][10])&#xA;                    {&#xA;                        pl-&gt;p[i]=10;&#xA;                        pl-&gt;l[i]=5;&#xA;                        pl-&gt;d[i]=k1-(n-m)-1;&#xA;                        break;&#xA;                    }&#xA;                    swap1=swap1&gt;&gt;2;&#xA;                }&#xA;                if(pl-&gt;p[i]&gt;=0) continue;&#xA;                break;&#xA;            case 7:&#xA;            case 8:&#xA;            case 9:&#xA;            case 6:&#xA;                for(n=m; n&lt;k; n++)&#xA;                {&#xA;                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;10);&#xA;                    if(swap1==condition[color1-1][4])&#xA;                    {&#xA;                        pl-&gt;p[i]=4;&#xA;                        pl-&gt;l[i]=6;&#xA;                        pl-&gt;d[i]=k1-(n-m);&#xA;                        break;&#xA;                    }&#xA;                    swap1=swap1&gt;&gt;2;&#xA;                }&#xA;                if(pl-&gt;p[i]&gt;=0) continue;&#xA;&#xA;                swap1=swap;&#xA;                for(n=m-1; n&lt;k; n++)&#xA;                {&#xA;                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;8);&#xA;                    if(swap1==condition[color1-1][10])&#xA;                    {&#xA;                        pl-&gt;p[i]=10;&#xA;                        pl-&gt;l[i]=5;&#xA;                        pl-&gt;d[i]=k1-(n-m)-1;&#xA;                        break;&#xA;                    }&#xA;                    swap1=swap1&gt;&gt;2;&#xA;                }&#xA;                if(pl-&gt;p[i]&gt;=0) continue;&#xA;&#xA;                for(n=m-1; n&lt;k; n++)&#xA;                {&#xA;                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;8);&#xA;                    back=compare(swap1,5,color1);&#xA;                    if(back&gt;=0)&#xA;                    {&#xA;                        pl-&gt;p[i]=back;&#xA;                        pl-&gt;l[i]=4;&#xA;                        pl-&gt;d[i]=k1-(n-m)-1;&#xA;                        break;&#xA;                    }&#xA;                    swap1=swap1&gt;&gt;2;&#xA;                }&#xA;                if(pl-&gt;p[i]&gt;=0) continue;&#xA;&#xA;                swap1=swap;&#xA;                for(n=m; n&lt;k; n++)&#xA;                {&#xA;                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;10);&#xA;                    back=compare(swap1,6,color1);&#xA;                    if(back&gt;=0)&#xA;                    {&#xA;                        pl-&gt;p[i]=back;&#xA;                        pl-&gt;l[i]=3;&#xA;                        pl-&gt;d[i]=k1-(n-m);&#xA;                        break;&#xA;                    }&#xA;                    swap1=swap1&gt;&gt;2;&#xA;                }&#xA;                if(pl-&gt;p[i]&gt;=0) continue;&#xA;                break;&#xA;            default:&#xA;                break;&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;int compare(unsigned input,int len,char color)&#xA;{&#xA;    int i;&#xA;    color--;&#xA;    switch(len)&#xA;    {&#xA;    case 5:&#xA;        for(i=5; i&lt;10; i++)&#xA;            if(input==condition[color][i]) return i;&#xA;        return -1;&#xA;    case 6:&#xA;        for(i=0; i&lt;4; i++)&#xA;            if(input==condition[color][i]) return i;&#xA;        return -1;&#xA;    default:&#xA;        printf(&quot;error len in compare\n&quot;);&#xA;        break;&#xA;    }&#xA;}&#xA;/////////////////////////////////////////////////////////////&#xA;void OnMouseDown(int id,int btn,int state,int x,int y)&#xA;{&#xA;&#xA;    mx=x;&#xA;    my=y;&#xA;    printf(&quot;mouse down,x:%d,y:%d&quot;,mx,my);&#xA;}&#xA;void OnClose()&#xA;{&#xA;    printf(&quot;need close...&quot;);&#xA;    needclose=1;&#xA;    Wait(1);&#xA;    HideVclWin();&#xA;    &#xA;    CloseVclWin();&#xA;&#xA;}&#xA;void InitGraph()&#xA;{&#xA;    HideLeftTools();&#xA;    ClearVclControls();&#xA;    ShowVclWin(180);&#xA;    //HideVclWin(200);&#xA;    pfm=GetGuiWin(1);&#xA;    //pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;五子棋&quot;,&quot;Width&quot;,430,&quot;height&quot;,480,&quot;BorderIcons&quot;,&quot;[]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnKeyDown&quot;,OnKeyDown,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]&#xA;    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,160,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);&#xA;    img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,400,&quot;height&quot;,380,&quot;OnMouseDown&quot;,OnMouseDown,0);&#xA;    SetProperty(pfm,&quot;visible&quot;,1);&#xA;    RECT rect= {0,0,640,480};&#xA;    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;    HBRUSH brush=CreateSolidBrush(0x0000);&#xA;    SelectObject(dc,brush);&#xA;    FillRect(dc,&amp;rect,brush);&#xA;    DeleteObject(brush);&#xA;}&#xA;void main(void)&#xA;{&#xA;    int i;&#xA;    char who,END=0;&#xA;    int result,temp;&#xA;    InitGraph();&#xA;&#xA;&#xA;    while(!END)&#xA;    {&#xA;        SetProperty(pfm,&quot;caption&quot;,&quot;五子棋&quot;);&#xA;        if(needclose)&#xA;        {&#xA;            //ClearVclControls();;&#xA;            return;&#xA;        }&#xA;        who=1;&#xA;&#xA;        reset();&#xA;        printf(&quot;game init...............&quot;);&#xA;        RECT rect= {0,0,640,480};&#xA;        dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);&#xA;        HBRUSH brush=CreateSolidBrush(0x0000);&#xA;        SelectObject(dc,brush);&#xA;        FillRect(dc,&amp;rect,brush);&#xA;        DeleteObject(brush);&#xA;&#xA;        game_init();&#xA;        Invalidate(img);&#xA;        if(MessageBox(GetFormHandle(pfm),&quot;你想先手吗？&quot;,&quot;开始下棋&quot;,4)==6 )&#xA;            player=2;&#xA;        else&#xA;            player=1;&#xA;&#xA;        mx=0;&#xA;        my=0;&#xA;        computer=(player==1)?2:1;&#xA;        step=0;&#xA;        //drawcircle(7,7,1);&#xA;&#xA;        SetProperty(pfm,&quot;caption&quot;,&quot;五子棋-轮到您走棋&quot;);&#xA;&#xA;        temp=0;&#xA;        result=0;&#xA;&#xA;        while(1)&#xA;        {&#xA;            set(who+1);&#xA;&#xA;            if(who==player-1)&#xA;            {&#xA;                printf(&quot;player go&quot;);&#xA;                SetProperty(pfm,&quot;caption&quot;,&quot;五子棋-轮到您走棋&quot;);&#xA;                temp=player_go();&#xA;            }&#xA;            else&#xA;            {&#xA;                printf(&quot;computer go&quot;);&#xA;                SetProperty(pfm,&quot;caption&quot;,&quot;五子棋-轮到计算机走棋&quot;);&#xA;                result=computer_go(temp);&#xA;            }&#xA;            if(needclose)&#xA;            {&#xA;                printf(&quot;exit go&quot;);&#xA;&#xA;                return;&#xA;            }&#xA;            printf(&quot;temp:%d,result:%d&quot;,temp,result);&#xA;&#xA;            if(temp==1||result==-1)&#xA;            {&#xA;                set(0);&#xA;&#xA;                MessageBox(GetFormHandle(pfm),&quot;未知!          &quot;,&quot;本局结束&quot;,0);&#xA;                if(needclose) return;&#xA;&#xA;                mx=0;&#xA;                my=0;&#xA;                break;&#xA;            }&#xA;            if(temp==-1)&#xA;            {&#xA;                set(0);&#xA;&#xA;                MessageBox(GetFormHandle(pfm),&quot;您赢了!          &quot;,&quot;本局结束&quot;,0);&#xA;                if(needclose) return;&#xA;&#xA;                mx=0;&#xA;                my=0;&#xA;                break;&#xA;            }&#xA;            if(result==1)&#xA;            {&#xA;                printf(&quot;result==1&quot;);&#xA;                set(0);&#xA;&#xA;                MessageBox(GetFormHandle(pfm),&quot;计算机赢了!         &quot;,&quot;本局结束&quot;,0);&#xA;                if(needclose) return;&#xA;&#xA;                mx=0;&#xA;                my=0;&#xA;                break;&#xA;            }&#xA;            if(temp==0x10)&#xA;            {&#xA;                END=1;&#xA;                break;&#xA;            }&#xA;            if(temp==0x11) break;&#xA;            who^=1;&#xA;        }&#xA;    }&#xA;&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;"/>
    </Command>
    <Command cmdname="协议组态工具unuseful" cmdType="P" cmd="[P]new command">
      <Command cmdname="数据分析/构造器" cmdType="S" cmd="[S]数据分析器数据">
        <Command cmdname="起始符1-0x55" cmdType="S" cmd="[S]0x55">
          <Command cmdname="数据名称" cmdType="S" cmd="[S]Start_0"/>
          <Command cmdname="存在方式" cmdType="S" cmd="[S]必选\可选\程序"/>
          <Command cmdname="是否转义" cmdType="S" cmd="[S]是/否"/>
          <Command cmdname="转义字符" cmdType="S" cmd="[S]/"/>
          <Command cmdname="全局合法性" cmdType="S" cmd="[S]是/否">
            <Command cmdname="长度合法" cmdType="S" cmd="[S]是/否"/>
            <Command cmdname="内容合法" cmdType="S" cmd="[S]是/否"/>
          </Command>
          <Command cmdname="长度" cmdType="S" cmd="[S]固定长度[1byte]- 变长[prg] 进行选择">
            <Command cmdname="长度方式" cmdType="S" cmd="[S]固定\程序\止于结束符"/>
            <Command cmdname="长度数值" cmdType="S" cmd="[S]1"/>
            <Command cmdname="动态长度" cmdType="S" cmd="[S]GetLength(&quot;Start_0&quot;)"/>
            <Command cmdname="结束符" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="是否包含结束符" cmdType="S" cmd="[S]是/否"/>
          </Command>
          <Command cmdname="内容" cmdType="S" cmd="[S]0x55">
            <Command cmdname="内容方式" cmdType="S" cmd="[S]固定/程序/列表"/>
            <Command cmdname="固定内容" cmdType="S" cmd="[S]0x55"/>
            <Command cmdname="程序判断" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="列表匹配" cmdType="S" cmd="[S]new command">
              <Command cmdname="匹配表格名称" cmdType="S" cmd="[S]new command"/>
              <Command cmdname="匹配方式" cmdType="S" cmd="[S]new command">
                <Command cmdname="(" cmdType="S" cmd="[S]左括号"/>
                <Command cmdname="主键1" cmdType="S" cmd="[S]new command"/>
                <Command cmdname="或" cmdType="S" cmd="[S]或关系"/>
                <Command cmdname="主键2" cmdType="S" cmd="[S]new command"/>
                <Command cmdname=")" cmdType="S" cmd="[S]new command"/>
                <Command cmdname="主键3" cmdType="S" cmd="[S]new command"/>
                <Command cmdname="程序匹配" cmdType="S" cmd="[S]new command"/>
                <Command cmdname="程序匹配" cmdType="S" cmd="[S]new command"/>
              </Command>
            </Command>
          </Command>
          <Command cmdname="扩展项目" cmdType="S" cmd="[S]new command">
            <Command cmdname="数据扩展项0" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="数据扩展项1" cmdType="S" cmd="[S]new command"/>
          </Command>
          <Command cmdname="生成方式" cmdType="S" cmd="[S]new command">
            <Command cmdname="自动加1" cmdType="S" cmd="[S]1 command"/>
            <Command cmdname="自动减1" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="数据范围" cmdType="S" cmd="[S]1,2,3-9"/>
            <Command cmdname="随机数" cmdType="S" cmd="[S]new command数">
              <Command cmdname="合法性判断" cmdType="S" cmd="[S]new command"/>
            </Command>
            <Command cmdname="程序生成" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="表格选取" cmdType="S" cmd="[S]一new command">
              <Command cmdname="选取方式" cmdType="S" cmd="[S]new command"/>
            </Command>
          </Command>
        </Command>
        <Command cmdname="起始符2-0xAA" cmdType="S" cmd="[S]new command">
          <Command cmdname="长度" cmdType="S" cmd="[S]固定长度[1byte]- 变长[prg] 进行选择"/>
          <Command cmdname="内容" cmdType="S" cmd="[S]0xAA"/>
        </Command>
        <Command cmdname="长度" cmdType="S" cmd="[S]new command">
          <Command cmdname="长度" cmdType="S" cmd="[S]固定长度[1byte]- 变长[prg] 进行选择"/>
          <Command cmdname="全局合法性" cmdType="S" cmd="[S]new command"/>
        </Command>
        <Command cmdname="长度(反)" cmdType="S" cmd="[S]new command">
          <Command cmdname="长度" cmdType="S" cmd="[S]固定长度[1byte]- 变长[prg] 进行选择"/>
          <Command cmdname="包裹合法性" cmdType="S" cmd="[S]new command"/>
        </Command>
        <Command cmdname="流水号" cmdType="S" cmd="[S]new command">
          <Command cmdname="长度" cmdType="S" cmd="[S]固定长度[1byte]- 变长[prg] 进行选择"/>
          <Command cmdname="内容" cmdType="S" cmd="[S]0x55"/>
        </Command>
        <Command cmdname="数据" cmdType="S" cmd="[S]new command">
          <Command cmdname="命令1" cmdType="S" cmd="[S]new command">
            <Command cmdname="主命令字" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="子命令字" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="命令参数" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="数据项属性" cmdType="S" cmd="[S]new command">
              <Command cmdname="重复匹配" cmdType="S" cmd="[S]new command"/>
              <Command cmdname="包裹合法性" cmdType="S" cmd="[S]new command"/>
            </Command>
          </Command>
          <Command cmdname="命令2" cmdType="S" cmd="[S]new command">
            <Command cmdname="包裹合法性" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="命令字" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="命令参数" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="循环匹配" cmdType="S" cmd="[S]new command"/>
          </Command>
        </Command>
        <Command cmdname="校验" cmdType="S" cmd="[S]new command">
          <Command cmdname="长度" cmdType="S" cmd="[S]new command"/>
          <Command cmdname="内容" cmdType="S" cmd="[S]new command"/>
          <Command cmdname="包裹合法性" cmdType="S" cmd="[S]new command"/>
        </Command>
        <Command cmdname="结束符" cmdType="S" cmd="[S]0x03">
          <Command cmdname="长度" cmdType="S" cmd="[S]new command"/>
          <Command cmdname="内容" cmdType="S" cmd="[S]0x55"/>
          <Command cmdname="包裹合法性" cmdType="S" cmd="[S]new command"/>
        </Command>
        <Command cmdname="匹配表格" cmdType="S" cmd="[S]new command">
          <Command cmdname="表格一" cmdType="S" cmd="[S]new command">
            <Command cmdname="表格结构" cmdType="S" cmd="[S]new command">
              <Command cmdname="一级键值" cmdType="S" cmd="[S]new command">
                <Command cmdname="长度" cmdType="S" cmd="[S]new command"/>
                <Command cmdname="类型" cmdType="S" cmd="[S]new command"/>
                <Command cmdname="备注" cmdType="S" cmd="[S]new command"/>
              </Command>
              <Command cmdname="键值内容" cmdType="S" cmd="[S]new command">
                <Command cmdname="名称" cmdType="S" cmd="[S]new command"/>
                <Command cmdname="内容" cmdType="S" cmd="[S]new command"/>
                <Command cmdname="键值4" cmdType="S" cmd="[S]new command"/>
              </Command>
            </Command>
            <Command cmdname="表格内容" cmdType="S" cmd="[S]new command"/>
          </Command>
        </Command>
        <Command cmdname="全局变量" cmdType="S" cmd="[S]new command"/>
        <Command cmdname="全局函数" cmdType="S" cmd="[S]new command"/>
      </Command>
      <Command cmdname="数据构造器" cmdType="S" cmd="[S]new command">
        <Command cmdname="构造器1" cmdType="S" cmd="[S]new command"/>
        <Command cmdname="构造器2" cmdType="S" cmd="[S]new command"/>
      </Command>
      <Command cmdname="数据解析器" cmdType="S" cmd="[S]new command">
        <Command cmdname="解析器1" cmdType="S" cmd="[S]new command"/>
        <Command cmdname="解析器2" cmdType="S" cmd="[S]new command"/>
      </Command>
      <Command cmdname="流程构造器" cmdType="S" cmd="[S]new command">
        <Command cmdname="主\从站方式" cmdType="S" cmd="[S]new command"/>
      </Command>
    </Command>
  </Command>
  <Command cmdname="组帧发送处理【预处理后发送】" cmdType="P" cmd="[P]void PreProcess(unsigned char *srcData,int srcLen,unsigned char *dstData,int *dstLen)&#xA;{&#xA;    //帧格式:帧同步字符0x55+0xAA(2字节),长度LEN(1字节),数据DATA,校验CS（1字节）&#xA;    int len,i;&#xA;    unsigned char cs;&#xA;    dstData[0]=0x55;  //帧同步字符&#xA;    dstData[1]=0xAA;  //帧同步字符&#xA;&#xA;    dstData[2]=srcLen;&#xA;    memcpy(dstData+3,srcData,srcLen);&#xA;    cs=0;&#xA;    for(i=0; i&lt;srcLen+3; i++)&#xA;        cs=cs^dstData[i];&#xA;&#xA;    dstData[srcLen+3]=cs;&#xA;    *dstLen=srcLen+4; //目标帧数据长度:55 aa len data cs&#xA;}&#xA;void main()&#xA;{&#xA;    ShowMessage(&quot;数据预处理模板，对发送的数据自动套用该模板处理。\n处理格式为：帧同步字符(0x55+0xAA(2字节))，长度LEN(1字节)，数据DATA(n字节)，校验CS（1字节）&quot;);&#xA;}">
    <Command cmdname="发送前后处理" cmdType="P" cmd="[P]void main()&#xA;{&#xA;    ShowMessage(&quot;在发送前后对发送内容可以进行预处理！&quot;);&#xA;}&#xA;&#xA;void BeforeSend()&#xA;{&#xA;    PrintToCommWin(&quot;=====================&quot;);&#xA;}&#xA;void AfterSend()&#xA;{&#xA;    PrintToCommWin(&quot;---------------------&quot;);&#xA;    PrintToCommWin(&quot;&quot;);&#xA;}"/>
    <Command cmdname="组帧模板" cmdType="R" cmd="[R]void PreProcess(unsigned char *srcData,int srcLen,unsigned char *dstData,int *dstLen)&#xA;{&#xA;    //帧格式:帧同步字符0x55+0xAA(2字节),长度LEN(1字节),数据DATA,校验CS（1字节）&#xA;    int len,i;&#xA;    unsigned char cs;&#xA;    dstData[0]=0x55;  //帧同步字符&#xA;    dstData[1]=0xAA;  //帧同步字符&#xA;&#xA;    dstData[2]=srcLen;&#xA;    memcpy(dstData+3,srcData,srcLen);&#xA;    cs=0;&#xA;    for(i=0; i&lt;srcLen+3; i++)&#xA;        cs=cs^dstData[i];&#xA;&#xA;    dstData[srcLen+3]=cs;&#xA;    *dstLen=srcLen+4; //目标帧数据长度:55 aa len data cs&#xA;}&#xA;void main()&#xA;{&#xA;    ShowMessage(&quot;数据预处理模板，对发送的数据自动套用该模板处理。\n处理格式为：帧同步字符(0x55+0xAA(2字节))，长度LEN(1字节)，数据DATA(n字节)，校验CS（1字节）&quot;);&#xA;}"/>
    <Command cmdname="数据预处理[增加转义字符]" cmdType="R" cmd="[R]void PreProcess(unsigned char *srcData,int srcLen,unsigned char *dstData,int *dstLen)&#xA;{&#xA;    //0x02 为转义字符&#xA;    int len,i;&#xA;    len=0; &#xA;    for(i=0;i&lt;srcLen;i++)&#xA;    {        &#xA;        dstData[len++]=srcData[i];&#xA;        if(srcData[i]==0x02)        &#xA;            dstData[len++]=srcData[i];        &#xA;    }&#xA;    *dstLen=len ;  &#xA;}">
      <Command cmdname="1234" cmdType="H" cmd="[H]01 02 03 04"/>
    </Command>
    <Command cmdname="数据预处理[进行帧封装]" cmdType="R" cmd="[R]#include &quot;stdio.h&quot;&#xA;void PreProcess(unsigned char *srcData,int srcLen,unsigned char *dstData,int *dstLen)&#xA;{&#xA;    //帧格式:帧同步字符0x55+0xAA(2字节),长度LEN(1字节),数据DATA,校验CS（1字节）&#xA;    int len,i;&#xA;    unsigned char cs;&#xA;    dstData[0]=0x55;  //帧同步字符&#xA;    dstData[1]=0xAA;  //帧同步字符&#xA;         &#xA;    dstData[2]=srcLen;&#xA;    memcpy(dstData+3,srcData,srcLen);    &#xA;    cs=0;&#xA;    for(i=0;i&lt;srcLen+3;i++)&#xA;      cs=cs^dstData[i];&#xA;      &#xA;    dstData[srcLen+3]=cs;&#xA;    *dstLen=srcLen+4; //目标帧数据长度:55 aa len data cs&#xA;    printf(&quot;aaa&quot;);&#xA;}">
      <Command cmdname="1234" cmdType="H" cmd="[H]11 22 33 44"/>
      <Command cmdname="字符串" cmdType="S" cmd="[S]12345"/>
    </Command>
  </Command>
  <Command cmdname="网络通讯" cmdType="S" cmd="[S]=====数据发送区/C语言脚本编辑区=====&#xA;1.[F5]键发送/执行、[F4]键终止脚本运行。&#xA;2.[F8]键显示、隐藏输出栏。&#xA;3.[Ctrl+.]调出脚本接口函数列表、[Ctrl+/]提示函数参数信息、[Ctrl+P]列出代码模板。&#xA;4.[Ctrl+Enter]发送数据。&#xA;5.支持&quot;预处理&quot;功能，采用C语言脚本回调函数，对发送的数据进行预处理后发送。">
    <Command cmdname="以太网抓包" cmdType="S" cmd="[S]数据发送区/C语言脚本编辑区，[F5]键发送/执行。">
      <Command cmdname="UDP抓包分析" cmdType="P" cmd="[P]int cb1,cb2,cb3;&#xA;int cb1chk=1,cb2chk=1,cb3chk=1;&#xA;&#xA;void cb1click(int control)&#xA;{&#xA;    cb1chk=GetProperty(cb1,&quot;checked&quot;,0,0);&#xA;}&#xA;void cb2click(int control)&#xA;{&#xA;    cb2chk=GetProperty(cb2,&quot;checked&quot;,0,0);&#xA;}&#xA;void cb3click(int control)&#xA;{&#xA;    cb3chk=GetProperty(cb3,&quot;checked&quot;,0,0);&#xA;}&#xA;void main()&#xA;{&#xA;    ClearOutputWin();   //清除输出窗口内容&#xA;    ClearVclControls();&#xA;    ShowVclWin(160);&#xA;    ShowOutputWin(800);&#xA;    HideLeftTools();&#xA;    SetCommType(10);&#xA;&#xA;    int p=GetGuiWin();&#xA;    int pnl = CreateComponentEx(p,&quot;panel&quot;,&quot;caption&quot;,&quot;&quot;,&quot;left&quot;,2,&quot;top&quot;,2,&quot;width&quot;,620,&quot;height&quot;,170,NULL);&#xA;    cb1= CreateComponentEx(pnl,&quot;checkbox&quot;,&quot;caption&quot;,&quot;显示卡号&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,160,&quot;checked&quot;,1,&quot;onclick&quot;,cb1click,NULL);&#xA;    cb2= CreateComponentEx(pnl,&quot;checkbox&quot;,&quot;caption&quot;,&quot;显示版本&quot;,&quot;left&quot;,10,&quot;top&quot;,60,&quot;width&quot;,160,&quot;checked&quot;,1,&quot;onclick&quot;,cb2click,NULL);&#xA;    cb3= CreateComponentEx(pnl,&quot;checkbox&quot;,&quot;caption&quot;,&quot;显示读卡分站状态&quot;,&quot;left&quot;,10,&quot;top&quot;,80,&quot;width&quot;,160,&quot;checked&quot;,1,&quot;onclick&quot;,cb3click,NULL);&#xA;&#xA;&#xA;&#xA;};&#xA;&#xA;typedef struct _TAG&#xA;{&#xA;    int id;&#xA;    char name[20];&#xA;} TAG;&#xA;&#xA;&#xA;TAG taglist[]=&#xA;{&#xA;    {  935,&quot;测试01&quot;},&#xA;    {  750,&quot;测试02&quot;},&#xA;    {  288,&quot;测试03&quot;},&#xA;    {  909,&quot;测试04&quot;},&#xA;    {  737,&quot;测试05&quot;},&#xA;    {  855,&quot;测试06&quot;},&#xA;    {  552,&quot;测试07&quot;},&#xA;    {  782,&quot;测试08&quot;},&#xA;    {  296,&quot;测试09&quot;},&#xA;    {  269,&quot;测试10&quot;},&#xA;    {26896,&quot;测试11&quot;},&#xA;    {18662,&quot;测试12&quot;},&#xA;    {28725,&quot;测试13&quot;},&#xA;    {21839,&quot;测试14&quot;},&#xA;    {26890,&quot;测试15&quot;},&#xA;    {28385,&quot;测试16&quot;},&#xA;    {22119,&quot;测试17&quot;},&#xA;    {25876,&quot;测试18&quot;},&#xA;    {10955,&quot;测试19&quot;},&#xA;    {23656,&quot;测试20&quot;},&#xA;    {20793,&quot;测试21&quot;},&#xA;    {21669,&quot;测试22&quot;},&#xA;    {27235,&quot;测试23&quot;},&#xA;    {26250,&quot;测试24&quot;},&#xA;    {27378,&quot;测试25&quot;},&#xA;    {27885,&quot;测试26&quot;},&#xA;    {26269,&quot;测试27&quot;},&#xA;    {28805,&quot;测试28&quot;},&#xA;    {28872,&quot;测试29&quot;},&#xA;    {25696,&quot;测试30&quot;},&#xA;};&#xA;&#xA;void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件&#xA;{&#xA;    int node;&#xA;    int i,j,k;&#xA;    char s[1024];&#xA;    char tm[62],tmp[62];&#xA;    int fd;&#xA;&#xA;    //for(i=0;i&lt;count;i++)printf(&quot;%02x &quot;,buf[i]&amp;0xff);&#xA;    GetTimeStr(tm,62);&#xA;    sprintf(tmp,&quot;%d.%d.%d.【%3d】&quot;,(srcIp&gt;&gt;0)&amp;0xff,(srcIp&gt;&gt;8)&amp;0xff,(srcIp&gt;&gt;16)&amp;0xff,(srcIp&gt;&gt;24)&amp;0xff);&#xA;&#xA;    if(count&gt;25)&#xA;    {&#xA;&#xA;        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x99)&amp;&amp;(buf[9]==0x04)&amp;&amp;(count&gt;25))//&amp;&amp;(buf[2]==0x11)&#xA;        {&#xA;            sprintf(s,&quot;%s  %s.%1X %02d:%02d:%02d  %02d,卡号：&quot;,tm,tmp,(buf[7]&gt;&gt;4)&amp;0xff,buf[14],buf[15],buf[16],(count-24)/2);&#xA;            for(j=23; j&lt;count-1; j+=2)&#xA;            {&#xA;                //printf(&quot;卡号:%05d&quot;,buf[j]*256+buf[j+1]);&#xA;                fd=0;&#xA;                if((buf[j]&gt;&gt;7)&gt;0)&#xA;                    printf(&quot;呼叫：%d&quot;,(buf[j]*256+buf[j+1])&amp;0x7fff);&#xA;&#xA;                for(k=0; k&lt;sizeof(taglist); k++)&#xA;                    if(buf[j]*256+buf[j+1]==taglist[k].id)&#xA;                    {&#xA;                        sprintf(tmp,&quot;   VIP--%s,&quot;,taglist[k].name);&#xA;                        fd=1;&#xA;                        break;&#xA;                    }&#xA;                if(fd==0)&#xA;                    sprintf(tmp,&quot;%05d,&quot;,buf[j]*256+buf[j+1]);&#xA;                strcat(s,tmp);&#xA;            }&#xA;            if(cb1chk)&#xA;                printf(&quot;%s&quot;,s);&#xA;        }&#xA;    }&#xA;    else if(count&gt;=15)&#xA;    {&#xA;        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x98)&amp;&amp;(buf[9]==0x1d))&#xA;        {&#xA;            sprintf(s,&quot;%s  %s.%1X 上报版本号:%c%c%c%c&quot;,tm,tmp,(buf[7]&gt;&gt;4)&amp;0xff,buf[10],buf[11],buf[12],buf[13]);&#xA;            if(cb2chk)printf(s);&#xA;        }&#xA;    }&#xA;    else if(count&gt;=12)&#xA;    {&#xA;        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x98)&amp;&amp;(buf[9]==0x1a))&#xA;        {&#xA;            sprintf(s,&quot;%s  %s.%1X 上报读卡分站状态:%d&quot;,tm,tmp,(buf[7]&gt;&gt;4)&amp;0xff,buf[10]&amp;0xff);&#xA;            if(cb3chk)printf(s);&#xA;        }&#xA;    }&#xA;    else if(count&gt;=11)&#xA;    {&#xA;        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x07))&#xA;            printf(&quot;%s  %s.%1X 站点启动报告,代码：%d&quot;,tm,tmp,(buf[7]&gt;&gt;4)&amp;0xff,buf[9]);&#xA;    }&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;"/>
      <Command cmdname="HTTP抓包分析" cmdType="P" cmd="[P]int cb1,cb2,cb3;&#xA;int cb1chk=1,cb2chk=1,cb3chk=1;&#xA;&#xA;void main()&#xA;{&#xA;    ClearOutputWin();   //清除输出窗口内容&#xA;    ClearVclControls();&#xA;    ShowVclWin(160);&#xA;    ShowOutputWin(800);&#xA;    HideLeftTools();&#xA;    SetCommType(10);&#xA;&#xA;    int p=GetGuiWin();&#xA;    int pnl = CreateComponentEx(p,&quot;panel&quot;,&quot;caption&quot;,&quot;&quot;,&quot;left&quot;,2,&quot;top&quot;,2,&quot;width&quot;,620,&quot;height&quot;,170,NULL);&#xA;   // cb1= CreateComponentEx(pnl,&quot;checkbox&quot;,&quot;caption&quot;,&quot;显示卡号&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,160,&quot;checked&quot;,1,&quot;onclick&quot;,cb1click,NULL);&#xA;   // cb2= CreateComponentEx(pnl,&quot;checkbox&quot;,&quot;caption&quot;,&quot;显示版本&quot;,&quot;left&quot;,10,&quot;top&quot;,60,&quot;width&quot;,160,&quot;checked&quot;,1,&quot;onclick&quot;,cb2click,NULL);&#xA;   // cb3= CreateComponentEx(pnl,&quot;checkbox&quot;,&quot;caption&quot;,&quot;显示读卡分站状态&quot;,&quot;left&quot;,10,&quot;top&quot;,80,&quot;width&quot;,160,&quot;checked&quot;,1,&quot;onclick&quot;,cb3click,NULL);&#xA;&#xA;&#xA;&#xA;};&#xA;&#xA;&#xA;void CapTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件&#xA;{&#xA;    int node;&#xA;    int i,j,k;&#xA;    char s[1024];&#xA;    char tm[62],tmp[62];&#xA;    int fd;&#xA;    printf(&quot;cap tcp data:%x,%d,%x,%d,%s&quot;,srcIp,srcPort,dstIp,dstPort,buf);&#xA;    if(dstPort!=80) return;&#xA;&#xA;    if(strstr(buf,&quot;passw&quot;)!=0)&#xA;    {&#xA;        char *p=strstr(buf,&quot;passw&quot;);&#xA;        printf(&quot;find:%s&quot;,p);&#xA;    }&#xA;    else&#xA;    {&#xA;        return;&#xA;    }&#xA;&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;"/>
      <Command cmdname="UDP抓包分析-协议树" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;int cb1,cb2,cb3;&#xA;int cb1chk=1,cb2chk=1,cb3chk=1;&#xA;int station[255];&#xA;void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count);//UDP抓包事件&#xA;void AnaProtocolData(unsigned char *buf,int count)&#xA;{&#xA;    int node,node1;&#xA;    int i,j,k;&#xA;    char s[1024];&#xA;    if(count&lt;7)return;&#xA;    if(buf[0]!=0xff) return;&#xA;    if(buf[1]!=0xff) return;&#xA;    if(buf[3]&gt;count-5) return;&#xA;    unsigned char cs=0;&#xA;    for(i=0; i&lt;buf[3]+3; i++)&#xA;        cs+=buf[2+i];&#xA;    if(cs!=0)&#xA;    {&#xA;        printf(&quot;check sum error!&quot;);&#xA;        return;&#xA;    }&#xA;    AddPrtclDetailNode(NULL,&quot;同步头&quot;,0,2);&#xA;    AddPrtclDetailNode(NULL,&quot;目的地址&quot;,2,1);&#xA;    AddPrtclDetailNode(NULL,&quot;数据长度&quot;,3,1);&#xA;    AddPrtclDetailNode(NULL,&quot;源地址&quot;,4,1);&#xA;    AddPrtclDetailNode(NULL,&quot;流水号&quot;,5,1);&#xA;    if(buf[3]-2&gt;0)&#xA;    {&#xA;        AddPrtclDetailNode(NULL,&quot;数据长度&quot;,6,1);&#xA;        node=AddPrtclDetailNode(NULL,&quot;数据&quot;,7,buf[6]);&#xA;        AddPrtclDetailNode(node,&quot;点号&quot;,7,1);&#xA;        AddPrtclDetailNode(node,&quot;命令号&quot;,8,2);&#xA;        AddPrtclDetailNode(NULL,&quot;校验&quot;,7+buf[6],1);&#xA;    }&#xA;    else&#xA;    {&#xA;        AddPrtclDetailNode(NULL,&quot;校验&quot;,6,1);&#xA;    }&#xA;&#xA;    if(count&gt;25)&#xA;    {&#xA;        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x99)&amp;&amp;(buf[9]==0x04)&amp;&amp;(count&gt;25))//&amp;&amp;(buf[2]==0x11)&#xA;        {&#xA;            AddPrtclDetailNode(node,&quot;日期&quot;,10,4);&#xA;&#xA;            node1=AddPrtclDetailNode(node,&quot;时间&quot;,14,3);&#xA;            sprintf(s,&quot;%02d:%02d:%02d&quot;,buf[14]&amp;0xff,buf[15]&amp;0xff,buf[16]&amp;0xff);&#xA;            AddPrtclDetailNode(node1,s,10,0);&#xA;&#xA;            AddPrtclDetailNode(node,&quot;查询流水号&quot;,17,1);&#xA;            AddPrtclDetailNode(node,&quot;总包数&quot;,18,1);&#xA;            AddPrtclDetailNode(node,&quot;包号&quot;,19,1);&#xA;            AddPrtclDetailNode(node,&quot;节点号&quot;,20,1);&#xA;            AddPrtclDetailNode(node,&quot;总团数&quot;,21,1);&#xA;            AddPrtclDetailNode(node,&quot;团人数&quot;,22,1);&#xA;&#xA;            node1=AddPrtclDetailNode(node,&quot;卡号&quot;,23,buf[6]-16);&#xA;            for(i=0; i&lt;buf[6]-16; i+=2)&#xA;            {&#xA;                sprintf(s,&quot;卡%02d:%05d &quot;,i+1,buf[23+i]*256+buf[23+i+1]);&#xA;                AddPrtclDetailNode(node1,s,23+i,2);&#xA;            }&#xA;        }&#xA;    }&#xA;    else if(count&gt;=15)&#xA;    {&#xA;        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x98)&amp;&amp;(buf[9]==0x1d))&#xA;        {&#xA;            sprintf(s,&quot;版本号:%c%c%c%c&quot;,buf[10],buf[11],buf[12],buf[13]);&#xA;            AddPrtclDetailNode(node,s,10,4);&#xA;        }&#xA;    }&#xA;    else if(count&gt;=12)&#xA;    {&#xA;        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x98)&amp;&amp;(buf[9]==0x1a))&#xA;        {&#xA;            sprintf(s,&quot;读卡分站状态:%d&quot;,buf[10]&amp;0xff);&#xA;            AddPrtclDetailNode(node,s,10,1);&#xA;        }&#xA;    }&#xA;    else if(count&gt;=11)&#xA;    {&#xA;        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x07))&#xA;        {&#xA;            sprintf(s,&quot;启动报告代码：%d&quot;,buf[9]);&#xA;            AddPrtclDetailNode(node,s,9,1);&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;&#xA;void cb1click(int control)&#xA;{&#xA;    cb1chk=GetProperty(cb1,&quot;checked&quot;,0,0);&#xA;}&#xA;&#xA;void cb2click(int control)&#xA;{&#xA;    cb2chk=GetProperty(cb2,&quot;checked&quot;,0,0);&#xA;}&#xA;&#xA;void cb3click(int control)&#xA;{&#xA;    cb3chk=GetProperty(cb3,&quot;checked&quot;,0,0);&#xA;}&#xA;void btnClick(int control)&#xA;{&#xA;    unsigned char dat0[]= {0xFF,0xFF,0x11,0x19,0x13,0x09,0x16,0x10,0x99,0x04,0x07,0xDB,0x08,0x1A,0x0C,0x2A,0x18,0x56,0x01,0x01,0x10,0x01,0x03,0x5A,0xAF,0x69,0x4B,0x68,0x2A,0xEA};&#xA;    unsigned char dat1[]= {0xFF,0xFF,0x11,0x0A,0x13,0x05,0x07,0xC0,0x98,0x1D,0x31,0x2E,0x30,0x32,0x90};&#xA;&#xA;    CapUdpData(0,0,0,0,dat0,sizeof(dat0));//UDP抓包模拟&#xA;    CapUdpData(0,0,0,0,dat1,sizeof(dat1));//UDP抓包模拟&#xA;}&#xA;void main()&#xA;{&#xA;    int i;&#xA;    ClearOutputWin();   //清除输出窗口内容&#xA;    ClearVclControls();&#xA;    ShowVclWin(160);&#xA;    ShowOutputWin(800);&#xA;    //HideLeftTools();&#xA;    ShowProtocolWin();&#xA;    ClearProtocolTree();&#xA;    SetCommType(10);&#xA;&#xA;    int p=GetGuiWin();&#xA;    int pnl = CreateComponentEx(p,&quot;panel&quot;,&quot;caption&quot;,&quot;&quot;,&quot;left&quot;,2,&quot;top&quot;,2,&quot;width&quot;,620,&quot;height&quot;,170,NULL);&#xA;    cb1= CreateComponentEx(pnl,&quot;checkbox&quot;,&quot;caption&quot;,&quot;显示卡号&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,160,&quot;checked&quot;,1,&quot;onclick&quot;,cb1click,NULL);&#xA;    cb2= CreateComponentEx(pnl,&quot;checkbox&quot;,&quot;caption&quot;,&quot;显示版本&quot;,&quot;left&quot;,10,&quot;top&quot;,60,&quot;width&quot;,160,&quot;checked&quot;,1,&quot;onclick&quot;,cb2click,NULL);&#xA;    cb3= CreateComponentEx(pnl,&quot;checkbox&quot;,&quot;caption&quot;,&quot;显示读卡分站状态&quot;,&quot;left&quot;,10,&quot;top&quot;,80,&quot;width&quot;,160,&quot;checked&quot;,1,&quot;onclick&quot;,cb3click,NULL);&#xA;    CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;测试数据&quot;,&quot;left&quot;,10,&quot;top&quot;,100,&quot;width&quot;,100,&quot;onclick&quot;,btnClick,NULL);&#xA;    for(i=0; i&lt;255; i++)station[i]=0;&#xA;&#xA;    //btnClick(0);&#xA;};&#xA;&#xA;typedef struct _TAG&#xA;{&#xA;    int id;&#xA;    char name[20];&#xA;} TAG;&#xA;&#xA;&#xA;TAG taglist[]=&#xA;{&#xA;    {  935,&quot;测试01&quot;},&#xA;    {  750,&quot;测试02&quot;},&#xA;    {  288,&quot;测试03&quot;},&#xA;    {  909,&quot;测试04&quot;},&#xA;    {  737,&quot;测试05&quot;},&#xA;    {  855,&quot;测试06&quot;},&#xA;    {  552,&quot;测试07&quot;},&#xA;    {  782,&quot;测试08&quot;},&#xA;    {  296,&quot;测试09&quot;},&#xA;    {  269,&quot;测试10&quot;},&#xA;    {26896,&quot;测试11&quot;},&#xA;    {18662,&quot;测试12&quot;},&#xA;    {28725,&quot;测试13&quot;},&#xA;    {21839,&quot;测试14&quot;},&#xA;    {26890,&quot;测试15&quot;},&#xA;    {28385,&quot;测试16&quot;},&#xA;    {22119,&quot;测试17&quot;},&#xA;    {25876,&quot;测试18&quot;},&#xA;    {10955,&quot;测试19&quot;},&#xA;    {23656,&quot;测试20&quot;},&#xA;    {20793,&quot;测试21&quot;},&#xA;    {21669,&quot;测试22&quot;},&#xA;    {27235,&quot;测试23&quot;},&#xA;    {26250,&quot;测试24&quot;},&#xA;    {27378,&quot;测试25&quot;},&#xA;    {27885,&quot;测试26&quot;},&#xA;    {26269,&quot;测试27&quot;},&#xA;    {28805,&quot;测试28&quot;},&#xA;    {28872,&quot;测试29&quot;},&#xA;    {25696,&quot;测试30&quot;},&#xA;};&#xA;&#xA;void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件&#xA;{&#xA;    int node;&#xA;    int i,j,k;&#xA;    char s[1024];&#xA;    char tm[62],tmp[62];&#xA;    int fd;&#xA;&#xA;    //for(i=0;i&lt;count;i++)printf(&quot;%02x &quot;,buf[i]&amp;0xff);&#xA;    GetTimeStr(tm,62);&#xA;    sprintf(tmp,&quot;%d.%d.%d.【%3d】&quot;,(srcIp&gt;&gt;0)&amp;0xff,(srcIp&gt;&gt;8)&amp;0xff,(srcIp&gt;&gt;16)&amp;0xff,(srcIp&gt;&gt;24)&amp;0xff);&#xA;&#xA;    if(count&lt;7)return;&#xA;    if(buf[0]!=0xff) return;&#xA;    if(buf[1]!=0xff) return;&#xA;    if(buf[3]&gt;count-5) return;&#xA;    unsigned char cs=0;&#xA;    unsigned char src,dst;&#xA;    int node;&#xA;&#xA;&#xA;    for(i=0; i&lt;buf[3]+3; i++)&#xA;        cs+=buf[2+i];&#xA;    if(cs!=0)&#xA;    {&#xA;        printf(&quot;check sum error!&quot;);&#xA;        return;&#xA;    }&#xA;&#xA;    src=buf[4];&#xA;    dst=buf[2];&#xA;    if(src==17)&#xA;    {&#xA;        if(station[dst]==0)&#xA;        {&#xA;            sprintf(s,&quot;分站-%d&quot;,dst);&#xA;            station[dst]=AddPrtclDataNode(NULL,s,0,0,0);&#xA;        }&#xA;        node=station[dst];&#xA;    }&#xA;    else&#xA;    {&#xA;        if(station[src]==0)&#xA;        {&#xA;            sprintf(s,&quot;分站-%d&quot;,src);&#xA;            station[dst]=AddPrtclDataNode(NULL,s,0,0,0);&#xA;        }&#xA;        node=station[src];&#xA;    }&#xA;&#xA;    if(buf[3]==0x02)&#xA;    {&#xA;        sprintf(s,&quot;循访空包:%d-&gt;%d,sn:%d&quot;,buf[4],buf[2],buf[5]);&#xA;        src=buf[4];&#xA;        dst=buf[2];&#xA;&#xA;        AddPrtclDataNode(node,s,buf,count,0);&#xA;&#xA;&#xA;&#xA;        return;&#xA;    }&#xA;&#xA;    if(count&gt;25)&#xA;    {&#xA;        sprintf(s,&quot;上报卡号:%d-&gt;%d,sn:%d&quot;,buf[4],buf[2],buf[5]);&#xA;        AddPrtclDataNode(node,s,buf,count,0);&#xA;&#xA;&#xA;        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x99)&amp;&amp;(buf[9]==0x04)&amp;&amp;(count&gt;25))//&amp;&amp;(buf[2]==0x11)&#xA;        {&#xA;            sprintf(s,&quot;%s  %s.%1X %02d:%02d:%02d  %02d,卡号：&quot;,tm,tmp,(buf[7]&gt;&gt;4)&amp;0xff,buf[14],buf[15],buf[16],(count-24)/2);&#xA;            for(j=23; j&lt;count-1; j+=2)&#xA;            {&#xA;                //printf(&quot;卡号:%05d&quot;,buf[j]*256+buf[j+1]);&#xA;                fd=0;&#xA;                if((buf[j]&gt;&gt;7)&gt;0)&#xA;                    printf(&quot;呼叫：%d&quot;,(buf[j]*256+buf[j+1])&amp;0x7fff);&#xA;&#xA;                for(k=0; k&lt;sizeof(taglist); k++)&#xA;                    if(buf[j]*256+buf[j+1]==taglist[k].id)&#xA;                    {&#xA;                        sprintf(tmp,&quot;   VIP--%s,&quot;,taglist[k].name);&#xA;                        fd=1;&#xA;                        break;&#xA;                    }&#xA;                if(fd==0)&#xA;                    sprintf(tmp,&quot;%05d,&quot;,buf[j]*256+buf[j+1]);&#xA;                strcat(s,tmp);&#xA;            }&#xA;            if(cb1chk)&#xA;                printf(&quot;%s&quot;,s);&#xA;        }&#xA;    }&#xA;    else if(count&gt;=15)&#xA;    {&#xA;        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x98)&amp;&amp;(buf[9]==0x1d))&#xA;        {&#xA;&#xA;&#xA;            sprintf(s,&quot;上报版本号:%d-&gt;%d,sn:%d&quot;,buf[4],buf[2],buf[5]);&#xA;            AddPrtclDataNode(node,s,buf,count,0);&#xA;&#xA;            sprintf(s,&quot;%s  %s.%1X 上报版本号:%c%c%c%c&quot;,tm,tmp,(buf[7]&gt;&gt;4)&amp;0xff,buf[10],buf[11],buf[12],buf[13]);&#xA;            if(cb2chk)printf(s);&#xA;        }&#xA;    }&#xA;    else if(count&gt;=12)&#xA;    {&#xA;        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x98)&amp;&amp;(buf[9]==0x1a))&#xA;        {&#xA;&#xA;&#xA;            sprintf(s,&quot;上报读卡分站状态:%d-&gt;%d,sn:%d&quot;,buf[4],buf[2],buf[5]);&#xA;            AddPrtclDataNode(node,s,buf,count,0);&#xA;&#xA;            sprintf(s,&quot;%s  %s.%1X 上报读卡分站状态:%d&quot;,tm,tmp,(buf[7]&gt;&gt;4)&amp;0xff,buf[10]&amp;0xff);&#xA;            if(cb3chk)printf(s);&#xA;        }&#xA;    }&#xA;    else if(count&gt;=11)&#xA;    {&#xA;        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x07))&#xA;        {&#xA;&#xA;            sprintf(s,&quot;站点启动报告:%d-&gt;%d,sn:%d&quot;,buf[4],buf[2],buf[5]);&#xA;            AddPrtclDataNode(node,s,buf,count,0);&#xA;&#xA;            printf(&quot;%s  %s.%1X 站点启动报告,代码：%d&quot;,tm,tmp,(buf[7]&gt;&gt;4)&amp;0xff,buf[9]);&#xA;        }&#xA;    }&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;"/>
    </Command>
    <Command cmdname="C脚本通讯协议分析-数据树形显示" cmdType="P" cmd="[P]#include &quot;windows.h&quot; &#xA; &#xA;//////////////// 接收队列处理 ///////////////////////////////////&#xA;#define MAXRXBUFLEN (1024*20)&#xA;#define GetRxBufLen()  ((RxBufTail+MAXRXBUFLEN-RxBufHead) % MAXRXBUFLEN)&#xA;#define IsRxBufEmpty() (RxBufHead==RxBufTail)&#xA;#define IsRxBufFull()  ((RxBufTail+1)%MAXRXBUFLEN==RxBufHead)&#xA;#define ClearRxBuf()   RxBufHead=RxBufTail=0&#xA;&#xA;BYTE RxBuf[MAXRXBUFLEN];&#xA;BYTE RxBufHead=0;&#xA;BYTE RxBufTail=0;&#xA;&#xA;BYTE GetRxBufByte(void)&#xA;{&#xA;   BYTE dat;&#xA;   dat=RxBuf[RxBufHead];&#xA;   RxBufHead++;&#xA;   RxBufHead%=MAXRXBUFLEN;&#xA;   return dat;&#xA;}&#xA;void DiscardRxBufBytes(BYTE count)&#xA;{&#xA;   RxBufHead+=count;&#xA;   RxBufHead%=MAXRXBUFLEN;&#xA;}&#xA;BYTE PeekRxBufByte(BYTE idx)&#xA;{&#xA;   BYTE tmpHead=RxBufHead;&#xA;   tmpHead+=idx;&#xA;   tmpHead%=MAXRXBUFLEN;&#xA;   return RxBuf[tmpHead];&#xA;}&#xA;void PutRxBufByte(BYTE dat)&#xA;{&#xA;   RxBuf[RxBufTail]=dat;&#xA;   RxBufTail++;&#xA;   RxBufTail%=MAXRXBUFLEN;&#xA;}&#xA;&#xA;//////////////////////////////////////////////////////////////////&#xA;//////////////// 队列处理 ///////////////////////////////////&#xA;//#define MAXRXBUFLEN (1024*20)&#xA;#define GetPrtclBufLen()  ((PrtclBufTail+MAXRXBUFLEN-PrtclBufHead) % MAXRXBUFLEN)&#xA;#define IsPrtclBufEmpty() (PrtclBufHead==PrtclBufTail)&#xA;#define IsPrtclBufFull()  ((PrtclBufTail+1)%MAXRXBUFLEN==PrtclBufHead)&#xA;#define ClearPrtclBuf()   PrtclBufHead=PrtclBufTail=0&#xA;&#xA;BYTE PrtclBuf[MAXRXBUFLEN];&#xA;BYTE PrtclBufHead=0;&#xA;BYTE PrtclBufTail=0;&#xA;&#xA;BYTE GetPrtclBufByte(void)&#xA;{&#xA;   BYTE dat;&#xA;   dat=PrtclBuf[PrtclBufHead];&#xA;   PrtclBufHead++;&#xA;   PrtclBufHead%=MAXRXBUFLEN;&#xA;   return dat;&#xA;}&#xA;void DiscardPrtclBufBytes(BYTE count)&#xA;{&#xA;   PrtclBufHead+=count;&#xA;   PrtclBufHead%=MAXRXBUFLEN;&#xA;}&#xA;BYTE PeekPrtclBufByte(BYTE idx)&#xA;{&#xA;   BYTE tmpHead=PrtclBufHead;&#xA;   tmpHead+=idx;&#xA;   tmpHead%=MAXRXBUFLEN;&#xA;   return PrtclBuf[tmpHead];&#xA;}&#xA;void PutPrtclBufByte(BYTE dat)&#xA;{&#xA;   PrtclBuf[PrtclBufTail]=dat;&#xA;   PrtclBufTail++;&#xA;   PrtclBufTail%=MAXRXBUFLEN;&#xA;}&#xA;&#xA;//////////////////////////////////////////////////////////////////&#xA;&#xA;&#xA;&#xA;&#xA;#define MAXCMDLEN 20&#xA;BYTE StationCmd[MAXCMDLEN];&#xA;BYTE StationCmdLen;&#xA;BYTE RepBuf[140];&#xA;&#xA;unsigned int  newId,newInterval;&#xA;&#xA;void ConsolePutArray(BYTE buf[],BYTE len)&#xA;{&#xA;   BYTE i;&#xA;   for(i=0;i&lt;len;i++)&#xA;   	;//   halPutch(buf[i]);&#xA;}&#xA;&#xA; &#xA;void ProgramData(void)// 查询单个团详细信息&#xA;{&#xA;    BYTE i,j;&#xA;    BYTE find;&#xA;    BYTE idx;&#xA;    BYTE cs;&#xA;    BYTE mbCount;&#xA;&#xA;    if(StationCmdLen!=1+4)&#xA;    { 	 &#xA;	  // return;&#xA;    }&#xA;    newId=StationCmd[1]+StationCmd[2]*256;&#xA;     &#xA;}&#xA;&#xA;void ProcessStationCmd(void)&#xA;{&#xA;    if(StationCmdLen==0) return;&#xA;    switch(StationCmd[0])&#xA;    {   	&#xA;        case 0x08: // 查询工作状态            =[H]55 AA 02 FD 07 07 03&#xA;           ProgramData();&#xA;   	   break;&#xA;		&#xA;        default:&#xA;	   break;&#xA;    } &#xA;}&#xA;&#xA;void EncodePrtclData(void)//包裹解码&#xA;{&#xA;   BYTE i,len;&#xA;   BYTE cs;&#xA;   len=PeekPrtclBufByte(2);&#xA;   if(len&gt;MAXCMDLEN)&#xA;   {&#xA;       StationCmd[0]=PeekPrtclBufByte(4);&#xA;       for(i=0;i&lt;=4+len;i++)&#xA;   	   GetPrtclBufByte();//丢弃一个字节;&#xA;       return ;&#xA;   }&#xA;   AddPrtclDetailNode(NULL,&quot;同步头&quot;,PrtclBufHead,2);&#xA;   GetPrtclBufByte();//丢弃一个字节; 55&#xA;   GetPrtclBufByte();//丢弃一个字节; aa&#xA;   AddPrtclDetailNode(NULL,&quot;长度&quot;,PrtclBufHead,1);&#xA;&#xA;   GetPrtclBufByte();//丢弃一个字节; len&#xA;   AddPrtclDetailNode(NULL,&quot;~长度&quot;,PrtclBufHead,1);&#xA;   GetPrtclBufByte();//丢弃一个字节; ~len&#xA;&#xA;   AddPrtclDetailNode(NULL,&quot;data&quot;,PrtclBufHead,len);  &#xA;&#xA;   for(i=0;i&lt;len;i++)&#xA;      StationCmd[i]=GetPrtclBufByte();&#xA;   GetPrtclBufByte(); //0x03&#xA;&#xA;   cs=0;&#xA;   for(i=0;i&lt;len-1;i++)&#xA;      cs^=StationCmd[i];&#xA;&#xA;   if(cs!=StationCmd[len-1])&#xA;   {       &#xA;       printf(&quot;check sum error!&quot;);&#xA;       //return;	&#xA;   }&#xA;&#xA;   //ConsolePutROMString((rom char *)&quot;接收到命令包:&quot;);&#xA;   //ConsolePutInitData(0,StationCmd[0]);&#xA;   StationCmdLen=len-1; //不包含校验位&#xA;   printf(&quot;Recv a command!&quot;);&#xA;   ProcessStationCmd();&#xA;&#xA;}&#xA;&#xA;&#xA;//通讯处理&#xA;void ProcessRxComm(void)&#xA;{&#xA;    BYTE len;&#xA;    while(GetRxBufLen()&gt;=7)&#xA;    {&#xA;        if(PeekRxBufByte(0)!=0x55)	  	&#xA;        {          &#xA;           DiscardRxBufBytes(1);&#xA;        }&#xA;        else if(PeekRxBufByte(1)!=0xaa)	  	&#xA;	{	   &#xA;	   DiscardRxBufBytes(2);&#xA;	}&#xA;	else if(PeekRxBufByte(2)+PeekRxBufByte(3)!=0xff)//长度、长度取反&#xA;	{	 &#xA;	   DiscardRxBufBytes(4);&#xA;	}&#xA;	else&#xA;	{&#xA;	   len=PeekRxBufByte(2);&#xA;           if(len&gt;MAXCMDLEN)  //命令过长&#xA;	   {	       &#xA;              DiscardRxBufBytes(4);&#xA;	   }&#xA;	   else if(GetRxBufLen()&gt;len+4)&#xA;	   {&#xA;	     if(PeekRxBufByte(4+len)!=0x03)//结束字符&#xA;	     {	 	   &#xA;        	   DiscardRxBufBytes(1);&#xA;	     }&#xA;	     else&#xA;	    {&#xA;                  &#xA;                 AddPrtclDataNode(NULL,&quot;版本号查询&quot;,&amp;RxBuf[RxBufHead],len+5,0);&#xA;                  &#xA;		 DiscardRxBufBytes(len+5);&#xA;                  &#xA;	    }&#xA;	  }&#xA;	  else&#xA;	  {&#xA;	      break;&#xA;	  }&#xA;	}			&#xA;    }	//while	&#xA;}&#xA;&#xA;&#xA;&#xA;void ProcessPrtclData(void)&#xA;{&#xA;    BYTE len;&#xA;    while(GetPrtclBufLen()&gt;=7)&#xA;    {&#xA;        if(PeekPrtclBufByte(0)!=0x55)	  	&#xA;        {          &#xA;           DiscardPrtclBufBytes(1);&#xA;        }&#xA;        else if(PeekPrtclBufByte(1)!=0xaa)	  	&#xA;	{	   &#xA;	   DiscardPrtclBufBytes(2);&#xA;	}&#xA;	else if(PeekPrtclBufByte(2)+PeekPrtclBufByte(3)!=0xff)//长度、长度取反&#xA;	{	 &#xA;	   DiscardPrtclBufBytes(4);&#xA;	}&#xA;	else&#xA;	{&#xA;	   len=PeekPrtclBufByte(2);&#xA;           if(len&gt;MAXCMDLEN)  //命令过长&#xA;	   {	       &#xA;              DiscardPrtclBufBytes(4);&#xA;	   }&#xA;	   else if(GetPrtclBufLen()&gt;len+4)&#xA;	   {&#xA;	     if(PeekPrtclBufByte(4+len)!=0x03)//结束字符&#xA;	     {	 	   &#xA;        	   DiscardPrtclBufBytes(1);&#xA;	     }&#xA;	     else&#xA;	    {  &#xA;                 EncodePrtclData(); &#xA;	    }&#xA;	  }&#xA;	  else&#xA;	  {&#xA;	      break;&#xA;	  }&#xA;	}			&#xA;    }	//while	&#xA;}&#xA;&#xA;&#xA;//////////////////////////////////////////////////////////////////////&#xA;&#xA;void RecvSerialData(char *buf,int count)&#xA;{&#xA;   int i;&#xA;   for(i=0;i&lt;count;i++)&#xA;   {&#xA;       PutRxBufByte(buf[i]);&#xA;   }  &#xA;   printf(&quot;RecvSerialData,len(%d)&quot;,count);  &#xA;   ProcessRxComm();&#xA; &#xA;}&#xA;void AnaProtocolData(char *buf,int count)&#xA;{   &#xA;   int node; int i;&#xA;   printf(&quot;AnaProtocolData,len(%d) &quot;,count );  &#xA;   ClearPrtclBuf();&#xA;   for(i=0;i&lt;count;i++)&#xA;       PutPrtclBufByte(buf[i]);&#xA;   ProcessPrtclData();&#xA;   &#xA;}&#xA;&#xA;void click(int btn)&#xA;{&#xA;   char s[20];&#xA;   printf(&quot;clicked&quot;);&#xA;   //SetProperty(btn,&quot;enabled&quot;,&quot;false&quot;);&#xA;   GetProperty(btn,&quot;caption&quot;,s,20); &#xA;   printf(&quot;button caption is %s&quot;,s);   &#xA;   MessageBox(0,s,&quot;按钮标题&quot;,1);&#xA;};&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;void main()&#xA;{&#xA;  int i;&#xA;  int btn;&#xA;  int node;&#xA;  char s[100];&#xA;  ShowProtocolWindow();&#xA;  ClearVclControls();&#xA;  ShowVclWin(150);&#xA;  ShowOutputWin(300);&#xA;  int p=GetGuiWindow();&#xA;  for(  i=0;i&lt;1;i++)&#xA;  {                              &#xA;     sprintf(s,&quot;按钮:%d&quot;,i);&#xA;     btn=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,s,&quot;left&quot;,10+i*70,&quot;top&quot;,30,&quot;width&quot;,65,&quot;onclick&quot;,click,NULL);//创建按钮&#xA;  }&#xA;&#xA;  btn=CreateComponentEx(p,&quot;combobox&quot;,&quot;text&quot;,&quot;按钮&quot;,&quot;left&quot;,12+i*70,&quot;top&quot;,32,&quot;width&quot;,80,&quot;onclick&quot;,click,NULL);//创建按钮&#xA;  //SetProperty(btn,&quot;caption&quot;,&quot;最后一个按钮&quot;);&#xA;  StringsAdd(btn,&quot;111&quot;);&#xA;  //s[0]=90;//printf(&quot;%s&quot;,s);&#xA;  sprintf(s+10,&quot;按钮876587iuytiuyt87888777666555:%d&quot;,i);   &#xA;  ClearProtocolTree();&#xA;  //node=AddPrtclDataNode(NULL,&quot;版本号查询&quot;,s,100,0);&#xA;  //sprintf(s+10,&quot;reqtgfdsgfdsgft64ew2543w25435:%d&quot;,i); &#xA;  //node=AddPrtclDataNode(node,&quot;版本号查询1&quot;,s,100,0);&#xA;};&#xA;">
      <Command cmdname="协议解析程序0" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;&#xA;//////////////// 接收队列处理 ///////////////////////////////////&#xA;#define MAXRXBUFLEN (1024*20)&#xA;#define GetRxBufLen()  ((RxBufTail+MAXRXBUFLEN-RxBufHead) % MAXRXBUFLEN)&#xA;#define IsRxBufEmpty() (RxBufHead==RxBufTail)&#xA;#define IsRxBufFull()  ((RxBufTail+1)%MAXRXBUFLEN==RxBufHead)&#xA;#define ClearRxBuf()   RxBufHead=RxBufTail=0&#xA;&#xA;BYTE RxBuf[MAXRXBUFLEN];&#xA;BYTE RxBufHead=0;&#xA;BYTE RxBufTail=0;&#xA;&#xA;BYTE GetRxBufByte(void)&#xA;{&#xA;    BYTE dat;&#xA;    dat=RxBuf[RxBufHead];&#xA;    RxBufHead++;&#xA;    RxBufHead%=MAXRXBUFLEN;&#xA;    return dat;&#xA;}&#xA;void DiscardRxBufBytes(BYTE count)&#xA;{&#xA;    RxBufHead+=count;&#xA;    RxBufHead%=MAXRXBUFLEN;&#xA;}&#xA;BYTE PeekRxBufByte(BYTE idx)&#xA;{&#xA;    BYTE tmpHead=RxBufHead;&#xA;    tmpHead+=idx;&#xA;    tmpHead%=MAXRXBUFLEN;&#xA;    return RxBuf[tmpHead];&#xA;}&#xA;void PutRxBufByte(BYTE dat)&#xA;{&#xA;    RxBuf[RxBufTail]=dat;&#xA;    RxBufTail++;&#xA;    RxBufTail%=MAXRXBUFLEN;&#xA;}&#xA;&#xA;//////////////////////////////////////////////////////////////////&#xA;//////////////// 队列处理 ///////////////////////////////////&#xA;//#define MAXRXBUFLEN (1024*20)&#xA;#define GetPrtclBufLen()  ((PrtclBufTail+MAXRXBUFLEN-PrtclBufHead) % MAXRXBUFLEN)&#xA;#define IsPrtclBufEmpty() (PrtclBufHead==PrtclBufTail)&#xA;#define IsPrtclBufFull()  ((PrtclBufTail+1)%MAXRXBUFLEN==PrtclBufHead)&#xA;#define ClearPrtclBuf()   PrtclBufHead=PrtclBufTail=0&#xA;&#xA;BYTE PrtclBuf[MAXRXBUFLEN];&#xA;BYTE PrtclBufHead=0;&#xA;BYTE PrtclBufTail=0;&#xA;&#xA;BYTE GetPrtclBufByte(void)&#xA;{&#xA;    BYTE dat;&#xA;    dat=PrtclBuf[PrtclBufHead];&#xA;    PrtclBufHead++;&#xA;    PrtclBufHead%=MAXRXBUFLEN;&#xA;    return dat;&#xA;}&#xA;void DiscardPrtclBufBytes(BYTE count)&#xA;{&#xA;    PrtclBufHead+=count;&#xA;    PrtclBufHead%=MAXRXBUFLEN;&#xA;}&#xA;BYTE PeekPrtclBufByte(BYTE idx)&#xA;{&#xA;    BYTE tmpHead=PrtclBufHead;&#xA;    tmpHead+=idx;&#xA;    tmpHead%=MAXRXBUFLEN;&#xA;    return PrtclBuf[tmpHead];&#xA;}&#xA;void PutPrtclBufByte(BYTE dat)&#xA;{&#xA;    PrtclBuf[PrtclBufTail]=dat;&#xA;    PrtclBufTail++;&#xA;    PrtclBufTail%=MAXRXBUFLEN;&#xA;}&#xA;&#xA;//////////////////////////////////////////////////////////////////&#xA;&#xA;&#xA;&#xA;&#xA;#define MAXCMDLEN 20&#xA;BYTE StationCmd[MAXCMDLEN];&#xA;BYTE StationCmdLen;&#xA;BYTE RepBuf[140];&#xA;&#xA;unsigned int  newId,newInterval;&#xA;&#xA;void ConsolePutArray(BYTE buf[],BYTE len)&#xA;{&#xA;    BYTE i;&#xA;    for(i=0; i&lt;len; i++)&#xA;        ;//   halPutch(buf[i]);&#xA;}&#xA;&#xA;&#xA;void ProgramData(void)// 查询单个团详细信息&#xA;{&#xA;    BYTE i,j;&#xA;    BYTE find;&#xA;    BYTE idx;&#xA;    BYTE cs;&#xA;    BYTE mbCount;&#xA;&#xA;    if(StationCmdLen!=1+4)&#xA;    {&#xA;        // return;&#xA;    }&#xA;    newId=StationCmd[1]+StationCmd[2]*256;&#xA;&#xA;}&#xA;&#xA;void ProcessStationCmd(void)&#xA;{&#xA;    if(StationCmdLen==0) return;&#xA;    switch(StationCmd[0])&#xA;    {&#xA;    case 0x08: // 查询工作状态            =[H]55 AA 02 FD 07 07 03&#xA;        ProgramData();&#xA;        break;&#xA;    case 0x09: // 查询工作状态            =[H]55 AA 02 FD 07 07 03&#xA;        ProgramData();&#xA;        break;&#xA;    default:&#xA;        break;&#xA;    }&#xA;}&#xA;&#xA;void EncodePrtclData(void)//包裹解码&#xA;{&#xA;    int i,j,len;&#xA;    BYTE cs;&#xA;    int id;&#xA;    int num,nd;&#xA;    char s[200],stmp[200];&#xA;    int tmp;&#xA;    len=PeekPrtclBufByte(3);&#xA;&#xA;    AddPrtclDetailNode(NULL,&quot;同步头&quot;,PrtclBufHead,2);&#xA;    GetPrtclBufByte();//丢弃一个字节; 55&#xA;    GetPrtclBufByte();//丢弃一个字节; aa&#xA;    AddPrtclDetailNode(NULL,&quot;地址&quot;,PrtclBufHead,1);&#xA;    GetPrtclBufByte();&#xA;    AddPrtclDetailNode(NULL,&quot;长度&quot;,PrtclBufHead,1);&#xA;    GetPrtclBufByte();//丢弃一个字节; len&#xA;    AddPrtclDetailNode(NULL,&quot;~长度&quot;,PrtclBufHead,1);&#xA;    GetPrtclBufByte();//丢弃一个字节; ~len&#xA;    AddPrtclDetailNode(NULL,&quot;读卡器地址&quot;,PrtclBufHead,1);&#xA;    GetPrtclBufByte();//丢弃一个字节; ~len&#xA;    AddPrtclDetailNode(NULL,&quot;流水号&quot;,PrtclBufHead,1);&#xA;    GetPrtclBufByte();//丢弃一个字节; ~len&#xA;    AddPrtclDetailNode(NULL,&quot;包裹长度&quot;,PrtclBufHead,1);&#xA;    GetPrtclBufByte();//丢弃一个字节; ~len&#xA;    AddPrtclDetailNode(NULL,&quot;命令字&quot;,PrtclBufHead,1);&#xA;    GetPrtclBufByte();//丢弃一个字节; ~len&#xA;    AddPrtclDetailNode(NULL,&quot;识别卡数量&quot;,PrtclBufHead,1);&#xA;    num=GetPrtclBufByte();//丢弃一个字节; ~len&#xA;    nd=AddPrtclDetailNode(NULL,&quot;卡号&quot;,PrtclBufHead,num*2);&#xA;&#xA;    i=0;&#xA;    //while(i&lt;num)&#xA;    {&#xA;        //AddPrtclDetailNode(nd,&quot;卡号&quot;,PrtclBufHead,2);&#xA;        tmp=PrtclBufHead; &#xA;        s[0]=0;&#xA;        for(j=0; j&lt;num; j++)&#xA;        {&#xA;            //if(i==num)break;&#xA;            id=GetPrtclBufByte();&#xA;            id=(id&lt;&lt;8)+GetPrtclBufByte();&#xA;            //sprintf(stmp,&quot;%s,%d&quot;,s,id);&#xA;            //sprintf(s,&quot;%s&quot;,stmp);              &#xA;            i++;&#xA;        }&#xA;        //printf(s);&#xA;       // AddPrtclDetailNode(nd,s,tmp,20);&#xA;    }&#xA;&#xA;    AddPrtclDetailNode(NULL,&quot;checksum&quot;,PrtclBufHead,1);&#xA;    GetPrtclBufByte(); //0x03&#xA;    return;&#xA;&#xA;    cs=0;&#xA;    for(i=0; i&lt;len-1; i++)&#xA;    {&#xA;        //printf(&quot;cs:%d,%02x&quot;,i,StationCmd[i]&amp;0xff);&#xA;        cs+=StationCmd[i];&#xA;    }&#xA;&#xA;    if(cs!=StationCmd[len-1])&#xA;    {&#xA;        //printf(&quot;check sum error:0x%02x---0x%02x!&quot;,cs,StationCmd[len-1]&amp;0xff);&#xA;        //return;&#xA;    }&#xA;    else&#xA;        printf(&quot;check sum success:%02x!&quot;,StationCmd[len-1]&amp;0xff);&#xA;&#xA;    //ConsolePutROMString((rom char *)&quot;接收到命令包:&quot;);&#xA;    //ConsolePutInitData(0,StationCmd[0]);&#xA;    StationCmdLen=len-1; //不包含校验位&#xA;    printf(&quot;Recv a command!&quot;);&#xA;    ProcessStationCmd();&#xA;&#xA;}&#xA;&#xA;&#xA;//通讯处理&#xA;void ProcessRxComm(void)&#xA;{&#xA;    BYTE len;&#xA;    while(GetRxBufLen()&gt;=7)&#xA;    {&#xA;        if(PeekRxBufByte(0)!=0x55)&#xA;        {&#xA;            DiscardRxBufBytes(1);&#xA;        }&#xA;        else if(PeekRxBufByte(1)!=0xaa)&#xA;        {&#xA;            DiscardRxBufBytes(1);&#xA;        }&#xA;        else if(PeekRxBufByte(3)+PeekRxBufByte(4)!=0xff)//长度、长度取反&#xA;        {&#xA;            DiscardRxBufBytes(1);&#xA;        }&#xA;        else&#xA;        {&#xA;            len=PeekRxBufByte(3);&#xA;            if(GetRxBufLen()&gt;=len+4)&#xA;            {&#xA;                AddPrtclDataNode(NULL,&quot;上报卡号&quot;,&amp;RxBuf[RxBufHead],len+4,0);&#xA;                DiscardRxBufBytes(len+4);&#xA;            }&#xA;            else&#xA;            {&#xA;                break;&#xA;            }&#xA;        }&#xA;    }	//while&#xA;}&#xA;&#xA;&#xA;&#xA;void ProcessPrtclData(void)&#xA;{&#xA;    BYTE len;&#xA;    while(GetPrtclBufLen()&gt;=7)&#xA;    {&#xA;        if(PeekPrtclBufByte(0)!=0x55)&#xA;        {&#xA;            DiscardPrtclBufBytes(1);&#xA;        }&#xA;        else if(PeekPrtclBufByte(1)!=0xaa)&#xA;        {&#xA;            DiscardPrtclBufBytes(1);&#xA;        }&#xA;        else if(PeekPrtclBufByte(3)+PeekPrtclBufByte(4)!=0xff)//长度、长度取反&#xA;        {&#xA;            DiscardPrtclBufBytes(1);&#xA;        }&#xA;        else&#xA;        {&#xA;            len=PeekPrtclBufByte(3);&#xA;            if(GetPrtclBufLen()&gt;=len+4)&#xA;            {&#xA;&#xA;                EncodePrtclData();&#xA;&#xA;            }&#xA;            else&#xA;            {&#xA;                break;&#xA;            }&#xA;        }&#xA;    }	//while&#xA;}&#xA;&#xA;&#xA;//////////////////////////////////////////////////////////////////////&#xA;&#xA;void RecvSerialData(char *buf,int count)&#xA;{&#xA;    int i;&#xA;    for(i=0; i&lt;count; i++)&#xA;    {&#xA;        PutRxBufByte(buf[i]);&#xA;    }&#xA;    //printf(&quot;RecvSerialData,len(%d)&quot;,count);&#xA;    ProcessRxComm();&#xA;&#xA;}&#xA;void AnaProtocolData(char *buf,int count)&#xA;{&#xA;    int node;&#xA;    int i;&#xA;    //printf(&quot;AnaProtocolData,len(%d) &quot;,count );&#xA;    ClearPrtclBuf();&#xA;    for(i=0; i&lt;count; i++)&#xA;        PutPrtclBufByte(buf[i]);&#xA;    ProcessPrtclData();&#xA;&#xA;}&#xA;&#xA;void click(int btn)&#xA;{&#xA;    char s0[]= {0x55 ,0xAA ,0x04 ,0xFb ,0x01 ,0x02 ,0x03 ,0x06 ,0x03};&#xA;    char s1[]= {0x55 ,0xAA ,0x04 ,0xFb ,0x02 ,0x02 ,0xf3 ,0xf7 ,0x03};&#xA;char *s2=&quot;  55 AA 00 A7 58 03 06 A2 01 50 &#xA;00 0B 00 07 4F 68 03 FD 00 27 00 1D 00 9B 00 5D 00 03 00 0A &#xA;00 17 00 09 00 53 00 3F 02 9A 00 23 08 98 00 20 00 34 00 33 &#xA;09 3B 00 15 00 39 00 4B 00 66 66 01 00 49 00 44 00 46 00 11 &#xA;00 01 21 70 04 0C 00 58 00 32 00 61 0B CC 00 38 00 67 00 3C &#xA;00 42 00 26 00 3A 22 B8 04 09 00 60 00 5B 00 24 59 E0 00 45 &#xA;00 4C 00 4E 00 62 00 6C 00 1F 00 69 65 FD 1F E8 00 6B 00 0C &#xA;66 0B 00 1C 00 47 00 3D 00 57 00 10 00 6A 00 02 1E 02 00 89 &#xA;00 55 53 FD 50 E4 00 64 04 02 00 06 00 50 00 5F 66 2F 00 59 &#xA;65&quot;;&#xA;    //SendHexString(s);&#xA;    SendHexString(s2,sizeof(s2));&#xA;    //RecvSerialData(s1,sizeof(s1));&#xA;};&#xA;&#xA;&#xA;&#xA;void main()&#xA;{&#xA;    int i;&#xA;    int btn;&#xA;    int node;&#xA;    char s[100];&#xA;    ShowProtocolWin();&#xA;    ClearVclControls();&#xA;&#xA;    //ShowOutputWin(300);&#xA;    ShowVclWin(150);&#xA;    int p=GetGuiWin(0);&#xA;    for(  i=0; i&lt;2; i++)&#xA;    {&#xA;        sprintf(s,&quot;按钮:%d&quot;,i);&#xA;        btn=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,s,&quot;left&quot;,10+i*70,&quot;top&quot;,30,&quot;width&quot;,65,&quot;onclick&quot;,click,NULL);//创建按钮&#xA;    }&#xA;&#xA;    ClearProtocolTree();&#xA;    click(0);&#xA;};&#xA;"/>
      <Command cmdname="协议解析程序1" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;&#xA;//////////////// 接收队列处理 ///////////////////////////////////&#xA;#define MAXRXBUFLEN (1024*20)&#xA;#define GetRxBufLen()  ((RxBufTail+MAXRXBUFLEN-RxBufHead) % MAXRXBUFLEN)&#xA;#define IsRxBufEmpty() (RxBufHead==RxBufTail)&#xA;#define IsRxBufFull()  ((RxBufTail+1)%MAXRXBUFLEN==RxBufHead)&#xA;#define ClearRxBuf()   RxBufHead=RxBufTail=0&#xA;&#xA;BYTE RxBuf[MAXRXBUFLEN];&#xA;BYTE RxBufHead=0;&#xA;BYTE RxBufTail=0;&#xA;&#xA;BYTE GetRxBufByte(void)&#xA;{&#xA;    BYTE dat;&#xA;    dat=RxBuf[RxBufHead];&#xA;    RxBufHead++;&#xA;    RxBufHead%=MAXRXBUFLEN;&#xA;    return dat;&#xA;}&#xA;void DiscardRxBufBytes(BYTE count)&#xA;{&#xA;    RxBufHead+=count;&#xA;    RxBufHead%=MAXRXBUFLEN;&#xA;}&#xA;BYTE PeekRxBufByte(BYTE idx)&#xA;{&#xA;    BYTE tmpHead=RxBufHead;&#xA;    tmpHead+=idx;&#xA;    tmpHead%=MAXRXBUFLEN;&#xA;    return RxBuf[tmpHead];&#xA;}&#xA;void PutRxBufByte(BYTE dat)&#xA;{&#xA;    RxBuf[RxBufTail]=dat;&#xA;    RxBufTail++;&#xA;    RxBufTail%=MAXRXBUFLEN;&#xA;}&#xA;&#xA;//////////////////////////////////////////////////////////////////&#xA;//////////////// 队列处理 ///////////////////////////////////&#xA;//#define MAXRXBUFLEN (1024*20)&#xA;#define GetPrtclBufLen()  ((PrtclBufTail+MAXRXBUFLEN-PrtclBufHead) % MAXRXBUFLEN)&#xA;#define IsPrtclBufEmpty() (PrtclBufHead==PrtclBufTail)&#xA;#define IsPrtclBufFull()  ((PrtclBufTail+1)%MAXRXBUFLEN==PrtclBufHead)&#xA;#define ClearPrtclBuf()   PrtclBufHead=PrtclBufTail=0&#xA;&#xA;BYTE PrtclBuf[MAXRXBUFLEN];&#xA;BYTE PrtclBufHead=0;&#xA;BYTE PrtclBufTail=0;&#xA;&#xA;BYTE GetPrtclBufByte(void)&#xA;{&#xA;    BYTE dat;&#xA;    dat=PrtclBuf[PrtclBufHead];&#xA;    PrtclBufHead++;&#xA;    PrtclBufHead%=MAXRXBUFLEN;&#xA;    return dat;&#xA;}&#xA;void DiscardPrtclBufBytes(BYTE count)&#xA;{&#xA;    PrtclBufHead+=count;&#xA;    PrtclBufHead%=MAXRXBUFLEN;&#xA;}&#xA;BYTE PeekPrtclBufByte(BYTE idx)&#xA;{&#xA;    BYTE tmpHead=PrtclBufHead;&#xA;    tmpHead+=idx;&#xA;    tmpHead%=MAXRXBUFLEN;&#xA;    return PrtclBuf[tmpHead];&#xA;}&#xA;void PutPrtclBufByte(BYTE dat)&#xA;{&#xA;    PrtclBuf[PrtclBufTail]=dat;&#xA;    PrtclBufTail++;&#xA;    PrtclBufTail%=MAXRXBUFLEN;&#xA;}&#xA;&#xA;//////////////////////////////////////////////////////////////////&#xA;&#xA;&#xA;&#xA;&#xA;#define MAXCMDLEN 20&#xA;BYTE StationCmd[MAXCMDLEN];&#xA;BYTE StationCmdLen;&#xA;BYTE RepBuf[140];&#xA;&#xA;unsigned int  newId,newInterval;&#xA;&#xA;void ConsolePutArray(BYTE buf[],BYTE len)&#xA;{&#xA;    BYTE i;&#xA;    for(i=0; i&lt;len; i++)&#xA;        ;//   halPutch(buf[i]);&#xA;}&#xA;&#xA;&#xA;void ProgramData(void)// 查询单个团详细信息&#xA;{&#xA;    BYTE i,j;&#xA;    BYTE find;&#xA;    BYTE idx;&#xA;    BYTE cs;&#xA;    BYTE mbCount;&#xA;&#xA;    if(StationCmdLen!=1+4)&#xA;    {&#xA;        // return;&#xA;    }&#xA;    newId=StationCmd[1]+StationCmd[2]*256;&#xA;&#xA;}&#xA;&#xA;void ProcessStationCmd(void)&#xA;{&#xA;    if(StationCmdLen==0) return;&#xA;    switch(StationCmd[0])&#xA;    {&#xA;    case 0x08: // 查询工作状态            =[H]55 AA 02 FD 07 07 03&#xA;        ProgramData();&#xA;        break;&#xA;    case 0x09: // 查询工作状态            =[H]55 AA 02 FD 07 07 03&#xA;        ProgramData();&#xA;        break;&#xA;    default:&#xA;        break;&#xA;    }&#xA;}&#xA;&#xA;void EncodePrtclData(void)//包裹解码&#xA;{&#xA;    BYTE i,len;&#xA;    BYTE cs;&#xA;    len=PeekPrtclBufByte(2);&#xA;    if(len&gt;MAXCMDLEN)&#xA;    {&#xA;        StationCmd[0]=PeekPrtclBufByte(4);&#xA;        for(i=0; i&lt;=4+len; i++)&#xA;            GetPrtclBufByte();//丢弃一个字节;&#xA;        return ;&#xA;    }&#xA;    AddPrtclDetailNode(NULL,&quot;同步头&quot;,PrtclBufHead,2);&#xA;    GetPrtclBufByte();//丢弃一个字节; 55&#xA;    GetPrtclBufByte();//丢弃一个字节; aa&#xA;    AddPrtclDetailNode(NULL,&quot;长度&quot;,PrtclBufHead,1);&#xA;&#xA;    GetPrtclBufByte();//丢弃一个字节; len&#xA;    AddPrtclDetailNode(NULL,&quot;~长度&quot;,PrtclBufHead,1);&#xA;    GetPrtclBufByte();//丢弃一个字节; ~len&#xA;&#xA;    AddPrtclDetailNode(NULL,&quot;data&quot;,PrtclBufHead,len);&#xA;&#xA;    for(i=0; i&lt;len; i++)&#xA;        StationCmd[i]=GetPrtclBufByte();&#xA;    GetPrtclBufByte(); //0x03&#xA;&#xA;    cs=0;&#xA;    for(i=0; i&lt;len-1; i++)&#xA;    {&#xA;        printf(&quot;cs:%d,%02x&quot;,i,StationCmd[i]&amp;0xff);&#xA;        cs+=StationCmd[i];&#xA;    }&#xA;&#xA;    if(cs!=StationCmd[len-1])&#xA;    {&#xA;        printf(&quot;check sum error:0x%02x---0x%02x!&quot;,cs,StationCmd[len-1]&amp;0xff);&#xA;        //return;&#xA;    }&#xA;    else&#xA;        printf(&quot;check sum success:%02x!&quot;,StationCmd[len-1]&amp;0xff);&#xA;&#xA;    //ConsolePutROMString((rom char *)&quot;接收到命令包:&quot;);&#xA;    //ConsolePutInitData(0,StationCmd[0]);&#xA;    StationCmdLen=len-1; //不包含校验位&#xA;    printf(&quot;Recv a command!&quot;);&#xA;    ProcessStationCmd();&#xA;&#xA;}&#xA;&#xA;&#xA;//通讯处理&#xA;void ProcessRxComm(void)&#xA;{&#xA;    BYTE len;&#xA;    while(GetRxBufLen()&gt;=7)&#xA;    {&#xA;        if(PeekRxBufByte(0)!=0x55)&#xA;        {&#xA;            DiscardRxBufBytes(1);&#xA;        }&#xA;        else if(PeekRxBufByte(1)!=0xaa)&#xA;        {&#xA;            DiscardRxBufBytes(2);&#xA;        }&#xA;        else if(PeekRxBufByte(2)+PeekRxBufByte(3)!=0xff)//长度、长度取反&#xA;        {&#xA;            DiscardRxBufBytes(4);&#xA;        }&#xA;        else&#xA;        {&#xA;            len=PeekRxBufByte(2);&#xA;            if(len&gt;MAXCMDLEN)  //命令过长&#xA;            {&#xA;                DiscardRxBufBytes(4);&#xA;            }&#xA;            else if(GetRxBufLen()&gt;len+4)&#xA;            {&#xA;                if(PeekRxBufByte(4+len)!=0x03)//结束字符&#xA;                {&#xA;                    DiscardRxBufBytes(1);&#xA;                }&#xA;                else&#xA;                {&#xA;                    if(RxBuf[RxBufHead+4]==0x01)&#xA;                        AddPrtclDataNode(NULL,&quot;版本号查询&quot;,&amp;RxBuf[RxBufHead],len+5,0);&#xA;                    else if(RxBuf[RxBufHead+4]==0x02)&#xA;                        AddPrtclDataNode(NULL,&quot;读序列号&quot;,&amp;RxBuf[RxBufHead],len+5,0);&#xA;                    else if(RxBuf[RxBufHead+4]==0x03)&#xA;                        AddPrtclDataNode(NULL,&quot;控制继电器&quot;,&amp;RxBuf[RxBufHead],len+5,0);&#xA;                    DiscardRxBufBytes(len+5);&#xA;&#xA;                }&#xA;            }&#xA;            else&#xA;            {&#xA;                break;&#xA;            }&#xA;        }&#xA;    }	//while&#xA;}&#xA;&#xA;&#xA;&#xA;void ProcessPrtclData(void)&#xA;{&#xA;    BYTE len;&#xA;    while(GetPrtclBufLen()&gt;=7)&#xA;    {&#xA;        if(PeekPrtclBufByte(0)!=0x55)&#xA;        {&#xA;            DiscardPrtclBufBytes(1);&#xA;        }&#xA;        else if(PeekPrtclBufByte(1)!=0xaa)&#xA;        {&#xA;            DiscardPrtclBufBytes(2);&#xA;        }&#xA;        else if(PeekPrtclBufByte(2)+PeekPrtclBufByte(3)!=0xff)//长度、长度取反&#xA;        {&#xA;            DiscardPrtclBufBytes(4);&#xA;        }&#xA;        else&#xA;        {&#xA;            len=PeekPrtclBufByte(2);&#xA;            if(len&gt;MAXCMDLEN)  //命令过长&#xA;            {&#xA;                DiscardPrtclBufBytes(4);&#xA;            }&#xA;            else if(GetPrtclBufLen()&gt;len+4)&#xA;            {&#xA;                if(PeekPrtclBufByte(4+len)!=0x03)//结束字符&#xA;                {&#xA;                    DiscardPrtclBufBytes(1);&#xA;                }&#xA;                else&#xA;                {&#xA;                    EncodePrtclData();&#xA;                }&#xA;            }&#xA;            else&#xA;            {&#xA;                break;&#xA;            }&#xA;        }&#xA;    }	//while&#xA;}&#xA;&#xA;&#xA;//////////////////////////////////////////////////////////////////////&#xA;&#xA;void RecvSerialData(char *buf,int count)&#xA;{&#xA;    int i;&#xA;    for(i=0; i&lt;count; i++)&#xA;    {&#xA;        PutRxBufByte(buf[i]);&#xA;    }&#xA;    printf(&quot;RecvSerialData,len(%d)&quot;,count);&#xA;    ProcessRxComm();&#xA;&#xA;}&#xA;void AnaProtocolData(char *buf,int count)&#xA;{&#xA;    int node;&#xA;    int i;&#xA;    printf(&quot;AnaProtocolData,len(%d) &quot;,count );&#xA;    ClearPrtclBuf();&#xA;    for(i=0; i&lt;count; i++)&#xA;        PutPrtclBufByte(buf[i]);&#xA;    ProcessPrtclData();&#xA;&#xA;}&#xA;&#xA;void click(int btn)&#xA;{&#xA;    char s0[]= {0x55 ,0xAA ,0x04 ,0xFb ,0x01 ,0x02 ,0x03 ,0x06 ,0x03};&#xA;    char s1[]= {0x55 ,0xAA ,0x04 ,0xFb ,0x02 ,0x02 ,0xf3 ,0xf7 ,0x03};&#xA;    //SendHexString(s);&#xA;    RecvSerialData(s0,sizeof(s0));&#xA;    RecvSerialData(s1,sizeof(s1));&#xA;};&#xA;&#xA;&#xA;&#xA;void main()&#xA;{&#xA;    int i;&#xA;    int btn;&#xA;    int node;&#xA;    char s[100];&#xA;    ShowProtocolWin();&#xA;    ClearVclControls();&#xA;&#xA;    //ShowOutputWin(300);&#xA;    ShowVclWin(150);&#xA;    int p=GetGuiWin(1);&#xA;    for(  i=0; i&lt;2; i++)&#xA;    {&#xA;        sprintf(s,&quot;按钮:%d&quot;,i);&#xA;        btn=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,s,&quot;left&quot;,10+i*70,&quot;top&quot;,30,&quot;width&quot;,65,&quot;onclick&quot;,click,NULL);//创建按钮&#xA;    }&#xA;&#xA;    ClearProtocolTree();&#xA;    click(0);&#xA;};&#xA;"/>
      <Command cmdname="协议测试命令(通过串口回环模式)" cmdType="H" cmd="[H]55 AA 04 Fb 01 02 03 07 03"/>
    </Command>
    <Command cmdname="通讯数据分析" cmdType="S" cmd="[S]new command">
      <Command cmdname="以太网数据分析" cmdType="P" cmd="[P] &#xA;&#xA;void main()&#xA;{&#xA;    ClearOutputWin();   //清除输出窗口内容&#xA;    ClearVclControls();&#xA;    ShowVclWin(160);&#xA;    ShowOutputWin(-1);&#xA;    HideLeftTools();&#xA;};&#xA;&#xA;&#xA;void CapTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件&#xA;{&#xA;    int node;&#xA;    int i,j,k;&#xA;    char s[1024];&#xA;    char tm[62],tmp[62];&#xA;    int fd;&#xA;    printf(&quot;cap tcp data:%x,%d,%x,%d,%s&quot;,srcIp,srcPort,dstIp,dstPort,buf);&#xA;    if(dstPort!=80) return;&#xA;&#xA;    if(strstr(buf,&quot;passw&quot;)!=0)&#xA;    {&#xA;        char *p=strstr(buf,&quot;passw&quot;);&#xA;        printf(&quot;find:%s&quot;,p);&#xA;    }&#xA;    else&#xA;    {&#xA;        return;&#xA;    }&#xA;}&#xA;void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件&#xA;{&#xA;    int node;&#xA;    int i,j,k;&#xA;    char s[1024];&#xA;    char tm[62],tmp[62];&#xA;    int fd;&#xA;    printf(&quot;cap udp data:%x,%d,%x,%d,%s&quot;,srcIp,srcPort,dstIp,dstPort,buf);&#xA;    if(dstPort!=80) return;&#xA;&#xA;    if(strstr(buf,&quot;passw&quot;)!=0)&#xA;    {&#xA;        char *p=strstr(buf,&quot;passw&quot;);&#xA;        printf(&quot;find:%s&quot;,p);&#xA;    }&#xA;    else&#xA;    {&#xA;        return;&#xA;    }&#xA;}&#xA;&#xA;&#xA;void RecvTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件&#xA;{&#xA;    int node;&#xA;    int i,j,k;&#xA;    char s[1024];&#xA;    char tm[62],tmp[62];&#xA;    int fd;&#xA;    printf(&quot;recv tcp data:%x,%d,%x,%d,%s&quot;,srcIp,srcPort,dstIp,dstPort,buf);&#xA;    if(dstPort!=80) return;&#xA;&#xA;    if(strstr(buf,&quot;passw&quot;)!=0)&#xA;    {&#xA;        char *p=strstr(buf,&quot;passw&quot;);&#xA;        printf(&quot;find:%s&quot;,p);&#xA;    }&#xA;    else&#xA;    {&#xA;        return;&#xA;    }&#xA;}&#xA;void RecvUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件&#xA;{&#xA;    int node;&#xA;    int i,j,k;&#xA;    char s[1024];&#xA;    char tm[62],tmp[62];&#xA;    int fd;&#xA;    printf(&quot;recv udp data:%x,%d,%x,%d,%s&quot;,srcIp,srcPort,dstIp,dstPort,buf);&#xA;    if(dstPort!=80) return;&#xA;&#xA;    if(strstr(buf,&quot;passw&quot;)!=0)&#xA;    {&#xA;        char *p=strstr(buf,&quot;passw&quot;);&#xA;        printf(&quot;find:%s&quot;,p);&#xA;    }&#xA;    else&#xA;    {&#xA;        return;&#xA;    }&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;"/>
      <Command cmdname="通讯数据分析" cmdType="P" cmd="[P] &#xA;&#xA;void main()&#xA;{&#xA;    ClearOutputWin();   //清除输出窗口内容&#xA;    ClearVclControls();&#xA;    ShowVclWin(160);&#xA;    ShowOutputWin(-1);&#xA;    HideLeftTools();&#xA;};&#xA;&#xA;&#xA;void CapSerialData(unsigned int ComNum,int RdWt,unsigned char *buf,int count)//串口捕获数据事件&#xA;{&#xA;    int node;&#xA;    int i,j,k;&#xA;    char s[1024];&#xA;    char tm[62],tmp[62];&#xA;    int fd;&#xA;    printf(&quot;cap serial data:COM%d,RdWt:%d,%s&quot;,ComNum,RdWt,buf);&#xA;&#xA;}&#xA;void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件&#xA;{&#xA;    int node;&#xA;    int i,j,k;&#xA;    char s[1024];&#xA;    char tm[62],tmp[62];&#xA;    int fd;&#xA;    printf(&quot;cap udp data:%x,%d,%x,%d,%s&quot;,srcIp,srcPort,dstIp,dstPort,buf);&#xA;    &#xA;}&#xA;void CapTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件&#xA;{&#xA;    int node;&#xA;    int i,j,k;&#xA;    char s[1024];&#xA;    char tm[62],tmp[62];&#xA;    int fd;&#xA;    printf(&quot;cap tcp data:%x,%d,%x,%d,%s&quot;,srcIp,srcPort,dstIp,dstPort,buf);&#xA;    &#xA;}&#xA;&#xA;void RecvTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件&#xA;{&#xA;    int node;&#xA;    int i,j,k;&#xA;    char s[1024];&#xA;    char tm[62],tmp[62];&#xA;    int fd;&#xA;    printf(&quot;recv tcp data:%x,%d,%x,%d,%s&quot;,srcIp,srcPort,dstIp,dstPort,buf);&#xA;   &#xA;}&#xA;void RecvUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件&#xA;{&#xA;    int node;&#xA;    int i,j,k;&#xA;    char s[1024];&#xA;    char tm[62],tmp[62];&#xA;    int fd;&#xA;    printf(&quot;recv udp data:%x,%d,%x,%d,%s&quot;,srcIp,srcPort,dstIp,dstPort,buf);&#xA;    &#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;"/>
      <Command cmdname="通讯数据脚本分析" cmdType="P" cmd="[P]&#xA;void main()&#xA;{&#xA;    ClearOutputWin();   //清除输出窗口内容&#xA;    ClearVclControls();&#xA;    ShowVclWin(160);&#xA;    ShowOutputWin(-1);&#xA;    HideLeftTools();&#xA;};&#xA;void RecvSerialData(unsigned char *buf,int count)//串口接收到数据&#xA;{&#xA;    printf(&quot;Recv serial data,len-%d;%s&quot;,count,buf);&#xA;}&#xA;&#xA;void CapSerialData(unsigned int ComNum,int RdWt,unsigned char *buf,int count)//串口捕获数据事件&#xA;{&#xA;    printf(&quot;cap serial data:COM%d,RdWt:%d,len-%d;%s&quot;,ComNum,RdWt,count,buf);&#xA;}&#xA;&#xA;void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓取到数据包&#xA;{&#xA;    printf(&quot;cap udp data:%x,%d,%x,%d,len-%d;%s&quot;,srcIp,srcPort,dstIp,dstPort,count,buf);&#xA;}&#xA;&#xA;void CapTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//TCP抓取到数据包&#xA;{&#xA;    printf(&quot;cap tcp data:%x,%d,%x,%d,len-%d;%s&quot;,srcIp,srcPort,dstIp,dstPort,count,buf);&#xA;}&#xA;&#xA;void RecvTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//TCP接收到数据&#xA;{&#xA;&#xA;    printf(&quot;recv tcp data:%x,%d,%x,%d,len-%d;%s&quot;,srcIp,srcPort,dstIp,dstPort,count,buf);&#xA;&#xA;}&#xA;void RecvUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP接收到数据&#xA;{&#xA;    printf(&quot;recv udp data:%x,%d,%x,%d,len-%d;%s&quot;,srcIp,srcPort,dstIp,dstPort,count,buf);&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;"/>
    </Command>
  </Command>
  <Command cmdname="数据示波器" cmdType="P" cmd="[P]#pragma comment(lib,&quot;lib\\oscilloscope.o&quot;)&#xA;#pragma comment(lib,&quot;lib\\ftgl.def&quot;);&#xA;void RecvSerialData(unsigned char *buf,int count)//串口接收到数?&#xA;{&#xA;    int i;&#xA;    //for(i=0; i&lt;count; i++)&#xA;    //    AddWaveDataByte(0,buf[i]);&#xA;    AddWaveDataBuf(0,buf,count);&#xA;}&#xA;void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件&#xA;{&#xA;    AddWaveDataBuf(0,buf,count);&#xA;}&#xA;&#xA;void CapTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件&#xA;{&#xA;    AddWaveDataBuf(0,buf,count);&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;"/>
  <Command cmdname="逐行发送" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;int edt1;&#xA;int cbHex;&#xA;int cbx1,cbx2;&#xA;int tmr1;&#xA;int btn0,btn1,btn2;&#xA;int curLineIdx=0;&#xA;void OnClose(int *sender)&#xA;{&#xA;    HideVclWin();&#xA;    CloseVclWin();&#xA;&#xA;}&#xA;void OnStart(void *sender)&#xA;{&#xA;    char s[200];&#xA;    curLineIdx=0;&#xA;    GetProperty(cbx1,&quot;text&quot;,s,20);&#xA;    int inv=atoi(s);&#xA;    printf(&quot;%d&quot;,inv);&#xA;    SetProperty(tmr1,&quot;interval&quot;,inv);&#xA;    SetProperty(tmr1,&quot;enabled&quot;,1);&#xA;    SetProperty(btn1,&quot;enabled&quot;,0);&#xA;    SetProperty(btn2,&quot;enabled&quot;,1);&#xA;&#xA;}&#xA;void OnStop()&#xA;{&#xA;    SetProperty(tmr1,&quot;enabled&quot;,0);&#xA;    SetProperty(btn1,&quot;enabled&quot;,1);&#xA;    SetProperty(btn2,&quot;enabled&quot;,0);&#xA;&#xA;}&#xA;int GetLineStr(char *buf,int size,int idx)&#xA;{&#xA;    int count;&#xA;    int i;&#xA;    count=GetInputWinLineCount();&#xA;    if(idx&gt;=count) return -1;&#xA;    GetInputWinLineStr(buf,size,idx);&#xA;}&#xA;void OnTimer()&#xA;{&#xA;    char s[200],s1[202];&#xA;    int ck;&#xA;    int cr;&#xA;    ck=GetProperty(cbHex,&quot;checked&quot;,s,4);&#xA;    if(GetLineStr(s,200,curLineIdx)&lt;0)&#xA;    {&#xA;        OnStop();&#xA;        return;&#xA;    }&#xA;    SetProperty(edt1,&quot;text&quot;,s);&#xA;    printf(&quot;Send:%s&quot;,s);&#xA;    curLineIdx++;&#xA;&#xA;&#xA;    if(ck==1)&#xA;    {&#xA;        SendHexString(s);&#xA;    }&#xA;    else&#xA;    {&#xA;        cr=GetProperty(cbx2,&quot;itemindex&quot;,0,0);&#xA;        if(cr==0)&#xA;            sprintf(s1,&quot;%s&quot;,s);&#xA;        else if(cr==1)&#xA;            sprintf(s1,&quot;%s\r&quot;,s);&#xA;        else if(cr==2)&#xA;            sprintf(s1,&quot;%s\n&quot;,s);&#xA;        else if(cr==3)&#xA;            sprintf(s1,&quot;%s\r\n&quot;,s);&#xA;        else if(cr==4)&#xA;            sprintf(s1,&quot;%s\n\r&quot;,s);&#xA;        SendString(s1);&#xA;    }&#xA;}&#xA;&#xA;void main()&#xA;{&#xA;    ClearOutputWin();   //清除输出窗口内容&#xA;    ClearCommWin();&#xA;    //CloseInputWin();&#xA;    CloseCodeWin();//&#xA;    HideLeftTools();&#xA;    HideRightTools();&#xA;    HideOutputWin();&#xA;    ClearVclControls();&#xA;    int p=GetGuiWin(0);&#xA;&#xA;    btn0=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,     &quot;left&quot;,230,&quot;top&quot;,70,&quot;width&quot;,100,&quot;height&quot;,30,&quot;onclick&quot;,OnClose,NULL);//创建按钮&#xA;    btn1=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;开始发送&quot;, &quot;left&quot;,10,&quot;top&quot;,70,&quot;width&quot;,100,&quot;height&quot;,30,&quot;onclick&quot;,OnStart,NULL);//创建按钮&#xA;    btn2=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;停止发送&quot;, &quot;left&quot;,120,&quot;top&quot;,70,&quot;width&quot;,100,&quot;height&quot;,30,&quot;onclick&quot;,OnStop,NULL);//创建按钮&#xA;    int lbl1=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;发送内容:&quot;,&quot;left&quot;,10,&quot;top&quot;,8,&quot;width&quot;,90,&quot;height&quot;,20,NULL);//创建按钮&#xA;    edt1=CreateComponentEx(p,&quot;edit&quot;,  &quot;text&quot;,   &quot;...&quot;,   &quot;left&quot;,70,&quot;top&quot;,5,&quot;width&quot;,360,&quot;height&quot;,20,&quot;enabled&quot;,0,NULL);//创建按钮&#xA;    cbHex=CreateComponentEx(p,&quot;checkbox&quot;,&quot;caption&quot;,&quot;十六进制发送&quot;,&quot;left&quot;,10,&quot;top&quot;,35,&quot;width&quot;,100,&quot;height&quot;,20,NULL);//创建按钮&#xA;    int lbl2=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;发送间隔:&quot;,&quot;left&quot;,145,&quot;top&quot;,37,&quot;width&quot;,70,&quot;height&quot;,20,NULL);//创建按钮&#xA;    cbx1=CreateComponentEx(p,&quot;combobox&quot;,&quot;text&quot;,&quot;200&quot;,&quot;left&quot;,203,&quot;top&quot;,35,&quot;width&quot;,60,&quot;height&quot;,20,NULL);//创建按钮&#xA;    int lbl3=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;毫秒&quot;,&quot;left&quot;,270,&quot;top&quot;,37,&quot;width&quot;,70,&quot;height&quot;,20,NULL);//创建按钮&#xA;    CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;换行:&quot;,&quot;left&quot;,330,&quot;top&quot;,37,&quot;width&quot;,80,&quot;height&quot;,20,NULL);//创建按钮&#xA;    cbx2=CreateComponentEx(p,&quot;combobox&quot;,&quot;left&quot;,360,&quot;top&quot;,35,&quot;width&quot;,70,&quot;height&quot;,20,&quot;style&quot;,&quot;csdropdownlist&quot;,&quot;itemindex&quot;,2,NULL);//创建按钮&#xA;&#xA;&#xA;&#xA;    tmr1=CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,500,&quot;enabled&quot;,0,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮&#xA;&#xA;    StringsAdd(cbx1,&quot;1&quot;);&#xA;    StringsAdd(cbx1,&quot;100&quot;);&#xA;    StringsAdd(cbx1,&quot;200&quot;);&#xA;    StringsAdd(cbx1,&quot;500&quot;);&#xA;    StringsAdd(cbx1,&quot;1000&quot;);&#xA;    StringsAdd(cbx2,&quot;无&quot;);&#xA;    StringsAdd(cbx2,&quot;回车&quot;);&#xA;    StringsAdd(cbx2,&quot;换行&quot;);    &#xA;    StringsAdd(cbx2,&quot;回车换行&quot;);&#xA;    StringsAdd(cbx2,&quot;换行回车&quot;);&#xA;    SetProperty(cbx2,&quot;itemindex&quot;,3);&#xA;&#xA;&#xA;    AutoSetVclWinSize();&#xA;}"/>
  <Command cmdname="常用数据校验算法工具" cmdType="P" cmd="[P]&#xA;&#xA;#define UINT32 unsigned int&#xA;#define UINT unsigned int&#xA;#define UCHAR unsigned char&#xA;#define UINT16 unsigned short&#xA;#define  USHORT unsigned short&#xA;#define BOOL  unsigned char&#xA;#define FALSE 0&#xA;#define TRUE 1&#xA;#define ULONG  unsigned long&#xA;//======================================================================================&#xA;&#xA;//                                       校验和&#xA;&#xA;//======================================================================================&#xA;&#xA;/******************************************************&#xA;*函数名称:CheckSum8&#xA;*输   入:buf 要校验的数据&#xA;        len 校验数据的长&#xA;*输   出:校验和&#xA;*功   能:校验和-8&#xA;*******************************************************/&#xA;UCHAR CheckSum8(UCHAR *buf,UINT len)&#xA;{&#xA;    UINT    i=0;&#xA;    UCHAR Sum=0;&#xA;&#xA;    for (i=0; i&lt;len; i++)&#xA;    {&#xA;        Sum+=*buf++;&#xA;    }&#xA;&#xA;    return Sum;&#xA;}&#xA;/******************************************************&#xA;*函数名称:CheckSumSum16&#xA;*输   入:buf 要校验的数据&#xA;        len 校验数据的长&#xA;*输   出:校验和&#xA;*功   能:校验和-16&#xA;*******************************************************/&#xA;UINT16 CheckSum16(UCHAR *buf,UINT len)&#xA;{&#xA;    UINT    i=0;&#xA;    UINT16 Sum=0;&#xA;&#xA;    for (i=0; i&lt;len; i++)&#xA;    {&#xA;        Sum+=*buf++;&#xA;    }&#xA;&#xA;    return Sum;&#xA;}&#xA;/******************************************************&#xA;*函数名称:CheckSum32&#xA;*输   入:buf 要校验的数据&#xA;        len 校验数据的长&#xA;*输   出:校验和&#xA;*功   能:校验和-32&#xA;*******************************************************/&#xA;UINT32 CheckSum32(UCHAR *buf,UINT len)&#xA;{&#xA;    UINT    i=0;&#xA;    UINT32 Sum=0;&#xA;&#xA;    for (i=0; i&lt;len; i++)&#xA;    {&#xA;        Sum+=*buf++;&#xA;    }&#xA;&#xA;    return Sum;&#xA;}&#xA;&#xA;/******************************************************&#xA;*函数名称:IntelHexCheckSum&#xA;*输   入:buf 要校验的数据&#xA;        len 校验数据的长&#xA;*输   出:校验和&#xA;*功   能:校验和-Intel Hex&#xA;*******************************************************/&#xA;UCHAR IntelHexCheckSum(UCHAR *buf,UINT len)&#xA;{&#xA;    UCHAR Sum;&#xA;&#xA;    Sum=CheckSum8(buf,len);&#xA;    Sum=0x01+(UCHAR)(~Sum);&#xA;&#xA;    return Sum;&#xA;}&#xA;/******************************************************&#xA;*函数名称:NetCheckSum&#xA;*输   入:buf 要校验的数据&#xA;        len 校验数据的长&#xA;*输   出:校验和&#xA;*功   能:校验和-TCP/IP&#xA;*******************************************************/&#xA;USHORT NetCheckSum(UCHAR *buf, UINT len)&#xA;{&#xA;    UINT   Sum=0;&#xA;&#xA;    while(len--)&#xA;    {&#xA;        Sum+=*buf++;&#xA;    }&#xA;&#xA;    Sum=  (Sum&gt;&gt; 16)   +   (Sum&amp;   0xffff);&#xA;    Sum+= (Sum&gt;&gt; 16);&#xA;&#xA;    return   (USHORT)(~Sum);&#xA;}&#xA;/******************************************************&#xA;*函数名称:BCCVerify&#xA;*输   入:buf 要校验的数据&#xA;        len 校验数据的长&#xA;*输   出:校验值&#xA;*功   能:异或校验&#xA;*******************************************************/&#xA;UCHAR BCCVerify(UCHAR *buf,UINT len)&#xA;{&#xA;    UCHAR s=0;&#xA;    UINT  i;&#xA;    for ( i=0; i&lt;len; i++)&#xA;    {&#xA;        s = s^(*(buf+i));&#xA;    }&#xA;&#xA;    return s;&#xA;}&#xA;&#xA;//======================================================================================&#xA;&#xA;//                                       奇偶校验&#xA;&#xA;//======================================================================================&#xA;&#xA;/******************************************************&#xA;*函数名称:OddParity&#xA;*输   入:buf 要校验的数据; len 校验数据的长&#xA;*输   出:校验和&#xA;*功   能:奇校验&#xA;*******************************************************/&#xA;BOOL OddParity(UCHAR *buf, UINT len)&#xA;{&#xA;    UINT  i=0,j=0;&#xA;    UCHAR d=0;&#xA;    BOOL  bParity=FALSE;&#xA;&#xA;    bParity = 1;&#xA;&#xA;    for(j = 0; j &lt; len; j++)&#xA;    {&#xA;        d = *(buf + j);&#xA;&#xA;        for(i = 0; i &lt; 8; i++)&#xA;        {&#xA;&#xA;            if((d &amp; 0x01) == 0x01)&#xA;            {&#xA;                bParity ^= 1;&#xA;            }&#xA;&#xA;            d = d &gt;&gt; 1;&#xA;        }&#xA;    }&#xA;&#xA;    return bParity;&#xA;}&#xA;/******************************************************&#xA;*函数名称:EvenParity&#xA;*输   入:buf 要校验的数据; len 校验数据的长&#xA;*输   出:校验和&#xA;*功   能:偶校验&#xA;*******************************************************/&#xA;BOOL EvenParity(UCHAR *buf, UINT len)&#xA;{&#xA;    return (!OddParity(buf,len));&#xA;}&#xA;&#xA;//======================================================================================&#xA;&#xA;//                                       循环冗余校验&#xA;&#xA;//======================================================================================&#xA;/******************************************************************&#xA;*  CRC8 码表&#xA;******************************************************************/&#xA;//生成多项式：X8+X5+X4+1=0x31 ，CRC8TAB[1]=生成多项式&#xA;const UCHAR CRC8TAB[256]=&#xA;{&#xA;    //0&#xA;    0x00, 0x31, 0x62, 0x53, 0xC4, 0xF5, 0xA6, 0x97,&#xA;    0xB9, 0x88, 0xDB, 0xEA, 0x7D, 0x4C, 0x1F, 0x2E,&#xA;    //1&#xA;    0x43, 0x72, 0x21, 0x10, 0x87, 0xB6, 0xE5, 0xD4,&#xA;    0xFA, 0xCB, 0x98, 0xA9, 0x3E, 0x0F, 0x5C, 0x6D,&#xA;    //2&#xA;    0x86, 0xB7, 0xE4, 0xD5, 0x42, 0x73, 0x20, 0x11,&#xA;    0x3F, 0x0E, 0x5D, 0x6C, 0xFB, 0xCA, 0x99, 0xA8,&#xA;    //3&#xA;    0xC5, 0xF4, 0xA7, 0x96, 0x01, 0x30, 0x63, 0x52,&#xA;    0x7C, 0x4D, 0x1E, 0x2F, 0xB8, 0x89, 0xDA, 0xEB,&#xA;    //4&#xA;    0x3D, 0x0C, 0x5F, 0x6E, 0xF9, 0xC8, 0x9B, 0xAA,&#xA;    0x84, 0xB5, 0xE6, 0xD7, 0x40, 0x71, 0x22, 0x13,&#xA;    //5&#xA;    0x7E, 0x4F, 0x1C, 0x2D, 0xBA, 0x8B, 0xD8, 0xE9,&#xA;    0xC7, 0xF6, 0xA5, 0x94, 0x03, 0x32, 0x61, 0x50,&#xA;    //6&#xA;    0xBB, 0x8A, 0xD9, 0xE8, 0x7F, 0x4E, 0x1D, 0x2C,&#xA;    0x02, 0x33, 0x60, 0x51, 0xC6, 0xF7, 0xA4, 0x95,&#xA;    //7&#xA;    0xF8, 0xC9, 0x9A, 0xAB, 0x3C, 0x0D, 0x5E, 0x6F,&#xA;    0x41, 0x70, 0x23, 0x12, 0x85, 0xB4, 0xE7, 0xD6,&#xA;    //8&#xA;    0x7A, 0x4B, 0x18, 0x29, 0xBE, 0x8F, 0xDC, 0xED,&#xA;    0xC3, 0xF2, 0xA1, 0x90, 0x07, 0x36, 0x65, 0x54,&#xA;    //9&#xA;    0x39, 0x08, 0x5B, 0x6A, 0xFD, 0xCC, 0x9F, 0xAE,&#xA;    0x80, 0xB1, 0xE2, 0xD3, 0x44, 0x75, 0x26, 0x17,&#xA;    //A&#xA;    0xFC, 0xCD, 0x9E, 0xAF, 0x38, 0x09, 0x5A, 0x6B,&#xA;    0x45, 0x74, 0x27, 0x16, 0x81, 0xB0, 0xE3, 0xD2,&#xA;    //B&#xA;    0xBF, 0x8E, 0xDD, 0xEC, 0x7B, 0x4A, 0x19, 0x28,&#xA;    0x06, 0x37, 0x64, 0x55, 0xC2, 0xF3, 0xA0, 0x91,&#xA;    //C&#xA;    0x47, 0x76, 0x25, 0x14, 0x83, 0xB2, 0xE1, 0xD0,&#xA;    0xFE, 0xCF, 0x9C, 0xAD, 0x3A, 0x0B, 0x58, 0x69,&#xA;    //D&#xA;    0x04, 0x35, 0x66, 0x57, 0xC0, 0xF1, 0xA2, 0x93,&#xA;    0xBD, 0x8C, 0xDF, 0xFE, 0x79, 0x48, 0x1B, 0x2A,&#xA;    //E&#xA;    0xC1, 0xF0, 0xA3, 0x92, 0x05, 0x34, 0x67, 0x56,&#xA;    0x78, 0x49, 0x1A, 0x2B, 0xBC, 0x8D, 0xDE, 0xEF,&#xA;    //F&#xA;    0x82, 0xB3, 0xE0, 0xD1, 0x46, 0x77, 0x24, 0x15,&#xA;    0x3B, 0x0A, 0x59, 0x68, 0xFF, 0xCE, 0x9D, 0xAC&#xA;};&#xA;/******************************************************&#xA;*函数名称:CRC8&#xA;*输   入:buf 要校验的数据; len 校验数据的长&#xA;*输   出:校验值&#xA;*功   能:循环冗余校验-8&#xA;*******************************************************/&#xA;UCHAR CRC8( UCHAR *buf, UINT len)&#xA;{&#xA;    UCHAR  crc=0;&#xA;&#xA;    while ( len-- )&#xA;    {&#xA;        crc = CRC8TAB[crc^*buf];&#xA;&#xA;        buf++;&#xA;    }&#xA;&#xA;    return crc;&#xA;}&#xA;&#xA;/******************************************************&#xA;*函数名称:CRC16TAB&#xA;*输   入:pszBuf  要校验的数据&#xA;        unLength 校验数据的长&#xA;*输   出:校验值&#xA;*功   能:循环冗余校验-16&#xA;&#xA;*******************************************************/&#xA;/*&#xA;*****************************************************************************************&#xA;&#xA;                                创 建 人： L J&#xA;&#xA;                                修改时间： 2008-7-9&#xA;&#xA;                                描    述： CRC16 校验&#xA;&#xA;******************************************************************************************&#xA;*/&#xA;&#xA;unsigned int CRC16Table[256]=                /* CRC16 余式表 */&#xA;{&#xA;    0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,&#xA;    0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,&#xA;    0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,&#xA;    0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,&#xA;    0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,&#xA;    0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,&#xA;    0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,&#xA;    0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,&#xA;    0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,&#xA;    0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,&#xA;    0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,&#xA;    0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,&#xA;    0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,&#xA;    0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,&#xA;    0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,&#xA;    0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,&#xA;    0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,&#xA;    0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,&#xA;    0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,&#xA;    0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,&#xA;    0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,&#xA;    0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,&#xA;    0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,&#xA;    0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,&#xA;    0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,&#xA;    0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,&#xA;    0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,&#xA;    0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,&#xA;    0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,&#xA;    0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,&#xA;    0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,&#xA;    0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0&#xA;};&#xA;&#xA;/*************************************************************&#xA;    描    述：  CRC16校验查表子程序,速度快，占用空间大&#xA;    入口参数：  指向数组指针，校验字节个数&#xA;    出口参数：  16位CRC校验码          ZModem   左移CRC16=X16+X12+X5+1&#xA;**************************************************************/&#xA;unsigned int CRC16_Table(unsigned char *pcrc, unsigned char count)&#xA;{&#xA;    unsigned int  crc16 = 0;&#xA;    unsigned char crcregister;&#xA;&#xA;    for( ; count &gt; 0; count--)&#xA;    {&#xA;        crcregister = (unsigned int)crc16 &gt;&gt; 8;&#xA;        crc16 &lt;&lt;= 8;&#xA;        crc16 ^= CRC16Table[crcregister ^ *pcrc];&#xA;        pcrc++;&#xA;    }&#xA;    return(crc16);&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;/******************************************************&#xA;*函数名称:CRC16Default&#xA;*输   入:pszBuf  要校验的数据&#xA;        unLength 校验数据的长&#xA;*输   出:校验值&#xA;*功   能:循环冗余校验-16&#xA;         （美国标准-0x8005）&#xA;*******************************************************/&#xA;UINT16 CRC16Default(UCHAR * pszBuf, UINT unLength)&#xA;{&#xA;    UINT32 i, j;&#xA;    UINT16 CrcReg = 0xFFFF;&#xA;    UINT16 CurVal;&#xA;&#xA;    for (i = 0; i &lt; unLength; i++)&#xA;    {&#xA;        CurVal = pszBuf[i] &lt;&lt; 8;&#xA;&#xA;        for (j = 0; j &lt; 8; j++)&#xA;        {&#xA;            if ((short)(CrcReg ^ CurVal) &lt; 0)&#xA;                CrcReg = (CrcReg &lt;&lt; 1) ^ 0x8005;&#xA;            else&#xA;                CrcReg &lt;&lt;= 1;&#xA;            CurVal &lt;&lt;= 1;&#xA;        }&#xA;    }&#xA;&#xA;    return CrcReg;&#xA;}&#xA;/******************************************************&#xA;*函数名称:CRC16CCITT&#xA;*输   入:pszBuf  要校验的数据&#xA;        unLength 校验数据的长&#xA;*输   出:校验值&#xA;*功   能:循环冗余校验-16&#xA;         （CCITT标准-0x1021）&#xA;*******************************************************/&#xA;UINT16 CRC16CCITT(UCHAR * pszBuf, UINT unLength)&#xA;{&#xA;&#xA;    UINT32 i, j;&#xA;    UINT16 CrcReg = 0xFFFF;&#xA;    UINT16 CurVal;&#xA;&#xA;    for (i = 0; i &lt; unLength; i++)&#xA;    {&#xA;        CurVal = pszBuf[i] &lt;&lt; 8;&#xA;&#xA;        for (j = 0; j &lt; 8; j++)&#xA;        {&#xA;            if ((short)(CrcReg ^ CurVal) &lt; 0)&#xA;                CrcReg = (CrcReg &lt;&lt; 1) ^ 0x1021;&#xA;            else&#xA;                CrcReg &lt;&lt;= 1;&#xA;            CurVal &lt;&lt;= 1;&#xA;        }&#xA;    }&#xA;&#xA;    return CrcReg;&#xA;}&#xA;/******************************************************&#xA;*函数名称:CRC16RTU&#xA;*输   入:pszBuf  要校验的数据&#xA;        unLength 校验数据的长&#xA;*输   出:校验值&#xA;*功   能:循环冗余校验-16&#xA;         （RTU标准-0xA001）&#xA;*******************************************************/&#xA;UINT16 CRC16RTU( UCHAR * pszBuf, UINT unLength)&#xA;{&#xA;    UINT16 CRC=0XFFFF;&#xA;    UINT32 CRC_count;&#xA;&#xA;    for(CRC_count=0; CRC_count&lt;unLength; CRC_count++)&#xA;    {&#xA;        int i;&#xA;&#xA;        CRC=CRC^*(pszBuf+CRC_count);&#xA;&#xA;        for(i=0; i&lt;8; i++)&#xA;        {&#xA;            if(CRC&amp;1)&#xA;            {&#xA;                CRC&gt;&gt;=1;&#xA;                CRC^=0xA001;&#xA;            }&#xA;            else&#xA;            {&#xA;                CRC&gt;&gt;=1;&#xA;            }&#xA;&#xA;        }&#xA;    }&#xA;&#xA;    return CRC;&#xA;}&#xA;&#xA;&#xA;static unsigned long Reflect(unsigned long ref, char ch)&#xA;{&#xA;    unsigned long value = 0;&#xA;    int i;&#xA;&#xA;    for(  i = 1; i &lt; (ch + 1); i++)&#xA;    {&#xA;        if (ref &amp; 1)&#xA;            value |= 1 &lt;&lt; (ch - i);&#xA;        ref &gt;&gt;= 1;&#xA;    }&#xA;&#xA;    return value;&#xA;}&#xA;/******************************************************&#xA;*函数名称:CRC32Default&#xA;*输   入:pszBuf  要校验的数据&#xA;        unLength 校验数据的长&#xA;*输   出:校验值&#xA;*功   能:循环冗余校验-32&#xA;         （美国标准-0x04C11DB7）&#xA;*******************************************************/&#xA;ULONG CRC32Default(UCHAR *pszBuf,UINT ulLength)&#xA;{&#xA;    unsigned long Result = 0xFFFFFFFF;&#xA;    unsigned long m_Table[256];&#xA;&#xA;    unsigned long ulPolynomial = 0x04C11DB7;&#xA;    int i,j;&#xA;&#xA;    for ( i = 0; i &lt;= 0xFF; i++)&#xA;    {&#xA;        m_Table[i] = Reflect(i, 8) &lt;&lt; 24;&#xA;        for (  j = 0; j &lt; 8; j++)&#xA;            m_Table[i] = (m_Table[i] &lt;&lt; 1) ^ (m_Table[i] &amp; (1 &lt;&lt; 31) ? ulPolynomial : 0);&#xA;        m_Table[i] = Reflect(m_Table[i], 32);&#xA;    }&#xA;&#xA;    while (ulLength--)&#xA;        Result = (Result &gt;&gt; 8) ^ m_Table[(Result &amp; 0xFF) ^ *pszBuf++];&#xA;&#xA;    Result ^= 0xFFFFFFFF;&#xA;&#xA;    return Result;&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;//======================================================================================&#xA;&#xA;//                                       循环冗余校验&#xA;&#xA;//======================================================================================&#xA;/******************************************************************&#xA;*  CRC8 码表&#xA;******************************************************************/&#xA;//生??y?????X5+X4+1=0x31 ，CRC8TAB[1]=生成多项式&#xA;const UCHAR CRC8TAB[256]=&#xA;{&#xA;    //0&#xA;    0x00, 0x31, 0x62, 0x53, 0xC4, 0xF5, 0xA6, 0x97,&#xA;    0xB9, 0x88, 0xDB, 0xEA, 0x7D, 0x4C, 0x1F, 0x2E,&#xA;    //1&#xA;    0x43, 0x72, 0x21, 0x10, 0x87, 0xB6, 0xE5, 0xD4,&#xA;    0xFA, 0xCB, 0x98, 0xA9, 0x3E, 0x0F, 0x5C, 0x6D,&#xA;    //2&#xA;    0x86, 0xB7, 0xE4, 0xD5, 0x42, 0x73, 0x20, 0x11,&#xA;    0x3F, 0x0E, 0x5D, 0x6C, 0xFB, 0xCA, 0x99, 0xA8,&#xA;    //3&#xA;    0xC5, 0xF4, 0xA7, 0x96, 0x01, 0x30, 0x63, 0x52,&#xA;    0x7C, 0x4D, 0x1E, 0x2F, 0xB8, 0x89, 0xDA, 0xEB,&#xA;    //4&#xA;    0x3D, 0x0C, 0x5F, 0x6E, 0xF9, 0xC8, 0x9B, 0xAA,&#xA;    0x84, 0xB5, 0xE6, 0xD7, 0x40, 0x71, 0x22, 0x13,&#xA;    //5&#xA;    0x7E, 0x4F, 0x1C, 0x2D, 0xBA, 0x8B, 0xD8, 0xE9,&#xA;    0xC7, 0xF6, 0xA5, 0x94, 0x03, 0x32, 0x61, 0x50,&#xA;    //6&#xA;    0xBB, 0x8A, 0xD9, 0xE8, 0x7F, 0x4E, 0x1D, 0x2C,&#xA;    0x02, 0x33, 0x60, 0x51, 0xC6, 0xF7, 0xA4, 0x95,&#xA;    //7&#xA;    0xF8, 0xC9, 0x9A, 0xAB, 0x3C, 0x0D, 0x5E, 0x6F,&#xA;    0x41, 0x70, 0x23, 0x12, 0x85, 0xB4, 0xE7, 0xD6,&#xA;    //8&#xA;    0x7A, 0x4B, 0x18, 0x29, 0xBE, 0x8F, 0xDC, 0xED,&#xA;    0xC3, 0xF2, 0xA1, 0x90, 0x07, 0x36, 0x65, 0x54,&#xA;    //9&#xA;    0x39, 0x08, 0x5B, 0x6A, 0xFD, 0xCC, 0x9F, 0xAE,&#xA;    0x80, 0xB1, 0xE2, 0xD3, 0x44, 0x75, 0x26, 0x17,&#xA;    //A&#xA;    0xFC, 0xCD, 0x9E, 0xAF, 0x38, 0x09, 0x5A, 0x6B,&#xA;    0x45, 0x74, 0x27, 0x16, 0x81, 0xB0, 0xE3, 0xD2,&#xA;    //B&#xA;    0xBF, 0x8E, 0xDD, 0xEC, 0x7B, 0x4A, 0x19, 0x28,&#xA;    0x06, 0x37, 0x64, 0x55, 0xC2, 0xF3, 0xA0, 0x91,&#xA;    //C&#xA;    0x47, 0x76, 0x25, 0x14, 0x83, 0xB2, 0xE1, 0xD0,&#xA;    0xFE, 0xCF, 0x9C, 0xAD, 0x3A, 0x0B, 0x58, 0x69,&#xA;    //D&#xA;    0x04, 0x35, 0x66, 0x57, 0xC0, 0xF1, 0xA2, 0x93,&#xA;    0xBD, 0x8C, 0xDF, 0xFE, 0x79, 0x48, 0x1B, 0x2A,&#xA;    //E&#xA;    0xC1, 0xF0, 0xA3, 0x92, 0x05, 0x34, 0x67, 0x56,&#xA;    0x78, 0x49, 0x1A, 0x2B, 0xBC, 0x8D, 0xDE, 0xEF,&#xA;    //F&#xA;    0x82, 0xB3, 0xE0, 0xD1, 0x46, 0x77, 0x24, 0x15,&#xA;    0x3B, 0x0A, 0x59, 0x68, 0xFF, 0xCE, 0x9D, 0xAC&#xA;};&#xA;&#xA;&#xA;&#xA;///////////////////////////// 人机界面部分 ////////////////////////////////////////////&#xA;typedef struct&#xA;{&#xA;    char *name;&#xA;    int  *pFunc;&#xA;    int  resultLen;&#xA;} CHECKLIST;&#xA;&#xA;&#xA;CHECKLIST checkList[]=&#xA;{&#xA;    {&quot;校验和-8&quot;,    (int *)(&amp;CheckSum8),8},&#xA;    {&quot;校验和-16&quot;,   (int *)(&amp;CheckSum16),16},&#xA;    {&quot;校验和-32&quot;,   (int *)(&amp;CheckSum32),32},&#xA;    {&quot;校验和-Intel Hex&quot;,(int *)(&amp;IntelHexCheckSum),8},&#xA;    {&quot;校验和-TCP/IP&quot;,   (int *)(&amp;NetCheckSum),8},&#xA;    {&quot;异或校验&quot;,        (int *)(&amp;BCCVerify),8},&#xA;    {&quot;奇校验&quot;,(int *)(&amp;OddParity),8},&#xA;    {&quot;偶校验&quot;,(int *)(&amp;EvenParity),8},&#xA;    {&quot;CRC-8&quot;,(int *)(&amp;CRC8),8},&#xA;    {&quot;CRC-16 (CCITT标准-0x1021)&quot;,(int *)(&amp;CRC16CCITT),16},&#xA;    {&quot;CRC-16 (美国标准-0x8005)&quot;,(int *)(&amp;CRC16Default),16},&#xA;    {&quot;CRC-16 (RTU标准-0xA001)&quot;,(int *)(&amp;CRC16RTU),16},&#xA;    {&quot;CRC-16 (ZModem-查表)&quot;,(int *)(&amp;CRC16_Table),16},&#xA;    {&quot;CRC-32 (美国标准-0x04C11DB7)&quot;,(int *)(&amp;CRC32Default),32},&#xA;    {&quot;&quot;},&#xA;&#xA;};&#xA;char  (*pCheckFunc8)(char *buf,int len);&#xA;short (*pCheckFunc16)(char *buf,int len);&#xA;int   (*pCheckFunc32)(char *buf,int len);&#xA;&#xA;void OnGetSelDat();&#xA;void OnGetAllDat();&#xA;void OnCalcCheckVal();&#xA;void OnClose()&#xA;{&#xA;    HideVclWin();&#xA;    // printf(&quot;hided&quot;);&#xA;    CloseVclWin();&#xA;}&#xA;&#xA;int edtSdTxt;&#xA;int edtSumTxt;&#xA;int edtSumTxt1;&#xA;int edtDatLen;&#xA;int cbx1;&#xA;void main()&#xA;{&#xA;    int i;&#xA;    ClearOutputWin(); //清除输出窗口内容&#xA;    ClearCommWin();&#xA;    CloseCodeWin();&#xA;    HideRightTools();&#xA;    Update();&#xA;    ClearVclControls();&#xA;    int p=GetGuiWin(0);&#xA;    cbx1=CreateComponentEx(p,&quot;combobox&quot;,&quot;style&quot;,&quot;csdropdownlist&quot;,&quot;left&quot;,460,&quot;top&quot;,4,&quot;width&quot;,220,&quot;height&quot;,20,&quot;itemindex&quot;,2,NULL);//创建按钮&#xA;&#xA;    CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;校验数据:&quot;,&quot;left&quot;,10 ,&quot;top&quot;,8,&quot;width&quot;,170,&quot;height&quot;,20,0);&#xA;    edtSdTxt=CreateComponentEx(p,&quot;memo&quot;,&quot;text&quot;,&quot;12 D4 AA 8E&quot;,&quot;left&quot;,10,&quot;top&quot;,25,&quot;width&quot;,370,&quot;height&quot;,130,&quot;scrollbars&quot;,&quot;ssboth&quot;,0);&#xA;    int button0=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;取发送区反选数据&quot;,&quot;left&quot;,80 ,&quot;top&quot;,3,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnGetSelDat,0);&#xA;    int button1=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;取发送区所有数据&quot;,&quot;left&quot;,240,&quot;top&quot;,3,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnGetAllDat,0);&#xA;    CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot; 校验算法: &quot;,&quot;left&quot;,400-0 ,&quot;top&quot;,2,&quot;width&quot;,60,&quot;height&quot;,24,&quot;color&quot;,0x00ff00,0);&#xA;&#xA;    CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;十进制求和结果:&quot;,&quot;left&quot;,400,&quot;top&quot;,38,&quot;width&quot;,170,&quot;height&quot;,20,0);&#xA;    edtSumTxt=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;&quot;,&quot;left&quot;,100+400,&quot;top&quot;,35,&quot;width&quot;,180,&quot;height&quot;,20,0);&#xA;    int lblDatLen=CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;数据长度:&quot;,&quot;left&quot;, 400,&quot;top&quot;,93,&quot;width&quot;,170,&quot;height&quot;,20,0);&#xA;    edtDatLen=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;&quot;,&quot;left&quot;,100+400,&quot;top&quot;,90,&quot;width&quot;,180,&quot;height&quot;,20,0);&#xA;    int lblSumTxt1=CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;16进制结果:&quot;,&quot;left&quot;, 400,&quot;top&quot;,68,&quot;width&quot;,170,&quot;height&quot;,20,0);&#xA;    edtSumTxt1=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;&quot;,&quot;left&quot;,100+400,&quot;top&quot;,65,&quot;width&quot;,180,&quot;height&quot;,20,0);&#xA;    int button2=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;计算校验&quot;,&quot;left&quot;, 400,&quot;top&quot;,125,&quot;width&quot;,130,&quot;height&quot;,30,&quot;onclick&quot;,OnCalcCheckVal,0);&#xA;    int button1=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;, 550,&quot;top&quot;,125,&quot;width&quot;,130,&quot;height&quot;,30,&quot;onclick&quot;,OnClose,0);&#xA;    //ShowVclWin(150);&#xA;    //ShowOutputWin(200);&#xA;    for(i=0; i&lt;100; i++)&#xA;    {&#xA;        if(checkList[i].name[0]==0)break;&#xA;        StringsAdd(cbx1,checkList[i].name);&#xA;    }&#xA;&#xA;    SetProperty(cbx1,&quot;itemindex&quot;,0);&#xA;    AutoSetVclWinSize();&#xA;}&#xA;&#xA;&#xA;void OnGetSelDat()&#xA;{&#xA;    char s[2000];&#xA;    GetInputWinSelText(s,2000);&#xA;    if(strlen(s)==0) return;&#xA;    SetProperty(edtSdTxt,&quot;text&quot;,s);&#xA;    OnCalcCheckVal();&#xA;}&#xA;void OnGetAllDat()&#xA;{&#xA;    char s[2000];&#xA;    GetInputWinText(s,2000);&#xA;    if(strlen(s)==0) return;&#xA;    SetProperty(edtSdTxt,&quot;text&quot;,s);&#xA;    OnCalcCheckVal();&#xA;}&#xA;&#xA;&#xA;int GetVal(int val)&#xA;{&#xA;    if((val&gt;=48)&amp;&amp;(val&lt;=57))&#xA;        return val-48;&#xA;    else if((val&gt;=97)&amp;&amp;(val&lt;=102))&#xA;        return val+10-97;&#xA;    else if((val&gt;=65)&amp;&amp;(val&lt;=70))&#xA;        return val+10-65;&#xA;&#xA;    return 0;&#xA;}&#xA;&#xA;void isDigit(int val)&#xA;{&#xA;    if((val&gt;=48)&amp;&amp;(val&lt;=57))&#xA;        return 1;&#xA;    else if((val&gt;=97)&amp;&amp;(val&lt;=102))&#xA;        return 1;&#xA;    else if((val&gt;=65)&amp;&amp;(val&lt;=70))&#xA;        return 1;&#xA;    return 0;&#xA;}&#xA;&#xA;void OnCalcCheckVal()&#xA;{&#xA;    int val,val1,gotfirst;&#xA;    char s[2000];&#xA;    char buf[2000];&#xA;    GetProperty(edtSdTxt,&quot;text&quot;,s,2000);&#xA;&#xA;    //s=myForm.edtSdTxt.Text;&#xA;    int i=0;&#xA;    int sum=0;&#xA;    gotfirst=0;&#xA;    int len=0;&#xA;    int ls=strlen(s);&#xA;    while(i&lt;ls)&#xA;    {&#xA;        i=i+1;&#xA;        if(gotfirst==0)&#xA;        {&#xA;            val=s[i-1];&#xA;            if(isDigit(val))&#xA;                gotfirst=1;&#xA;        }&#xA;        else&#xA;        {&#xA;            val1=s[i-1];&#xA;            if(isDigit(val1))&#xA;            {&#xA;                //sum=sum+GetVal(val)*16+GetVal(val1);&#xA;                buf[len]=GetVal(val)*16+GetVal(val1);&#xA;                len=len+1;&#xA;                gotfirst=0;&#xA;            }&#xA;            else&#xA;            {&#xA;                //sum=sum+GetVal(val);&#xA;                buf[len]=GetVal(val);&#xA;                len=len+1;&#xA;                gotfirst=0;&#xA;            }&#xA;        }&#xA;    }&#xA;    if(gotfirst==1)&#xA;    {&#xA;        sum=sum+GetVal(val);&#xA;        len=len+1;&#xA;    }&#xA;&#xA;    int idx;&#xA;&#xA;    idx=GetProperty(cbx1,&quot;itemindex&quot;,0,0);&#xA;    if(checkList[idx].resultLen==8)&#xA;    {&#xA;        pCheckFunc8=checkList[idx].pFunc;&#xA;        sum=pCheckFunc8(buf,len);&#xA;        //printf(&quot;name:%s,val:%x&quot;,checkList[idx].name,sum);&#xA;    }&#xA;    else if(checkList[idx].resultLen==16)&#xA;    {&#xA;        pCheckFunc16=checkList[idx].pFunc;&#xA;        sum=pCheckFunc16(buf,len);&#xA;        //printf(&quot;name:%s,val:%x&quot;,checkList[idx].name,sum);&#xA;    }&#xA;    else if(checkList[idx].resultLen==32)&#xA;    {&#xA;        pCheckFunc32=checkList[idx].pFunc;&#xA;        sum=pCheckFunc32(buf,len);&#xA;        //printf(&quot;name:%s,val:%x&quot;,checkList[idx].name,sum);&#xA;    }&#xA;&#xA;    if(checkList[idx].resultLen==8)&#xA;        sum&amp;=0xff;&#xA;    if(checkList[idx].resultLen==16)&#xA;        sum&amp;=0xffff;&#xA;&#xA;    sprintf(s,&quot;%d&quot;,sum);&#xA;    SetProperty(edtSumTxt,&quot;text&quot;,s);&#xA;&#xA;    if(checkList[idx].resultLen==8)&#xA;        sprintf(s,&quot;%02X&quot;,sum);&#xA;    if(checkList[idx].resultLen==16)&#xA;        sprintf(s,&quot;%04X&quot;,sum);&#xA;    if(checkList[idx].resultLen==32)&#xA;        sprintf(s,&quot;%08X&quot;,sum);&#xA;&#xA;    SetProperty(edtSumTxt1,&quot;text&quot;,s);&#xA;    sprintf(s,&quot;%d&quot;,len);&#xA;    SetProperty(edtDatLen,&quot;text&quot;,s);&#xA;}"/>
  <Command cmdname="发送文件" cmdType="P" cmd="[P]#include &quot;windows.h&quot;&#xA;#include &lt;stdio.h&gt;&#xA;#include &lt;string.h&gt;&#xA;&#xA;#define BUF_LEN 1&#xA;#define LINE     15&#xA;int p;&#xA;FILE *source,*dest;&#xA;int edt1,edt2,edt3,lblSentCount,lblFileSize;&#xA;&#xA;int cbHex;&#xA;int cbx1,cbx2;&#xA;int tmr1;&#xA;int btn0,btn1,btn2;&#xA;int txt6;&#xA;int pgb1;&#xA;&#xA;unsigned char *fileDatBuf;&#xA;int fsize=0;&#xA;int sendIdx=0;&#xA;int onePktLen;&#xA;long int filesize( FILE *fp )&#xA;{&#xA;    long int save_pos, size_of_file;&#xA;&#xA;    save_pos = ftell( fp );&#xA;    fseek( fp, 0L, SEEK_END );&#xA;    size_of_file = ftell( fp );&#xA;    fseek( fp, save_pos, SEEK_SET );&#xA;    return( size_of_file );&#xA;}&#xA;&#xA;&#xA;void OpenFileClick(void *sender)&#xA;{&#xA;    char s[200];&#xA;    GetFileName(s,200,&quot;*.*&quot;);&#xA;    if(strlen(s)&gt;0)&#xA;    {&#xA;        SetProperty(edt1,&quot;text&quot;,s);&#xA;    }&#xA;}&#xA;&#xA;&#xA;void SendFileData()&#xA;{&#xA;    char  fname[255];&#xA;    unsigned char s[100],ch[3];&#xA;    int i,count,ck;&#xA;    unsigned char *tmpBuf;&#xA;    unsigned char buffer[1024] ;&#xA;    int c;&#xA;&#xA;    if(fsize&gt;0)free(fileDatBuf);&#xA;    fsize=0;&#xA;&#xA;    GetProperty(edt1,&quot;text&quot;,fname,200);&#xA;    ch[0]=0;&#xA;    ch[2]=0;&#xA;&#xA;&#xA;    SetProperty(lblSentCount,&quot;caption&quot;,&quot;  已发送: 0 字节&quot;);&#xA;   &#xA;    //SetProperty(lblFileSize,&quot;caption&quot;,&quot;文件大小: 0 字节&quot;);&#xA;&#xA;    if( (source=fopen(fname, &quot;rb&quot; )) == NULL )&#xA;    {&#xA;        sprintf(s,&quot;文件[%s]不存在!&quot;,fname);&#xA;        ShowMessage(s);&#xA;        return;&#xA;    }&#xA;    sendIdx=0;&#xA;    if(fsize&gt;0)free(fileDatBuf);&#xA;    fsize=filesize(source);&#xA;    sprintf(s,&quot;文件大小: %d 字节&quot;,fsize);&#xA;    SetProperty(lblFileSize,&quot;caption&quot;,s);    &#xA;    //Update(lblSentCount);   &#xA;    &#xA;    ck=GetProperty(cbHex,&quot;checked&quot;,s,4);&#xA;    if(ck)&#xA;    {&#xA;        tmpBuf=(unsigned char *)malloc(fsize);&#xA;        fileDatBuf=(unsigned char *)malloc(fsize );&#xA;        count=fread(tmpBuf,1,fsize,source);&#xA;        //printf(&quot;file read:%d &quot;,count );&#xA;        fsize=0;&#xA;        i=0;&#xA;        while(i&lt;count)&#xA;        {&#xA;            if(((tmpBuf[i]&gt;='0')&amp;&amp;&#xA;                    (tmpBuf[i]&lt;='9'))||&#xA;                    ((tmpBuf[i]&gt;='a')&amp;&amp;&#xA;                     (tmpBuf[i]&lt;='f'))||&#xA;                    ((tmpBuf[i]&gt;='A')&amp;&amp;&#xA;                     (tmpBuf[i]&lt;='F')))&#xA;            {&#xA;                if(ch[0]==0)&#xA;                    ch[0]=tmpBuf[i];&#xA;                else&#xA;                {&#xA;                    ch[1]=tmpBuf[i];&#xA;                    fileDatBuf[fsize]=HexStrToInt(ch);&#xA;                    fsize++;&#xA;                    ch[0]=0;&#xA;&#xA;                }&#xA;            }&#xA;            i++;&#xA;        }&#xA;        free(tmpBuf);&#xA;    }&#xA;    else&#xA;    {&#xA;        fileDatBuf=malloc(fsize);&#xA;        count=fread(fileDatBuf,1,fsize,source);&#xA;        //printf(&quot;file read:%d &quot;,count );&#xA;    }&#xA;&#xA;&#xA;&#xA;    fclose(source);&#xA;    GetProperty(cbx2,&quot;text&quot;,s,200);&#xA;    onePktLen=atoi(s);&#xA;    if(onePktLen&lt;1)onePktLen=1;&#xA;    //printf(&quot;read OK!&quot;);&#xA;    &#xA;&#xA;&#xA;}&#xA;&#xA;&#xA;void OnClose(int *sender)&#xA;{&#xA;&#xA;    HideVclWin();&#xA;    CloseVclWin();&#xA;    ////PrintToCommWin(&quot;over&quot;);&#xA;&#xA;}&#xA;void OnStart(void *sender)&#xA;{&#xA;    char s[200];&#xA;    GetProperty(cbx1,&quot;text&quot;,s,20);&#xA;    int inv=atoi(s);&#xA;    //printf(&quot;%d&quot;,inv);&#xA;    SendFileData();&#xA;    if(fsize&gt;0)&#xA;    {&#xA;        SetProperty(tmr1,&quot;interval&quot;,inv);&#xA;        SetProperty(tmr1,&quot;enabled&quot;,1);&#xA;        SetProperty(btn1,&quot;enabled&quot;,0);&#xA;        SetProperty(btn2,&quot;enabled&quot;,1);&#xA;        SetProperty(txt6,&quot;caption&quot;,&quot;0%&quot;);&#xA;        SetProperty(pgb1,&quot;position&quot;,0);&#xA;&#xA;&#xA;    }&#xA;    //myForm.btnStart.Enabled=false;&#xA;    //myForm.btnStop.Enabled=true;&#xA;}&#xA;void OnStop()&#xA;{&#xA;    SetProperty(tmr1,&quot;enabled&quot;,0);&#xA;    SetProperty(btn1,&quot;enabled&quot;,1);&#xA;    SetProperty(btn2,&quot;enabled&quot;,0);&#xA;&#xA;    if(fsize&gt;0)free(fileDatBuf);&#xA;    fsize=0;&#xA;}&#xA;void OnTimer()&#xA;{&#xA;    char s[200];&#xA;    int  count;&#xA;&#xA;&#xA;    GetProperty(edt1,&quot;text&quot;,s,200);&#xA;&#xA;    if(sendIdx&lt;fsize)&#xA;    {&#xA;        if(fsize-sendIdx&gt;onePktLen)&#xA;            count=onePktLen;&#xA;        else&#xA;            count=fsize-sendIdx;&#xA;        SendBuffer(&amp;fileDatBuf[sendIdx],count);&#xA;        //printf(&quot;fsize:%d,sendidx:%d&quot;,fsize,sendIdx);&#xA;        sendIdx+=count;&#xA;        sprintf(s,&quot;  已发送: %d 字节&quot;,sendIdx);&#xA;        SetProperty(lblSentCount,&quot;caption&quot;,s);&#xA;        sprintf(s,&quot;%2.0f%%&quot;,sendIdx*1.0/fsize*100.0);&#xA;        SetProperty(txt6,&quot;caption&quot;,s);&#xA;        SetProperty(pgb1,&quot;position&quot;,sendIdx*100/fsize);&#xA;        //int pgb1=&#xA;    }&#xA;    if(sendIdx&gt;=fsize)&#xA;    {&#xA;&#xA;        if(fsize&gt;0)free(fileDatBuf);&#xA;        fsize=0;&#xA;        OnStop();&#xA;        Update(lblSentCount);&#xA;        ShowMessage(&quot;文件发送结束!&quot;);&#xA;    }&#xA;   // Update(lblSentCount);&#xA;&#xA;}&#xA;&#xA;&#xA;void main()&#xA;{&#xA;    ClearOutputWin();   //清除输出窗口内容&#xA;    ClearCommWin();&#xA;    //CloseInputWin();&#xA;    CloseCodeWin();//&#xA;    HideLeftTools();&#xA;    HideRightTools();&#xA;    HideOutputWin();&#xA;    ClearVclControls();&#xA;    int p=GetGuiWin(0);&#xA;&#xA;    btn0=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关    闭&quot;,     &quot;left&quot;,340,&quot;top&quot;,120,&quot;width&quot;,110,&quot;height&quot;,25,&quot;onclick&quot;,OnClose,NULL);//创建按钮&#xA;    btn1=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;开始发送&quot;, &quot;left&quot;,10,&quot;top&quot;,120,&quot;width&quot;,110,&quot;height&quot;,25,&quot;onclick&quot;,OnStart,NULL);//创建按钮&#xA;    btn2=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;停止发送&quot;, &quot;left&quot;,135,&quot;top&quot;,120,&quot;width&quot;,110,&quot;height&quot;,25,&quot;onclick&quot;,OnStop,NULL);//创建按钮&#xA;    int lbl1=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;文件名称:&quot;,&quot;left&quot;,10,&quot;top&quot;,8,&quot;width&quot;,90,&quot;height&quot;,20,NULL);//创建按钮&#xA;    edt1=CreateComponentEx(p,&quot;edit&quot;,  &quot;text&quot;,   &quot;c:\\tmp.txt&quot;,   &quot;left&quot;,70,&quot;top&quot;,5,&quot;width&quot;,330,&quot;height&quot;,20,NULL);//创建按钮&#xA;    //btn0=&#xA;    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;...&quot;,     &quot;left&quot;,410,&quot;top&quot;,4,&quot;width&quot;,40,&quot;height&quot;,23,&quot;onclick&quot;,OpenFileClick,NULL);//创建按钮&#xA;&#xA;    cbHex=CreateComponentEx(p,&quot;checkbox&quot;,&quot;caption&quot;,&quot;十六进制发送&quot;,&quot;left&quot;,10,&quot;top&quot;,35,&quot;width&quot;,100,&quot;height&quot;,20,NULL);//创建按钮&#xA;    int lbl2=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;发送间隔:&quot;,&quot;left&quot;,145,&quot;top&quot;,37,&quot;width&quot;,70,&quot;height&quot;,20,NULL);//创建按钮&#xA;    cbx1=CreateComponentEx(p,&quot;combobox&quot;,&quot;text&quot;,&quot;100&quot;,&quot;left&quot;,203,&quot;top&quot;,35,&quot;width&quot;,60,&quot;height&quot;,20,NULL);//创建按钮&#xA;    int lbl3=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;毫秒&quot;,&quot;left&quot;,270,&quot;top&quot;,37,&quot;width&quot;,70,&quot;height&quot;,20,NULL);//创建按钮&#xA;&#xA;    int lbl2=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;每包长度:&quot;,&quot;left&quot;,313,&quot;top&quot;,37,&quot;width&quot;,70,&quot;height&quot;,20,NULL);//创建按钮&#xA;    cbx2=CreateComponentEx(p,&quot;combobox&quot;,&quot;text&quot;,&quot;128&quot;,&quot;left&quot;,370,&quot;top&quot;,35,&quot;width&quot;,50,&quot;height&quot;,20,NULL);//创建按钮&#xA;    int lbl3=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;字节&quot;,&quot;left&quot;,425,&quot;top&quot;,37,&quot;width&quot;,70,&quot;height&quot;,20,NULL);//创建按钮&#xA;&#xA;    lblFileSize=CreateComponentEx(p,&quot;label&quot;,  &quot;caption&quot;,&quot;文件大小: 0 字节&quot;,&quot;left&quot;,10,&quot;top&quot;,67,&quot;width&quot;,320,&quot;height&quot;,24,&quot;autosize&quot;,&quot;false&quot;,&quot;color&quot;,0x004000,NULL);//创建按钮&#xA;    lblSentCount=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;  已发送: 0 字节&quot;,&quot;left&quot;,310,&quot;top&quot;,67,&quot;width&quot;,140,&quot;height&quot;,24,&quot;autosize&quot;,&quot;false&quot;,&quot;color&quot;,0x004000,NULL);//创建按钮&#xA;    tmr1=CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,500,&quot;enabled&quot;,0,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮&#xA;    //int img=CreateComponentEx(p,&quot;image&quot;,&quot;left&quot;,20,&quot;top&quot;,170,&quot;width&quot;,100,&quot;height&quot;,130,NULL);//创建按钮&#xA;    //int canvas=GetProperty(img,&quot;canvas&quot;,0,0);&#xA;    //LineTo(canvas,100,100);&#xA;&#xA;    CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;下载进度：&quot;,&quot;left&quot;,10,&quot;top&quot;,97,&quot;width&quot;,60,NULL);&#xA;    txt6= CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;0%&quot;,&quot;left&quot;,80,&quot;top&quot;,97,&quot;width&quot;,40,NULL);&#xA;    pgb1= CreateComponentEx(p,&quot;progressbar&quot;,&quot;left&quot;,120,&quot;top&quot;,95,&quot;width&quot;,330,&quot;height&quot;,16,&quot;position&quot;,0,NULL);&#xA;    //int xx=CreateComponentEx(p,&quot;ShockwaveFlash&quot;,&quot;left&quot;,120,&quot;top&quot;,155,&quot;width&quot;,330,&quot;height&quot;,200,&quot;position&quot;,0,NULL);&#xA;    &#xA;    //SetProperty(xx,&quot;movie&quot;,&quot;c:\\unitsConvert.swf&quot;,19);&#xA;    int ft=GetProperty(lblSentCount,&quot;font&quot;,0,0);&#xA;    SetProperty(ft,&quot;color&quot;,0x00ff00,0);&#xA;    ft=GetProperty(lblFileSize,&quot;font&quot;,0,0);&#xA;    SetProperty(ft,&quot;color&quot;,0x00ff00,0);&#xA;    StringsAdd(cbx1,&quot;1&quot;);&#xA;    StringsAdd(cbx1,&quot;100&quot;);&#xA;    StringsAdd(cbx1,&quot;200&quot;);&#xA;    StringsAdd(cbx1,&quot;500&quot;);&#xA;    StringsAdd(cbx1,&quot;1000&quot;);&#xA;    StringsAdd(cbx2,&quot;1&quot;);&#xA;    StringsAdd(cbx2,&quot;16&quot;);&#xA;    StringsAdd(cbx2,&quot;32&quot;);&#xA;    StringsAdd(cbx2,&quot;64&quot;);&#xA;    StringsAdd(cbx2,&quot;128&quot;);&#xA;    StringsAdd(cbx2,&quot;512&quot;);&#xA;    StringsAdd(cbx2,&quot;1024&quot;);&#xA;    StringsAdd(cbx2,&quot;2048&quot;);&#xA;&#xA;&#xA;    //ShowVclWin(120);&#xA;    AutoSetVclWinSize();&#xA;&#xA;}"/>
</root>
